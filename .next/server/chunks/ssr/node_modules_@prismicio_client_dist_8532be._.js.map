{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"filter.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/filter.ts"],"sourcesContent":["/**\n * Formats the value of a filter element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value}\"`\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`\n\t}\n\n\treturn `${value}`\n}\n\n/**\n * Creates a filter builder function for filters with a path and arguments.\n *\n * @typeParam Args - Arguments for the filter.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathWithArgsFilter = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \")\n\t\tconst joiner = path && args.length ? \", \" : \"\"\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`\n\t}\n\n\treturn fn\n}\n\n/**\n * Creates a filter builder function for filters with only a path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathFilter = (name: string) => {\n\tconst filterFn = pathWithArgsFilter(name)\n\n\t/**\n\t * @param path - Path for the filter.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn filterFn(path)\n\t}\n\n\treturn fn\n}\n\n/**\n * Creates a filter builder function for filters with only arguments and no\n * path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst argsFilter = <Args extends unknown[]>(name: string) => {\n\tconst filterFn = pathWithArgsFilter<Args>(name)\n\n\t/**\n\t * @param args - Arguments for the filter.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn filterFn(\"\", ...args)\n\t}\n\n\treturn fn\n}\n\nexport const filter = {\n\t/**\n\t * The `at` filter checks that the path matches the described value exactly.\n\t * It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#at}\n\t */\n\tat: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"at\",\n\t),\n\n\t/**\n\t * The `not` filter checks that the path doesn't match the provided value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#not}\n\t */\n\tnot: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"not\",\n\t),\n\n\t/**\n\t * The `any` filter takes an array of values. It works exactly the same way as\n\t * the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#any}\n\t */\n\tany: pathWithArgsFilter<[values: (string | number | boolean | Date)[]]>(\n\t\t\"any\",\n\t),\n\n\t/**\n\t * The `in` filter is used specifically to retrieve an array of documents by\n\t * their IDs or UIDs. This filter is much more efficient at this than the any\n\t * filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#in}\n\t */\n\tin: pathWithArgsFilter<[values: string[]]>(\"in\"),\n\n\t/**\n\t * The `fulltext` filter provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom typeâ€™s Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}\n\t */\n\tfulltext: pathWithArgsFilter<[searchTerms: string]>(\"fulltext\"),\n\n\t/**\n\t * The `has` filter checks whether a fragment has a value. It will return all\n\t * the documents of the specified type that contain a value for the specified\n\t * field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#has}\n\t */\n\thas: pathFilter(\"has\"),\n\n\t/**\n\t * The `missing` filter checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#missing}\n\t */\n\tmissing: pathFilter(\"missing\"),\n\n\t/**\n\t * The `similar` filter takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#similar}\n\t */\n\tsimilar: argsFilter<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` filter checks that the value in the path is within the\n\t * radius of the given coordinates.\n\t *\n\t * This filter will only work for a geopoint field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsFilter<[latitude: number, longitude: number, radius: number]>(\n\t\t\t\"geopoint.near\",\n\t\t),\n\n\t/**\n\t * The `number.lt` filter checks that the value in the number field is less\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}\n\t */\n\tnumberLessThan: pathWithArgsFilter<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` filter checks that the value in the number field is greater\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}\n\t */\n\tnumberGreaterThan: pathWithArgsFilter<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` filter checks that the value in the path is within the\n\t * two values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsFilter<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` filter checks that the value in the path is after the date\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateAfter: pathWithArgsFilter<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` filter checks that the value in the path is before the\n\t * date value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBefore: pathWithArgsFilter<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` filter checks that the value in the path is within the\n\t * date values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBetween:\n\t\tpathWithArgsFilter<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` filter checks that the value in the path is equal\n\t * to the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonth: pathWithArgsFilter<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` filter checks that the value in the path is\n\t * after the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` filter checks that the value in the path is\n\t * before the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` filter checks that the value in the path is equal to\n\t * the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeek: pathWithArgsFilter<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` filter checks that the value in the path is\n\t * after the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before filter checks that the value in the path is\n\t * before the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` filter checks that the value in the path occurs in the\n\t * month value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonth: pathWithArgsFilter<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` filter checks that the value in the path occurs in\n\t * any month after the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` filter checks that the value in the path occurs in\n\t * any month before the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` filter checks that the value in the path occurs in the year\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateYear: pathWithArgsFilter<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` filter checks that the value in the path occurs within the\n\t * hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHour: pathWithArgsFilter<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` filter checks that the value in the path occurs after\n\t * the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourAfter: pathWithArgsFilter<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` filter checks that the value in the path occurs\n\t * before the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourBefore: pathWithArgsFilter<[hour: number]>(\"date.hour-before\"),\n}\n"],"names":[],"mappings":";;;AAQA,MAAM,cAAc,CACnB,UAMW;IACP,IAAA,MAAM,OAAA,CAAQ,KAAK,GAAG;QACzB,OAAO,CAAA,CAAA,EAAI,MAAM,GAAA,CAAI,WAAW,EAAE,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAA;IAC7C;IAEI,IAAA,OAAO,UAAU,UAAU;QAC9B,OAAO,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,CAAA;IACjB;IAEA,IAAI,iBAAiB,MAAM;QACnB,OAAA,GAAG,MAAM,OAAA,CAAA,CAAS,EAAA;IAC1B;IAEA,OAAO,GAAG,KAAK,EAAA;AAChB;AAWA,MAAM,qBAAqB,CAAyB,SAAgB;IAI7D,MAAA,KAAK,CAAC,MAAA,GAAiB,SAAsB;QAClD,MAAM,gBAAgB,KAAK,GAAA,CAAI,WAAW,EAAE,IAAA,CAAK,IAAI;QACrD,MAAM,SAAS,QAAQ,KAAK,MAAA,GAAS,OAAO;QAE5C,OAAO,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA,EAAI,IAAI,GAAG,MAAM,GAAG,aAAa,CAAA,EAAA,CAAA;IAAA;IAG1C,OAAA;AACR;AASA,MAAM,aAAa,CAAC,SAAgB;IAC7B,MAAA,WAAW,mBAAmB,IAAI;IAKlC,MAAA,KAAK,CAAC,SAAwB;QACnC,OAAO,SAAS,IAAI;IAAA;IAGd,OAAA;AACR;AAUA,MAAM,aAAa,CAAyB,SAAgB;IACrD,MAAA,WAAW,mBAAyB,IAAI;IAKxC,MAAA,KAAK,CAAA,GAAI,SAAsB;QAC7B,OAAA,SAAS,IAAI,GAAG,IAAI;IAAA;IAGrB,OAAA;AACR;AAEO,MAAM,SAAS;IAAA;;;;;GAAA,GAOrB,IAAI,mBACH,IAAI;IAAA;;;;;GAAA,GASL,KAAK,mBACJ,KAAK;IAAA;;;;;;GAAA,GAUN,KAAK,mBACJ,KAAK;IAAA;;;;;;GAAA,GAUN,IAAI,mBAAuC,IAAI;IAAA;;;;;;;;;GAAA,GAY/C,UAAU,mBAA0C,UAAU;IAAA;;;;;;GAAA,GAS9D,KAAK,WAAW,KAAK;IAAA;;;;;;GAAA,GASrB,SAAS,WAAW,SAAS;IAAA;;;;;;GAAA,GAS7B,SAAS,WAAwC,SAAS;IAAA;;;;;;;GAAA,GAU1D,cACC,mBACC,eAAe;IAAA;;;;;GAAA,GASjB,gBAAgB,mBAAoC,WAAW;IAAA;;;;;GAAA,GAQ/D,mBAAmB,mBAAoC,WAAW;IAAA;;;;;GAAA,GAQlE,eACC,mBACC,gBAAgB;IAAA;;;;;GAAA,GASlB,WAAW,mBAAmD,YAAY;IAAA;;;;;GAAA,GAQ1E,YAAY,mBAAmD,aAAa;IAAA;;;;;GAAA,GAQ5E,aACC,mBAEE,cAAc;IAAA;;;;;GAAA,GAQjB,gBAAgB,mBAAkC,mBAAmB;IAAA;;;;;GAAA,GAQrE,qBAAqB,mBACpB,yBAAyB;IAAA;;;;;GAAA,GAS1B,sBAAsB,mBACrB,0BAA0B;IAAA;;;;;GAAA,GAS3B,eAAe,mBAA2C,kBAAkB;IAAA;;;;;GAAA,GAQ5E,oBAAoB,mBACnB,wBAAwB;IAAA;;;;;GAAA,GASzB,qBAAqB,mBACpB,yBAAyB;IAAA;;;;;GAAA,GAS1B,WAAW,mBAA6C,YAAY;IAAA;;;;;GAAA,GAQpE,gBACC,mBAA6C,kBAAkB;IAAA;;;;;GAAA,GAQhE,iBACC,mBAA6C,mBAAmB;IAAA;;;;;GAAA,GAQjE,UAAU,mBAAmC,WAAW;IAAA;;;;;GAAA,GAQxD,UAAU,mBAAmC,WAAW;IAAA;;;;;GAAA,GAQxD,eAAe,mBAAmC,iBAAiB;IAAA;;;;;GAAA,GAQnE,gBAAgB,mBAAmC,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"file":"mapSliceZone.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/mapSliceZone.ts"],"sourcesContent":["import type { Slice } from \"../types/value/slice\"\n\n/**\n * Convert a value to a lazyily loaded module. This is useful when using\n * functions like `() => import(\"...\")`.\n */\ntype LazyModule<T> = () => Promise<T | { default: T }>\n\n/**\n * Mark a type as potentially lazy-loaded via a module.\n */\ntype MaybeLazyModule<T> = T | LazyModule<T>\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyFunction = (...args: any[]) => any\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam Slice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends SliceLikeRestV2\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceLikeGraphQL\n\t\t? TSlice[\"type\"]\n\t\t: never\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * Rest API V2 for the `mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLikeRestV2<TSliceType extends string = string> = Pick<\n\tSlice<TSliceType>,\n\t\"id\" | \"slice_type\"\n>\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * GraphQL API for the `mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLikeGraphQL<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"]\n}\n\n/**\n * The minimum required properties to represent a Prismic Slice for the\n * `mapSliceZone()` helper.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLike<TSliceType extends string = string> =\n\t| SliceLikeRestV2<TSliceType>\n\t| SliceLikeGraphQL<TSliceType>\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/client` using\n * `SliceLike`.\n *\n * If using Prismic's Rest API V2, use the `SliceZone` export from\n * `@prismicio/client` for the full type.\n *\n * @typeParam TSlice - The type(s) of a Slice in the Slice Zone.\n */\ntype SliceZoneLike<TSlice extends SliceLike = SliceLike> = readonly TSlice[]\n\n/**\n * A set of properties that identify a Slice as having been mapped. Consumers of\n * the mapped Slice Zone can use these properties to detect and specially handle\n * mapped Slices.\n */\ntype MappedSliceLike = {\n\t/**\n\t * If `true`, this Slice has been modified from its original value using a\n\t * mapper.\n\t *\n\t * @internal\n\t */\n\t__mapped: true\n}\n\n/**\n * Arguments for a function mapping content from a Prismic Slice using the\n * `mapSliceZone()` helper.\n *\n * @typeParam TSlice - The Slice passed as a prop.\n * @typeParam TContext - Arbitrary data passed to `mapSliceZone()` and made\n *   available to all Slice mappers.\n */\ntype SliceMapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data.\n\t */\n\tslice: TSlice\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<\n\t\tTSlice extends SliceLikeGraphQL ? SliceLikeGraphQL : SliceLikeRestV2\n\t>\n\n\t/**\n\t * Arbitrary data passed to `mapSliceZone()` and made available to all Slice\n\t * mappers.\n\t */\n\tcontext: TContext\n}\n\n/**\n * A record of mappers.\n */\ntype SliceMappers<TSlice extends SliceLike = SliceLike, TContext = unknown> = {\n\t[P in ExtractSliceType<TSlice>]?: MaybeLazyModule<\n\t\tSliceMapper<\n\t\t\tExtract<TSlice, SliceLike<P>>,\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tany,\n\t\t\tTContext\n\t\t>\n\t>\n}\n\n/**\n * A function that maps a Slice and its metadata to a modified version. The\n * return value will replace the Slice in the Slice Zone.\n */\nexport type SliceMapper<\n\tTSlice extends SliceLike = SliceLike,\n\tTMappedSlice extends Record<string, unknown> | undefined | void =\n\t\t| Record<string, unknown>\n\t\t| undefined\n\t\t| void,\n\tTContext = unknown,\n> = (\n\targs: SliceMapperArgs<TSlice, TContext>,\n) => TMappedSlice | Promise<TMappedSlice>\n\n/**\n * Unwraps a lazily loaded mapper module.\n */\ntype ResolveLazySliceMapperModule<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSliceMapper extends SliceMapper<any, any> | LazyModule<SliceMapper>,\n> =\n\tTSliceMapper extends LazyModule<SliceMapper>\n\t\t? Awaited<ReturnType<TSliceMapper>> extends {\n\t\t\t\tdefault: unknown\n\t\t\t}\n\t\t\t? Awaited<ReturnType<TSliceMapper>>[\"default\"]\n\t\t\t: Awaited<ReturnType<TSliceMapper>>\n\t\t: TSliceMapper\n\n/**\n * Transforms a Slice into its mapped version.\n */\ntype MapSliceLike<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSliceLike extends SliceLike<any>,\n\tTSliceMappers extends SliceMappers<\n\t\tTSliceLike,\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tany\n\t>,\n> = TSliceLike extends Slice\n\t? TSliceLike[\"slice_type\"] extends keyof TSliceMappers\n\t\t? TSliceMappers[TSliceLike[\"slice_type\"]] extends AnyFunction\n\t\t\t? SliceLikeRestV2<TSliceLike[\"slice_type\"]> &\n\t\t\t\t\tMappedSliceLike &\n\t\t\t\t\tAwaited<\n\t\t\t\t\t\tReturnType<\n\t\t\t\t\t\t\tResolveLazySliceMapperModule<\n\t\t\t\t\t\t\t\tTSliceMappers[TSliceLike[\"slice_type\"]]\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t: TSliceLike\n\t\t: TSliceLike\n\t: TSliceLike extends SliceLikeGraphQL\n\t\t? TSliceLike[\"type\"] extends keyof TSliceMappers\n\t\t\t? TSliceMappers[TSliceLike[\"type\"]] extends AnyFunction\n\t\t\t\t? SliceLikeGraphQL<TSliceLike[\"type\"]> &\n\t\t\t\t\t\tMappedSliceLike &\n\t\t\t\t\t\tAwaited<\n\t\t\t\t\t\t\tReturnType<\n\t\t\t\t\t\t\t\tResolveLazySliceMapperModule<TSliceMappers[TSliceLike[\"type\"]]>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t: TSliceLike\n\t\t\t: TSliceLike\n\t\t: never\n\n/**\n * Transforms a Slice Zone using a set of mapping functions, one for each type\n * of Slice. Mapping functions can be async.\n *\n * Whenever possible, use this function on the server to minimize client-side\n * processing.\n *\n * @example\n *\n * ```typescript\n * const mappedSliceZone = await mapSliceZone(page.data.slices, {\n * \tcode_block: ({ slice }) => ({\n * \t\tcodeHTML: await highlight(slice.primary.code),\n * \t}),\n * });\n * ```\n */\nexport function mapSliceZone<\n\tTSliceLike extends SliceLike,\n\tTSliceMappers extends SliceMappers<TSliceLike, TContext>,\n\tTContext = unknown,\n>(\n\tsliceZone: SliceZoneLike<TSliceLike>,\n\tmappers: TSliceMappers,\n\tcontext?: TContext,\n): Promise<MapSliceLike<TSliceLike, TSliceMappers>[]> {\n\treturn Promise.all(\n\t\tsliceZone.map(async (slice, index, slices) => {\n\t\t\tconst isRestSliceType = \"slice_type\" in slice\n\t\t\tconst sliceType = isRestSliceType ? slice.slice_type : slice.type\n\n\t\t\tconst mapper = mappers[sliceType as keyof typeof mappers]\n\n\t\t\tif (!mapper) {\n\t\t\t\treturn slice\n\t\t\t}\n\n\t\t\tconst mapperArgs = { slice, slices, index, context }\n\n\t\t\t// `result` may be a mapper function OR a module\n\t\t\t// containing a mapper function.\n\t\t\tlet result = await mapper(\n\t\t\t\t// @ts-expect-error - I don't know how to fix this type\n\t\t\t\tmapperArgs,\n\t\t\t)\n\n\t\t\t// `result` is a module containing a mapper function,\n\t\t\t// we need to dig out the mapper function. `result`\n\t\t\t// will be reassigned with the mapper function's value.\n\t\t\tif (\n\t\t\t\t// `mapper.length < 1` ensures the given\n\t\t\t\t// function is something of the form:\n\t\t\t\t// `() => import(...)`\n\t\t\t\tmapper.length < 1 &&\n\t\t\t\t(typeof result === \"function\" ||\n\t\t\t\t\t(typeof result === \"object\" && \"default\" in result))\n\t\t\t) {\n\t\t\t\tresult = \"default\" in result ? result.default : result\n\t\t\t\tresult = await result(mapperArgs)\n\t\t\t}\n\n\t\t\tif (isRestSliceType) {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\tid: slice.id,\n\t\t\t\t\tslice_type: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\ttype: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t)\n}\n"],"names":[],"mappings":";;;AAmOgB,SAAA,aAKf,SAAA,EACA,OAAA,EACA,OAAA,EAAkB;IAElB,OAAO,QAAQ,GAAA,CACd,UAAU,GAAA,CAAI,OAAO,OAAO,OAAO,WAAU;QAC5C,MAAM,kBAAkB,gBAAgB;QACxC,MAAM,YAAY,kBAAkB,MAAM,UAAA,GAAa,MAAM,IAAA;QAEvD,MAAA,SAAS,OAAA,CAAQ,SAAiC,CAAA;QAExD,IAAI,CAAC,QAAQ;YACL,OAAA;QACR;QAEA,MAAM,aAAa;YAAE;YAAO;YAAQ;YAAO;QAAO;QAIlD,IAAI,SAAS,MAAM,OAAA,uDAAA;QAElB;QAMD,IAAA,wCAAA;QAAA,qCAAA;QAAA,sBAAA;QAIC,OAAO,MAAA,GAAS,KAAA,CACf,OAAO,WAAW,cACjB,OAAO,WAAW,YAAY,aAAa,MAAA,GAC5C;YACQ,SAAA,aAAa,SAAS,OAAO,OAAA,GAAU;YACvC,SAAA,MAAM,OAAO,UAAU;QACjC;QAEA,IAAI,iBAAiB;YACb,OAAA;gBACN,UAAU;gBACV,IAAI,MAAM,EAAA;gBACV,YAAY;gBACZ,GAAG,MAAA;YAAA;QAAA,OAEE;YACC,OAAA;gBACN,UAAU;gBACV,MAAM;gBACN,GAAG,MAAA;YAAA;QAEL;IACA,CAAA,CAAC;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"file":"richText.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/value/richText.ts"],"sourcesContent":["import type { FieldState } from \"./types\"\n\nimport type { FilledContentRelationshipField } from \"./contentRelationship\"\nimport type { EmbedField } from \"./embed\"\nimport type { FilledLinkToWebField } from \"./link\"\nimport type { FilledLinkToMediaField } from \"./linkToMedia\"\n\n/**\n * Types enum for RichTextNodes\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title}\n */\nexport const RichTextNodeType = {\n\theading1: \"heading1\",\n\theading2: \"heading2\",\n\theading3: \"heading3\",\n\theading4: \"heading4\",\n\theading5: \"heading5\",\n\theading6: \"heading6\",\n\tparagraph: \"paragraph\",\n\tpreformatted: \"preformatted\",\n\tstrong: \"strong\",\n\tem: \"em\",\n\tlistItem: \"list-item\",\n\toListItem: \"o-list-item\",\n\tlist: \"group-list-item\",\n\toList: \"group-o-list-item\",\n\timage: \"image\",\n\tembed: \"embed\",\n\thyperlink: \"hyperlink\",\n\tlabel: \"label\",\n\tspan: \"span\",\n} as const\n\n/**\n * Types for RichTextNodes\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title}\n */\nexport type RichTextNodeTypes =\n\t(typeof RichTextNodeType)[keyof typeof RichTextNodeType]\n\n// Text nodes\n\n/**\n * Base to be extended by other rich text nodes.\n */\nexport interface RTTextNodeBase {\n\ttext: string\n\tspans: RTInlineNode[]\n\tdirection?: \"ltr\" | \"rtl\"\n}\n\n/**\n * Rich text `heading1` node\n */\nexport interface RTHeading1Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading1\n}\n\n/**\n * Rich text `heading2` node\n */\nexport interface RTHeading2Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading2\n}\n\n/**\n * Rich text `heading3` node\n */\nexport interface RTHeading3Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading3\n}\n\n/**\n * Rich text `heading4` node\n */\nexport interface RTHeading4Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading4\n}\n\n/**\n * Rich text `heading5` node\n */\nexport interface RTHeading5Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading5\n}\n\n/**\n * Rich text `heading6` node\n */\nexport interface RTHeading6Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading6\n}\n\n/**\n * Rich text `paragraph` node\n */\nexport interface RTParagraphNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.paragraph\n}\n\n/**\n * Rich text `preformatted` node\n */\nexport interface RTPreformattedNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.preformatted\n}\n\n/**\n * Rich text `list-item` node\n */\nexport interface RTListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.listItem\n}\n\n/**\n * Rich text `o-list-item` node for ordered lists\n */\nexport interface RTOListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.oListItem\n}\n\n// Span nodes\n\n/**\n * @internal Span Node base to be extended for other Span nodes\n */\nexport interface RTSpanNodeBase {\n\tstart: number\n\tend: number\n}\n/**\n * Rich text `strong` node\n */\nexport interface RTStrongNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.strong\n}\n\n/**\n * Rich text `embed` node\n */\nexport interface RTEmNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.em\n}\n\n/**\n * Rich text `label` node\n */\nexport interface RTLabelNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.label\n\tdata: {\n\t\tlabel: string\n\t}\n}\n\n// Media nodes\n\n/**\n * Rich text `image` nodes. They could link to other documents, external web\n * links and media fields\n */\nexport type RTImageNode = {\n\ttype: typeof RichTextNodeType.image\n\tid: string\n\turl: string\n\talt: string | null\n\tcopyright: string | null\n\tdimensions: {\n\t\twidth: number\n\t\theight: number\n\t}\n\tedit: {\n\t\tx: number\n\t\ty: number\n\t\tzoom: number\n\t\tbackground: string\n\t}\n\tlinkTo?:\n\t\t| FilledContentRelationshipField\n\t\t| FilledLinkToWebField\n\t\t| FilledLinkToMediaField\n}\n\n/**\n * Rich text `embed` node\n */\nexport type RTEmbedNode = {\n\ttype: typeof RichTextNodeType.embed\n\toembed: EmbedField\n}\n\n// Link nodes\n\n/**\n * Rich text `a` node\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title#elements-and-styles}\n */\nexport interface RTLinkNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.hyperlink\n\tdata:\n\t\t| FilledContentRelationshipField\n\t\t| FilledLinkToWebField\n\t\t| FilledLinkToMediaField\n}\n\n// Serialization related nodes\n\n/**\n * Rich text `list` node\n */\nexport interface RTListNode {\n\ttype: typeof RichTextNodeType.list\n\titems: RTListItemNode[]\n}\n\n/**\n * Rich text o-lost node\n */\nexport interface RTOListNode {\n\ttype: typeof RichTextNodeType.oList\n\titems: RTOListItemNode[]\n}\n\n// This one is confusing but it's actually the inner content of a block\n/**\n * Rich text `span` node\n */\nexport interface RTSpanNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.span\n}\n\n// Helpers\n\n/**\n * Nodes from a rich text field\n */\nexport type RTNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTImageNode\n\t| RTEmbedNode\n\n/**\n * Rich text nodes with text\n */\nexport type RTTextNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\n/**\n * Rich text block nodes\n */\nexport type RTBlockNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTListNode\n\t| RTOListNode\n\t| RTImageNode\n\t| RTEmbedNode\n\n/**\n * Inline rich text nodes\n */\nexport type RTInlineNode = RTStrongNode | RTEmNode | RTLabelNode | RTLinkNode\n\n/**\n * All rich text nodes\n */\nexport type RTAnyNode = RTBlockNode | RTInlineNode | RTSpanNode\n\n/**\n * A rich text field.\n *\n * @see Rich text field documentation: {@link https://prismic.io/docs/rich-text-title}\n */\nexport type RichTextField<State extends FieldState = FieldState> =\n\tState extends \"empty\" ? [] : [RTNode, ...RTNode[]]\n"],"names":[],"mappings":";;;AAYO,MAAM,mBAAmB;IAC/B,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,WAAW;IACX,cAAc;IACd,QAAQ;IACR,IAAI;IACJ,UAAU;IACV,WAAW;IACX,MAAM;IACN,OAAO;IACP,OAAO;IACP,OAAO;IACP,WAAW;IACX,OAAO;IACP,MAAM","ignoreList":[0]}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/index.ts"],"sourcesContent":["// Imports are used for deprecations.\nimport type { CustomTypeModelIntegrationField } from \"./types/model/integration\"\nimport type { IntegrationField } from \"./types/value/integration\"\nimport { RichTextNodeType } from \"./types/value/richText\"\n\nimport type {\n\tHTMLRichTextFunctionSerializer,\n\tHTMLRichTextMapSerializer,\n} from \"./helpers/asHTML\"\nimport { mapSliceZone } from \"./helpers/mapSliceZone\"\n\nimport { filter } from \"./filter\"\n\n//=============================================================================\n// Client - Query content from Prismic.\n//=============================================================================\n\n// Primary Client API.\nexport { createClient } from \"./createClient\"\nexport { Client } from \"./Client\"\n\n// Write Client API.\nexport { createWriteClient } from \"./createWriteClient\"\nexport { WriteClient } from \"./WriteClient\"\n\n// Migration helper.\nexport { createMigration } from \"./createMigration\"\nexport { Migration } from \"./Migration\"\n\n// API endpoint helpers.\nexport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\"\nexport { getRepositoryName } from \"./getRepositoryName\"\nexport { getGraphQLEndpoint } from \"./getGraphQLEndpoint\"\nexport { isRepositoryName } from \"./isRepositoryName\"\nexport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\"\nexport { buildQueryURL } from \"./buildQueryURL\"\n\n// Toolbar helpers.\nexport { getToolbarSrc } from \"./getToolbarSrc\"\n\n// Query filters API.\n/**\n * @deprecated Renamed to `filter`\n */\n// TODO: Remove when we remove support for deprecated `predicate` export.\nconst predicate = filter\nexport { filter, predicate }\n\n// A collection of well-known cookie names shared between Prismic libraries and systems.\nexport * as cookie from \"./cookie\"\n\n// General types used to query content from Prismic. These are made public to allow users to better type their projects.\nexport type { CreateClient } from \"./createClient\"\nexport type { ClientConfig } from \"./Client\"\nexport type { CreateWriteClient } from \"./createWriteClient\"\nexport type { WriteClientConfig, MigrateReporterEvents } from \"./WriteClient\"\nexport type {\n\tAbortSignalLike,\n\tFetchLike,\n\tHttpRequestLike,\n\tRequestInitLike,\n\tResponseLike,\n} from \"./BaseClient\"\nexport type {\n\tBuildQueryURLArgs,\n\tOrdering,\n\tQueryParams,\n\tRoute,\n} from \"./buildQueryURL\"\nexport type { CreateMigration } from \"./createMigration\"\n\n//=============================================================================\n// Helpers - Manipulate content from Prismic.\n//=============================================================================\n\n// Primary Helpers API.\nexport { asDate } from \"./helpers/asDate\"\nexport { asLink } from \"./helpers/asLink\"\nexport { asLinkAttrs } from \"./helpers/asLinkAttrs\"\nexport { asText } from \"./helpers/asText\"\nexport { asHTML } from \"./helpers/asHTML\"\nexport { asImageSrc } from \"./helpers/asImageSrc\"\nexport { asImageWidthSrcSet } from \"./helpers/asImageWidthSrcSet\"\nexport { asImagePixelDensitySrcSet } from \"./helpers/asImagePixelDensitySrcSet\"\nexport * as isFilled from \"./helpers/isFilled\"\n\n/**\n * @deprecated Renamed to `mapSliceZone`\n */\nconst unstable_mapSliceZone = mapSliceZone\nexport { mapSliceZone, unstable_mapSliceZone }\n\n// Conversion helper.\nexport { documentToLinkField } from \"./helpers/documentToLinkField\"\n\nexport type { LinkResolverFunction } from \"./helpers/asLink\"\nexport type { AsLinkAttrsConfig } from \"./helpers/asLinkAttrs\"\nexport type { SliceMapper } from \"./helpers/mapSliceZone\"\n\n/**\n * @deprecated Renamed to `HTMLRichTextMapSerializer`\n */\ntype HTMLMapSerializer = HTMLRichTextMapSerializer\n/**\n * @deprecated Renamed to `HTMLRichTextFunctionSerializer`\n */\ntype HTMLFunctionSerializer = HTMLRichTextFunctionSerializer\nexport type {\n\tHTMLRichTextMapSerializer,\n\tHTMLRichTextFunctionSerializer,\n\tHTMLMapSerializer,\n\tHTMLFunctionSerializer,\n}\nexport type { HTMLRichTextSerializer } from \"./helpers/asHTML\"\n\n//=============================================================================\n// Errors - Custom errors for Prismic APIs.\n//=============================================================================\n\n// Client Errors\nexport { PrismicError } from \"./errors/PrismicError\"\nexport { ForbiddenError } from \"./errors/ForbiddenError\"\nexport { NotFoundError } from \"./errors/NotFoundError\"\nexport { RefNotFoundError } from \"./errors/RefNotFoundError\"\nexport { RefExpiredError } from \"./errors/RefExpiredError\"\nexport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired\"\nexport { ParsingError } from \"./errors/ParsingError\"\nexport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError\"\n\n//=============================================================================\n// Types - Types representing Prismic content, models, and API payloads.\n//=============================================================================\n\n// Values - Types representing Prismic content.\n/**\n * @deprecated Use {@link RichTextNodeType} instead.\n */\n// TODO: Remove in v8.\nconst Element = RichTextNodeType\nexport { RichTextNodeType, Element }\nexport { LinkType } from \"./types/value/link\"\nexport { OEmbedType } from \"./types/value/embed\"\n\nexport type {\n\tPrismicDocument,\n\tPrismicDocumentWithUID,\n\tPrismicDocumentWithoutUID,\n\tPrismicDocumentHeader,\n\tAlternateLanguage,\n} from \"./types/value/document\"\n\nexport type {\n\t// RichText & Title\n\tRichTextField,\n\t// RichText & Title (block nodes)\n\tRTTextNodeBase,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTListItemNode,\n\tRTOListItemNode,\n\t// RichText & Title (span nodes)\n\tRTSpanNodeBase,\n\tRTStrongNode,\n\tRTEmNode,\n\tRTLabelNode,\n\t// RichText & Title (media nodes)\n\tRTImageNode,\n\tRTEmbedNode,\n\t// RichText & Title (link nodes)\n\tRTLinkNode,\n\t// RichText & Title (serialization related nodes)\n\tRTListNode,\n\tRTOListNode,\n\tRTSpanNode,\n\t// RichText & Title (helpers)\n\tRTNode,\n\tRTTextNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTAnyNode,\n\tRichTextNodeTypes,\n} from \"./types/value/richText\"\nexport type { TitleField } from \"./types/value/title\"\n\nexport type {\n\tImageField,\n\tImageFieldImage,\n\tFilledImageFieldImage,\n\tEmptyImageFieldImage,\n} from \"./types/value/image\"\n\nexport type {\n\tEmptyLinkField,\n\tLinkField,\n\tFilledLinkToWebField,\n} from \"./types/value/link\"\nexport type {\n\tContentRelationshipField,\n\tFilledContentRelationshipField,\n} from \"./types/value/contentRelationship\"\nexport type {\n\tLinkToMediaField,\n\tFilledLinkToMediaField,\n} from \"./types/value/linkToMedia\"\n\nexport type {\n\tOEmbedExtra,\n\tPhotoOEmbed,\n\tVideoOEmbed,\n\tLinkOEmbed,\n\tRichOEmbed,\n\tAnyOEmbed,\n\tEmbedField,\n} from \"./types/value/embed\"\n\nexport type { BooleanField } from \"./types/value/boolean\"\nexport type { ColorField } from \"./types/value/color\"\nexport type { DateField } from \"./types/value/date\"\nexport type { KeyTextField } from \"./types/value/keyText\"\nexport type { NumberField } from \"./types/value/number\"\nexport type { SelectField } from \"./types/value/select\"\nexport type { TimestampField } from \"./types/value/timestamp\"\nexport type { GeoPointField } from \"./types/value/geoPoint\"\n\n/**\n * @deprecated Renamed to `IntegrationField`\n */\n// TODO: Remove when we remove support for deprecated `IntegrationFields` export.\ntype IntegrationFields = IntegrationField\nexport { IntegrationField, IntegrationFields }\n\nexport type { GroupField, NestedGroupField } from \"./types/value/group\"\n\nexport type { SliceZone } from \"./types/value/sliceZone\"\nexport type { Slice } from \"./types/value/slice\"\nexport type { SharedSlice } from \"./types/value/sharedSlice\"\nexport type { SharedSliceVariation } from \"./types/value/sharedSliceVariation\"\n\nexport type {\n\tFieldState,\n\tAnyRegularField,\n\tAnySlicePrimaryField,\n\tRepeatable,\n} from \"./types/value/types\"\n\n// Models - Types representing Prismic content models.\nexport { CustomTypeModelFieldType } from \"./types/model/types\"\nexport { CustomTypeModelLinkSelectType } from \"./types/model/link\"\nexport { CustomTypeModelSliceType } from \"./types/model/sliceZone\"\nexport { CustomTypeModelSliceDisplay } from \"./types/model/slice\"\n\nexport type {\n\tCustomTypeModel,\n\tCustomTypeModelDefinition,\n\tCustomTypeModelTab,\n} from \"./types/model/customType\"\n\nexport type {\n\tCustomTypeModelRichTextField,\n\tCustomTypeModelRichTextMultiField,\n\tCustomTypeModelRichTextSingleField,\n} from \"./types/model/richText\"\nexport type { CustomTypeModelTitleField } from \"./types/model/title\"\n\nexport type {\n\tCustomTypeModelImageField,\n\tCustomTypeModelImageConstraint,\n\tCustomTypeModelImageThumbnail,\n} from \"./types/model/image\"\n\nexport type { CustomTypeModelContentRelationshipField } from \"./types/model/contentRelationship\"\nexport type { CustomTypeModelLinkField } from \"./types/model/link\"\nexport type { CustomTypeModelLinkToMediaField } from \"./types/model/linkToMedia\"\n\nexport type { CustomTypeModelEmbedField } from \"./types/model/embed\"\n\nexport type { CustomTypeModelBooleanField } from \"./types/model/boolean\"\nexport type { CustomTypeModelColorField } from \"./types/model/color\"\nexport type { CustomTypeModelDateField } from \"./types/model/date\"\nexport type { CustomTypeModelKeyTextField } from \"./types/model/keyText\"\nexport type { CustomTypeModelNumberField } from \"./types/model/number\"\nexport type { CustomTypeModelSelectField } from \"./types/model/select\"\nexport type { CustomTypeModelTimestampField } from \"./types/model/timestamp\"\nexport type { CustomTypeModelGeoPointField } from \"./types/model/geoPoint\"\n\n/**\n * @deprecated Renamed to `CustomTypeModelIntegrationField`.\n */\n// TODO: Remove when we remove support for deprecated `CustomTypeModelIntegrationField` export.\ntype CustomTypeModelIntegrationFieldsField = CustomTypeModelIntegrationField\nexport {\n\tCustomTypeModelIntegrationField,\n\tCustomTypeModelIntegrationFieldsField,\n}\nexport type {\n\tCustomTypeModelGroupField,\n\tCustomTypeModelNestedGroupField,\n} from \"./types/model/group\"\nexport type {\n\tCustomTypeModelSliceZoneField,\n\tCustomTypeModelSliceLabel,\n\tCustomTypeModelSharedSlice,\n} from \"./types/model/sliceZone\"\nexport type {\n\tCustomTypeModelSlice,\n\tCustomTypeModelLegacySlice,\n} from \"./types/model/slice\"\nexport type { SharedSliceModel } from \"./types/model/sharedSlice\"\nexport type { SharedSliceModelVariation } from \"./types/model/sharedSliceVariation\"\n\nexport type { CustomTypeModelUIDField } from \"./types/model/uid\"\n\nexport type { CustomTypeModelRangeField } from \"./types/model/range\"\nexport type { CustomTypeModelSeparatorField } from \"./types/model/separator\"\n\nexport type {\n\tCustomTypeModelField,\n\tCustomTypeModelFieldForGroup,\n\tCustomTypeModelFieldForNestedGroup,\n\tCustomTypeModelFieldForSlicePrimary,\n} from \"./types/model/types\"\n\n// Migrations - Types representing Prismic Migration API content values.\nexport { PrismicMigrationDocument } from \"./types/migration/Document\"\nexport type {\n\tPendingPrismicDocument,\n\tExistingPrismicDocument,\n\tInjectMigrationSpecificTypes,\n} from \"./types/migration/Document\"\n\nexport { PrismicMigrationAsset } from \"./types/migration/Asset\"\nexport type {\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"./types/migration/Asset\"\nexport type { MigrationContentRelationship } from \"./types/migration/ContentRelationship\"\n\n// API - Types representing Prismic Rest API V2 responses.\nexport type { Query } from \"./types/api/query\"\n\nexport type { Ref } from \"./types/api/ref\"\n\nexport type { Release } from \"./types/api/release\"\n\nexport type {\n\tRepository,\n\tLanguage,\n\tForm,\n\tFormField,\n} from \"./types/api/repository\"\n\nexport type { Tags } from \"./types/api/tags\"\n\n// Webhook - Types representing Prismic webhooks.\nexport { WebhookType } from \"./types/webhook/types\"\n\nexport type { WebhookBody } from \"./types/webhook/types\"\n\nexport type { WebhookBodyAPIUpdate } from \"./types/webhook/apiUpdate\"\n\nexport type { WebhookBodyTestTrigger } from \"./types/webhook/testTrigger\"\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,MAAM,oKAAY,SAAA;AA4ClB,MAAM,iMAAwB,eAAA;AAiD9B,MAAM,sLAAU,mBAAA","ignoreList":[0]}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"file":"isRepositoryEndpoint.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/isRepositoryEndpoint.ts"],"sourcesContent":["/**\n * Determines if a string if a Prismic Rest API V2 endpoint. Note that any valid\n * URL is a valid endpoint to support network proxies.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic Rest API V2 endpoint, `false`\n *   otherwise.\n */\nexport const isRepositoryEndpoint = (input: string): boolean => {\n\ttry {\n\t\tnew URL(input)\n\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n}\n"],"names":[],"mappings":";;;AASa,MAAA,uBAAuB,CAAC,UAA0B;IAC1D,IAAA;QACH,IAAI,IAAI,KAAK;QAEN,OAAA;IAAA,EAAA,OACA;QACA,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"file":"PrismicError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/PrismicError.ts"],"sourcesContent":["export class PrismicError<Response> extends Error {\n\turl?: string\n\tresponse: Response\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message)\n\n\t\tthis.url = url\n\t\tthis.response = response\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAM,MAAO,qBAA+B,MAAK;IAIhD,YACC,UAAU,sCAAA,EACV,GAAA,EACA,QAAA,CAAkB;QAElB,KAAA,CAAM,OAAO;QARd,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QASC,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,QAAA,GAAW;IACjB;AACA","ignoreList":[0]}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"file":"package.json.js","sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 439, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"file":"devMsg.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/devMsg.ts"],"sourcesContent":["import { version } from \"../../package.json\"\n\n/**\n * Returns a `prismic.dev/msg` URL for a given message slug.\n *\n * @example\n *\n * ```ts\n * devMsg(\"missing-param\")\n * // => \"https://prismic.dev/msg/client/v1.2.3/missing-param.md\"\n * ```\n *\n * @param slug - Slug for the message. This corresponds to a Markdown file in\n *   the Git repository's `/messages` directory.\n *\n * @returns The `prismic.dev/msg` URL for the given slug.\n */\nexport const devMsg = (slug: string): string => {\n\treturn `https://prismic.dev/msg/client/v${version}/${slug}`\n}\n"],"names":[],"mappings":";;;;;AAiBa,MAAA,SAAS,CAAC,SAAwB;IACvC,OAAA,CAAA,gCAAA,mKAAmC,UAAO,CAAA,CAAA,EAAI,IAAI,EAAA;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"file":"isRepositoryName.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/isRepositoryName.ts"],"sourcesContent":["/**\n * Determines if an input is a valid Prismic repository name.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic repository name, `false`\n *   otherwise.\n */\nexport const isRepositoryName = (input: string): boolean => {\n\treturn /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input)\n}\n"],"names":[],"mappings":";;;AAQa,MAAA,mBAAmB,CAAC,UAA0B;IACnD,OAAA,2CAA2C,IAAA,CAAK,KAAK;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"file":"getRepositoryEndpoint.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/getRepositoryEndpoint.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Get a repository's Prismic Rest API V2 endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic Rest API V2 endpoint\n *\n * @throws {@link Error} Thrown if an invalid repository name is provided.\n */\nexport const getRepositoryEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/api/v2` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAea,MAAA,wBAAwB,CACpC,mBACsD;IAClD,0KAAA,mBAAA,EAAiB,cAAc,GAAG;QACrC,OAAO,CAAA,QAAA,EAAW,cAAc,CAAA,sBAAA,CAAA;IAAA,OAC1B;QACN,MAAM,4KAAI,eAAA,CACT,CAAA,8CAAA,EAAiD,cAAc,EAAA,EAC/D,KAAA,GACA,KAAA,CAAS;IAEX;AACD","ignoreList":[0]}},
    {"offset": {"line": 491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 497, "column": 0}, "map": {"version":3,"file":"getRepositoryName.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/getRepositoryName.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\n/**\n * Get a Prismic repository's name from its standard Prismic Document API or\n * GraphQL endpoint.\n *\n * @param repositoryEndpoint - Prismic Document API endpoint for the repository.\n *\n * @returns The Prismic repository's name.\n *\n * @throws {@link Error} Thrown if an invalid Prismic Document API endpoint is\n *   provided.\n */\nexport const getRepositoryName = (repositoryEndpoint: string): string => {\n\ttry {\n\t\tconst hostname = new URL(repositoryEndpoint).hostname\n\n\t\tif (\n\t\t\thostname.endsWith(\"prismic.io\") || // Production\n\t\t\thostname.endsWith(\"wroom.io\") || // Staging\n\t\t\thostname.endsWith(\"wroom.test\") // Dev\n\t\t) {\n\t\t\treturn hostname.split(\".\")[0]\n\t\t}\n\t} catch {}\n\n\tthrow new PrismicError(\n\t\t`An invalid Prismic Document API endpoint was provided: ${repositoryEndpoint}`,\n\t\tundefined,\n\t\tundefined,\n\t)\n}\n"],"names":[],"mappings":";;;;;AAaa,MAAA,oBAAoB,CAAC,uBAAsC;IACnE,IAAA;QACH,MAAM,WAAW,IAAI,IAAI,kBAAkB,EAAE,QAAA;QAG5C,IAAA,SAAS,QAAA,CAAS,YAAY,KAAA,aAAA;QAC9B,SAAS,QAAA,CAAS,UAAU,KAAA,UAAA;QAC5B,SAAS,QAAA,CAAS,YAAY,GAC7B;YACD,OAAO,SAAS,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA;QAC7B;IAAA,EAAA,OACO,CAAC;IAET,MAAM,4KAAI,eAAA,CACT,CAAA,uDAAA,EAA0D,kBAAkB,EAAA,EAC5E,KAAA,GACA,KAAA,CAAS;AAEX","ignoreList":[0]}},
    {"offset": {"line": 515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 521, "column": 0}, "map": {"version":3,"file":"NotFoundError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/NotFoundError.ts"],"sourcesContent":["import { PrismicError } from \"./PrismicError\"\n\nexport class NotFoundError<\n\tTResponse = undefined,\n> extends PrismicError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAEM,MAAO,8LAEH,eAAA,CAAuB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 536, "column": 0}, "map": {"version":3,"file":"castArray.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/castArray.ts"],"sourcesContent":["/**\n * Ensures that a value is an array. If it is already an array, it is returned\n * as is. If it is not an array, it is converted to an array with itself as its\n * only element.\n *\n * @typeParam A - Element of the array.\n *\n * @param a - Value to ensure is an array.\n *\n * @returns `a` as an array.\n */\nexport const castArray = <A>(a: A | A[]): A[] => {\n\treturn Array.isArray(a) ? a : [a]\n}\n"],"names":[],"mappings":";;;AAWa,MAAA,YAAY,CAAI,MAAmB;IAC/C,OAAO,MAAM,OAAA,CAAQ,CAAC,IAAI,IAAI;QAAC,CAAC;KAAA;AACjC","ignoreList":[0]}},
    {"offset": {"line": 546, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"file":"appendFilters.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/appendFilters.ts"],"sourcesContent":["import { castArray } from \"./castArray\"\n\ninterface WithFilters {\n\tfilters?: string | string[]\n}\n\n/**\n * Adds one or more filters to an object with a `filters` property. Appended\n * filters are added to the end of the existing list.\n *\n * @typeParam T - Object to which filters will be append.\n *\n * @param objWithFilters - Object to append filters on the `filters` property.\n * @param filters - One or more filters to append.\n *\n * @returns The object with the appended filters.\n */\nexport const appendFilters = <T extends WithFilters>(\n\tobjWithFilters: T = {} as T,\n\tfilters: string | string[],\n): T & { filters: string[] } => {\n\treturn {\n\t\t...objWithFilters,\n\t\tfilters: [...(objWithFilters.filters || []), ...castArray(filters)],\n\t}\n}\n"],"names":[],"mappings":";;;;;AAiBO,MAAM,gBAAgB,CAC5B,iBAAoB,CAAA,CAAA,EACpB,YAC8B;IACvB,OAAA;QACN,GAAG,cAAA;QACH,SAAS,CAAC;eAAI,eAAe,OAAA,IAAW,CAAA,CAAA,EAAK;qLAAG,YAAA,EAAU,OAAO,CAAC;SAAA;IAAA;AAEpE","ignoreList":[0]}},
    {"offset": {"line": 568, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"file":"typeFilter.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/typeFilter.ts"],"sourcesContent":["import { filter } from \"../filter\"\n\n/**\n * Creates a filter to filter content by document type.\n *\n * @param documentType - The document type to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const typeFilter = (documentType: string): string => {\n\treturn filter.at(\"document.type\", documentType)\n}\n"],"names":[],"mappings":";;;;;AASa,MAAA,aAAa,CAAC,iBAAgC;IACnD,+JAAA,SAAA,CAAO,EAAA,CAAG,iBAAiB,YAAY;AAC/C","ignoreList":[0]}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"file":"someTagsFilter.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/someTagsFilter.ts"],"sourcesContent":["import { filter } from \"../filter\"\n\nimport { castArray } from \"./castArray\"\n\n/**\n * Creates a filter to filter content by document tags. At least one matching\n * tag is required on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const someTagsFilter = (tags: string | string[]): string => {\n\treturn filter.any(\"document.tags\", castArray(tags))\n}\n"],"names":[],"mappings":";;;;;;;AAYa,MAAA,iBAAiB,CAAC,SAAmC;IACjE,+JAAO,SAAA,CAAO,GAAA,CAAI,uLAAiB,YAAA,EAAU,IAAI,CAAC;AACnD","ignoreList":[0]}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"file":"everyTagFilter.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/everyTagFilter.ts"],"sourcesContent":["import { filter } from \"../filter\"\n\nimport { castArray } from \"./castArray\"\n\n/**\n * Creates a filter to filter content by document tags. All tags are required on\n * the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A filter that can be used in a Prismic REST API V2 request.\n */\nexport const everyTagFilter = (tags: string | string[]): string => {\n\treturn filter.at(\"document.tags\", castArray(tags))\n}\n"],"names":[],"mappings":";;;;;;;AAYa,MAAA,iBAAiB,CAAC,SAAmC;IACjE,+JAAO,SAAA,CAAO,EAAA,CAAG,uLAAiB,YAAA,EAAU,IAAI,CAAC;AAClD","ignoreList":[0]}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"file":"findRef.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/findRef.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { PrismicError } from \"../errors/PrismicError\"\n\n/**\n * Returns the first ref from a list that passes a filter (a function that\n * returns true).\n *\n * @param refs - A list of refs to search.\n * @param filter - A function that determines if a ref from the list matches the\n *   criteria.\n *\n * @returns The first matching ref.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRef = (refs: Ref[], filter: (ref: Ref) => boolean): Ref => {\n\tconst ref = refs.find((ref) => filter(ref))\n\n\tif (!ref) {\n\t\tthrow new PrismicError(\"Ref could not be found.\", undefined, undefined)\n\t}\n\n\treturn ref\n}\n"],"names":["ref"],"mappings":";;;;;AAgBa,MAAA,UAAU,CAAC,MAAa,WAAsC;IAC1E,MAAM,MAAM,KAAK,IAAA,CAAK,CAACA,OAAQ,OAAOA,IAAG,CAAC;IAE1C,IAAI,CAAC,KAAK;QACT,MAAM,4KAAI,eAAA,CAAa,2BAA2B,KAAA,GAAW,KAAA,CAAS;IACvE;IAEO,OAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"file":"findRefByID.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/findRefByID.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { findRef } from \"./findRef\"\n\n/**\n * Returns the ref from a list of given refs with a matching ID.\n *\n * @param refs - A list of refs to search.\n * @param id - The ID of the ref to find.\n *\n * @returns The ref with a matching ID from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByID = (refs: Ref[], id: string): Ref => {\n\treturn findRef(refs, (ref) => ref.id === id)\n}\n"],"names":[],"mappings":";;;;;AAca,MAAA,cAAc,CAAC,MAAa,OAAmB;IAC3D,2KAAO,UAAA,EAAQ,MAAM,CAAC,MAAQ,IAAI,EAAA,KAAO,EAAE;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 656, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 662, "column": 0}, "map": {"version":3,"file":"findRefByLabel.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/findRefByLabel.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { findRef } from \"./findRef\"\n\n/**\n * Returns the ref from a list of given refs with a matching label.\n *\n * @param refs - A list of refs to search.\n * @param id - The label of the ref to find.\n *\n * @returns The ref with a matching label from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByLabel = (refs: Ref[], label: string): Ref => {\n\treturn findRef(refs, (ref) => ref.label === label)\n}\n"],"names":[],"mappings":";;;;;AAca,MAAA,iBAAiB,CAAC,MAAa,UAAsB;IACjE,2KAAO,UAAA,EAAQ,MAAM,CAAC,MAAQ,IAAI,KAAA,KAAU,KAAK;AAClD","ignoreList":[0]}},
    {"offset": {"line": 672, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 678, "column": 0}, "map": {"version":3,"file":"findMasterRef.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/findMasterRef.ts"],"sourcesContent":["import type { Ref } from \"../types/api/ref\"\n\nimport { findRef } from \"./findRef\"\n\n/**\n * Returns the master ref from a list of given refs.\n *\n * @param refs - A list of refs to search.\n *\n * @returns The master ref from the list.\n *\n * @throws If a matching ref cannot be found.\n */\nexport const findMasterRef = (refs: Ref[]): Ref => {\n\treturn findRef(refs, (ref) => ref.isMasterRef)\n}\n"],"names":[],"mappings":";;;;;AAaa,MAAA,gBAAgB,CAAC,SAAoB;IACjD,2KAAO,UAAA,EAAQ,MAAM,CAAC,MAAQ,IAAI,WAAW;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 688, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"file":"buildQueryURL.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/buildQueryURL.ts"],"sourcesContent":["import { castArray } from \"./lib/castArray\"\nimport { devMsg } from \"./lib/devMsg\"\n\nimport { version } from \"../package.json\"\n\n/**\n * The query parameter used to indicate if the client is in development mode to\n * the API.\n */\nconst PRISMIC_DEV_PARAM = \"x-d\"\n\n/**\n * The query parameter used to indicate the version of the client to the API.\n */\nconst PRISMIC_CLIENT_VERSION_PARAM = \"x-c\"\n\n/**\n * Create a union of the given object's values, and optionally specify which\n * keys to get the values from.\n *\n * Taken from the `type-fest` package.\n *\n * See:\n * https://github.com/sindresorhus/type-fest/blob/61c35052f09caa23de5eef96d95196375d8ed498/source/value-of.d.ts\n */\ntype ValueOf<\n\tObjectType,\n\tValueType extends keyof ObjectType = keyof ObjectType,\n> = ObjectType[ValueType]\n\n/**\n * An `orderings` parameter that orders the results by the specified field.\n *\n * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n */\nexport interface Ordering {\n\tfield: string\n\tdirection?: \"asc\" | \"desc\"\n}\n\n/**\n * A `routes` parameter that determines how a document's URL field is resolved.\n *\n * {@link https://prismic.io/docs/route-resolver}\n *\n * @example With a document's UID field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:uid\"\n * }\n * ```\n *\n * @example With a Content Relationship `parent` field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:parent?/:uid\",\n * \t\"resolvers\": {\n * \t\t\"parent\": \"parent\"\n * \t}\n * }\n * ```\n */\nexport interface Route {\n\t/**\n\t * The custom type of the document.\n\t */\n\ttype: string\n\n\t/**\n\t * A specific UID to which this route definition is scoped. The route is only\n\t * defined for the document whose UID matches the given UID.\n\t */\n\tuid?: string\n\n\t/**\n\t * A specific language to which this route definition is scoped. The route is\n\t * only defined for documents whose language matches the given language.\n\t */\n\tlang?: string\n\n\t/**\n\t * The resolved path of the document with optional placeholders.\n\t */\n\tpath: string\n\n\t/**\n\t * An object that lists the API IDs of the Content Relationships in the route.\n\t */\n\tresolvers?: Record<string, string>\n}\n\n/**\n * Parameters for the Prismic REST API V2.\n *\n * {@link https://prismic.io/docs/api}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://prismic.io/docs/access-token}\n\t */\n\taccessToken?: string\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of documents that the\n\t * API will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#pagesize}\n\t */\n\tpageSize?: number\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#page}\n\t */\n\tpage?: number\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the documents except for those after the specified document in\n\t * the list.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#after}\n\t */\n\tafter?: string\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetch}\n\t */\n\tfetch?: string | string[]\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked document and add it to the document response object.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetchlinks}\n\t */\n\tfetchLinks?: string | string[]\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content\n\t * Relationships.\n\t *\n\t * {@link https://prismic.io/docs/graphquery-rest-api}\n\t */\n\tgraphQuery?: string\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#lang}\n\t */\n\tlang?: string\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n\t *\n\t * @remarks\n\t * Strings and arrays of strings are deprecated as of\n\t * `@prismicio/client@7.0.0`. Please migrate to the more explicit array of\n\t * objects.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * buildQueryURL(endpoint, {\n\t * \torderings: [\n\t * \t\t{ field: \"my.product.price\", direction: \"desc\" },\n\t * \t\t{ field: \"my.product.title\" },\n\t * \t],\n\t * })\n\t * ```\n\t */\n\t// TODO: Update TSDoc with deprecated API removal in v8\n\torderings?: string | Ordering | (string | Ordering)[]\n\n\t/**\n\t * The `routes` option allows you to define how a document's `url` field is\n\t * resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[]\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: string\n}\n\n/**\n * Arguments for `buildQueryURL` to construct a Query URL.\n */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n\t */\n\tref: string\n\n\t/**\n\t * Ref used to populate integration fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/integration-fields}\n\t */\n\tintegrationFieldsRef?: string\n\n\t/**\n\t * One or more filters to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#q}\n\t */\n\tfilters?: string | string[]\n\n\t/**\n\t * @deprecated Renamed to `filters`. Ensure the value is an array of filters,\n\t *   not a single, non-array filter.\n\t */\n\tpredicates?: string | string[]\n}\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const\n\n/**\n * A valid parameter name for the Prismic REST API V2.\n */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string => {\n\t// TODO: Remove the following when `orderings` strings are no longer supported.\n\tif (typeof ordering === \"string\") {\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconst [field, direction] = ordering.split(\" \")\n\n\t\t\tconst objectForm =\n\t\t\t\tdirection === \"desc\"\n\t\t\t\t\t? `{ field: \"${field}\", direction: \"desc\" }`\n\t\t\t\t\t: `{ field: \"${field}\" }`\n\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${devMsg(\n\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t)}`,\n\t\t\t)\n\t\t}\n\n\t\treturn ordering\n\t}\n\n\treturn ordering.direction === \"desc\"\n\t\t? `${ordering.field} desc`\n\t\t: ordering.field\n}\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams\n\n/**\n * Build a Prismic REST API V2 URL to request documents from a repository. The\n * paginated response for this URL includes documents matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n * {@link https://prismic.io/docs/rest-api-technical-reference}\n *\n * @param endpoint - URL to the repository's REST API V2.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request documents from the repository.\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { filters, predicates, ...params } = args\n\n\tconst url = new URL(`documents/search`, `${endpoint}/`)\n\n\tif (filters) {\n\t\t// TODO: Remove warning when we remove support for string `filters` values.\n\t\tif (process.env.NODE_ENV === \"development\" && !Array.isArray(filters)) {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A non-array value was provided to the \\`filters\\` query parameter (\\`${filters}\\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${devMsg(\n\t\t\t\t\t\"filters-must-be-an-array\",\n\t\t\t\t)}`,\n\t\t\t)\n\t\t}\n\n\t\t// TODO: Remove `castArray` when we remove support for string `filters` values.\n\t\tfor (const filter of castArray(filters)) {\n\t\t\turl.searchParams.append(\"q\", `[${filter}]`)\n\t\t}\n\t}\n\n\t// TODO: Remove when we remove support for deprecated `predicates` argument.\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`)\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ||\n\t\t\tk) as ValidParamName\n\n\t\tlet value = params[k as keyof typeof params]\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name]\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\t// TODO: Remove the following warning when `orderings` strings are no longer supported.\n\t\t\t\tif (\n\t\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t\ttypeof scopedValue === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${devMsg(\n\t\t\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t\t\t)}`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\")\n\n\t\t\t\tvalue = `[${v}]`\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]))\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(\n\t\t\t\tname,\n\t\t\t\tcastArray<string | number | Route | Ordering>(value).join(\",\"),\n\t\t\t)\n\t\t}\n\t}\n\n\turl.searchParams.set(PRISMIC_CLIENT_VERSION_PARAM, `js-${version}`)\n\n\tif (process.env.NODE_ENV === \"development\") {\n\t\turl.searchParams.set(PRISMIC_DEV_PARAM, \"1\")\n\t}\n\n\treturn url.toString()\n}\n"],"names":[],"mappings":";;;;;;;;;AASA,MAAM,oBAAoB;AAK1B,MAAM,+BAA+B;AAyOrC,MAAM,iBAAiB;IACtB,aAAa;;AAqBd,MAAM,uBAAuB,CAAC,aAAuC;IAEhE,IAAA,OAAO,aAAa,UAAU;QAC7B,IAAA,QAAQ,IAAI,aAAa,WAAe;YAC3C,MAAM,CAAC,OAAO,SAAS,CAAA,GAAI,SAAS,KAAA,CAAM,GAAG;YAE7C,MAAM,aACL,cAAc,SACX,CAAA,UAAA,EAAa,KAAK,CAAA,sBAAA,CAAA,GAClB,CAAA,UAAA,EAAa,KAAK,CAAA,GAAA,CAAA;YAEtB,QAAQ,IAAA,CACP,CAAA,oJAAA,EAAuJ,UAAU,CAAA,wBAAA,MAA2B,wKAAA,EAC3L,uCAAuC,CACvC,EAAE;QAEL;QAEO,OAAA;IACR;IAEA,OAAO,SAAS,SAAA,KAAc,SAC3B,GAAG,SAAS,KAAK,CAAA,KAAA,CAAA,GACjB,SAAS,KAAA;AACb;AAqBa,MAAA,gBAAgB,CAC5B,UACA,SACW;IACX,MAAM,EAAE,OAAA,EAAS,UAAA,EAAY,GAAG,QAAA,GAAW;IAE3C,MAAM,MAAM,IAAI,IAAI,CAAA,gBAAA,CAAA,EAAoB,GAAG,QAAQ,CAAA,CAAA,CAAG;IAEtD,IAAI,SAAS;QAER,IAAA,QAAQ,IAAI,wCAAa,iBAAiB,CAAC,MAAM,OAAA,CAAQ,OAAO,GAAG;YACtE,QAAQ,IAAA,CACP,CAAA,yFAAA,EAA4F,OAAO,CAAA,2FAAA,MAA8F,wKAAA,EAChM,0BAA0B,CAC1B,EAAE;QAEL;QAGW,KAAA,MAAA,gLAAU,YAAA,EAAU,OAAO,EAAG;YACxC,IAAI,YAAA,CAAa,MAAA,CAAO,KAAK,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,CAAG;QAC3C;IACD;IAGA,IAAI,YAAY;QACJ,KAAA,MAAA,cAAa,iLAAA,EAAU,UAAU,EAAG;YAC9C,IAAI,YAAA,CAAa,MAAA,CAAO,KAAK,CAAA,CAAA,EAAI,SAAS,CAAA,CAAA,CAAG;QAC9C;IACD;IAIA,IAAA,MAAW,KAAK,OAAQ;QACjB,MAAA,OAAQ,cAAA,CAAe,CAAgC,CAAA,IAC5D;QAEG,IAAA,QAAQ,MAAA,CAAO,CAAwB,CAAA;QAE3C,IAAI,SAAS,aAAa;YACnB,MAAA,cAAc,MAAA,CAAO,IAAI,CAAA;YAE/B,IAAI,eAAe,MAAM;gBAExB,IACC,QAAQ,IAAI,wCAAa,iBACzB,OAAO,gBAAgB,UACtB;oBACD,QAAQ,IAAA,CACP,CAAA,8KAAA,GAAiL,2KAAA,EAChL,uCAAuC,CACvC,EAAE;gBAEL;gBAEA,MAAM,0KAAI,YAAA,EAAU,WAAW,EAC7B,GAAA,CAAI,CAAC,WAAa,qBAAqB,QAAQ,CAAC,EAChD,IAAA,CAAK,GAAG;gBAEV,QAAQ,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA,CAAA;YACd;QAAA,OAAA,IACU,SAAS,UAAU;YAC7B,IAAI,OAAO,MAAA,CAAO,IAAI,CAAA,KAAM,UAAU;gBACrC,QAAQ,KAAK,SAAA,uKAAU,YAAA,EAAU,MAAA,CAAO,IAAI,CAAC,CAAC;YAC/C;QACD;QAEA,IAAI,SAAS,MAAM;YACd,IAAA,YAAA,CAAa,GAAA,CAChB,4KACA,YAAA,EAA8C,KAAK,EAAE,IAAA,CAAK,GAAG,CAAC;QAEhE;IACD;IAEA,IAAI,YAAA,CAAa,GAAA,CAAI,8BAA8B,CAAA,GAAA,mKAAM,UAAO,EAAE;IAE9D,IAAA,QAAQ,IAAI,aAAa,WAAe;QACvC,IAAA,YAAA,CAAa,GAAA,CAAI,mBAAmB,GAAG;IAC5C;IAEA,OAAO,IAAI,QAAA;AACZ","ignoreList":[0]}},
    {"offset": {"line": 764, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 770, "column": 0}, "map": {"version":3,"file":"link.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/value/link.ts"],"sourcesContent":["import type { AnyRegularField, FieldState } from \"./types\"\n\nimport type { ContentRelationshipField } from \"./contentRelationship\"\nimport type { GroupField } from \"./group\"\nimport type { LinkToMediaField } from \"./linkToMedia\"\nimport type { SliceZone } from \"./sliceZone\"\n\n/**\n * Link types\n */\nexport const LinkType = {\n\tAny: \"Any\",\n\tDocument: \"Document\",\n\tMedia: \"Media\",\n\tWeb: \"Web\",\n} as const\n\n/**\n * For link fields that haven't been filled\n *\n * @typeParam Type - The type of link.\n */\nexport type EmptyLinkField<\n\tType extends (typeof LinkType)[keyof typeof LinkType] = typeof LinkType.Any,\n> = {\n\tlink_type: Type | string\n\ttext?: string\n}\n\n/**\n * Link that points to external website\n */\nexport interface FilledLinkToWebField {\n\tlink_type: typeof LinkType.Web\n\turl: string\n\ttarget?: string\n\ttext?: string\n}\n\n/**\n * A link field.\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled in via\n *   GraphQuery of `fetchLinks`).\n * @typeParam State - State of the field which determines its shape.\n */\nexport type LinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyLinkField<typeof LinkType.Any>\n\t:\n\t\t\t| ContentRelationshipField<TypeEnum, LangEnum, DataInterface, State>\n\t\t\t| FilledLinkToWebField\n\t\t\t| LinkToMediaField<State>\n"],"names":[],"mappings":";;;AAUO,MAAM,WAAW;IACvB,KAAK;IACL,UAAU;IACV,OAAO;IACP,KAAK","ignoreList":[0]}},
    {"offset": {"line": 781, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 787, "column": 0}, "map": {"version":3,"file":"documentToLinkField.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/documentToLinkField.ts"],"sourcesContent":["import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport { LinkType } from \"../types/value/link\"\n\ntype SetOptional<T, Keys extends keyof T> = Omit<T, Keys> &\n\tPartial<Pick<T, Keys>>\n\n/**\n * Converts a document into a link field, this is useful when crawling the API\n * for document links\n *\n * @typeParam TDocument - Specific interface of the provided document\n *\n * @param prismicDocument - A document coming from Prismic\n *\n * @returns The equivalent link field to use with `asLink()`\n *\n * @internal\n */\nexport const documentToLinkField = <\n\tTDocument extends SetOptional<PrismicDocument, \"slugs\">,\n>(\n\tprismicDocument: TDocument,\n): FilledContentRelationshipField<\n\tTDocument[\"type\"],\n\tTDocument[\"lang\"],\n\tTDocument[\"data\"]\n> => {\n\treturn {\n\t\tlink_type: LinkType.Document,\n\t\tid: prismicDocument.id,\n\t\tuid: prismicDocument.uid || undefined,\n\t\ttype: prismicDocument.type,\n\t\ttags: prismicDocument.tags,\n\t\tlang: prismicDocument.lang,\n\t\turl: prismicDocument.url == null ? undefined : prismicDocument.url,\n\t\tslug: prismicDocument.slugs?.[0], // Slug field is not available with GraphQL\n\t\t// The REST API does not include a `data` property if the data\n\t\t// object is empty.\n\t\t//\n\t\t// A presence check for `prismicDocument.data` is done to\n\t\t// support partial documents. While `documentToLinkField` is\n\t\t// not typed to accept partial documents, passing a partial\n\t\t// document can happen in untyped projects.\n\t\t...(prismicDocument.data && Object.keys(prismicDocument.data).length > 0\n\t\t\t? { data: prismicDocument.data }\n\t\t\t: {}),\n\t}\n}\n"],"names":[],"mappings":";;;;;AAmBa,MAAA,sBAAsB,CAGlC,oBAKG;;IACI,OAAA;QACN,mLAAW,WAAA,CAAS,QAAA;QACpB,IAAI,gBAAgB,EAAA;QACpB,KAAK,gBAAgB,GAAA,IAAO,KAAA;QAC5B,MAAM,gBAAgB,IAAA;QACtB,MAAM,gBAAgB,IAAA;QACtB,MAAM,gBAAgB,IAAA;QACtB,KAAK,gBAAgB,GAAA,IAAO,OAAO,KAAA,IAAY,gBAAgB,GAAA;QAC/D,MAAA,CAAM,KAAA,gBAAgB,KAAA,KAAhB,OAAA,KAAA,IAAA,EAAA,CAAwB,EAAA;QAAA,2CAAA;QAAA,8DAAA;QAAA,mBAAA;QAAA,EAAA;QAAA,yDAAA;QAAA,4DAAA;QAAA,2DAAA;QAAA,2CAAA;QAQ9B,GAAI,gBAAgB,IAAA,IAAQ,OAAO,IAAA,CAAK,gBAAgB,IAAI,EAAE,MAAA,GAAS,IACpE;YAAE,MAAM,gBAAgB,IAAA;QAAA,IACxB,CAAA,CAAA;;AAEL","ignoreList":[0]}},
    {"offset": {"line": 818, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"file":"asLink.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asLink.ts"],"sourcesContent":["import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { FilledLinkToWebField, LinkField } from \"../types/value/link\"\nimport { LinkType } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\n\nimport { documentToLinkField } from \"./documentToLinkField\"\n\n/**\n * Resolves a link to a Prismic document to a URL\n *\n * @typeParam ReturnType - Return type of your link resolver function, useful if\n *   you prefer to return a complex object\n *\n * @param linkToDocumentField - A document link field to resolve\n *\n * @returns Resolved URL\n *\n * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n */\nexport type LinkResolverFunction<ReturnType = string | null | undefined> = (\n\tlinkToDocumentField: FilledContentRelationshipField,\n) => ReturnType\n\n/**\n * Configuration that determines the output of `asLink()`.\n */\ntype AsLinkConfig<LinkResolverFunctionReturnType = string | null | undefined> =\n\t{\n\t\t/**\n\t\t * An optional link resolver function. Without it, you are expected to use\n\t\t * the `routes` options from the API.\n\t\t */\n\t\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null\n\t}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsLinkDeprecatedTupleConfig<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n> = [linkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null]\n\n/**\n * The return type of `asLink()`.\n */\nexport type AsLinkReturnType<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? LinkResolverFunctionReturnType | string | null\n\t: null\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asLink: {\n\t/**\n\t * Resolves any type of link field or Prismic document to a URL.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - link resolver function return\n\t *   type\n\t * @typeParam Field - Link field or Prismic document to resolve to a URL\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a document to\n\t *   resolve\n\t * @param config - Configuration that determines the output of `asLink()`\n\t *\n\t * @returns Resolved URL or, if the provided link field or document is empty,\n\t *   `null`\n\t *\n\t * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n\t * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\tconfig?: AsLinkConfig<LinkResolverFunctionReturnType>,\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\n\t/**\n\t * Resolves any type of link field or Prismic document to a URL.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - link resolver function return\n\t *   type\n\t * @typeParam Field - Link field or Prismic document to resolve to a URL\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a document to\n\t *   resolve\n\t * @param linkResolver - An optional link resolver function. Without it, you\n\t *   are expected to use the `routes` options from the API\n\t *\n\t * @returns Resolved URL or, if the provided link field or document is empty,\n\t *   `null`\n\t *\n\t * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n\t * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\t...config: AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n} = <\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple:\n\t\t| [config?: AsLinkConfig<LinkResolverFunctionReturnType>]\n\t\t| AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n): AsLinkReturnType<LinkResolverFunctionReturnType, Field> => {\n\tif (!linkFieldOrDocument) {\n\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t}\n\n\t// Converts document to link field if needed\n\tconst linkField =\n\t\t// prettier-ignore\n\t\t(\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t\t// TODO: Remove the `prettier-ignore` comment when this bug is fixed.\n\t\t\t\"link_type\" in linkFieldOrDocument\n\t\t\t\t? linkFieldOrDocument\n\t\t\t\t: documentToLinkField(linkFieldOrDocument)\n\t\t) as LinkField\n\n\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\tconst [configObjectOrLinkResolver] = configObjectOrTuple\n\tlet config: AsLinkConfig<LinkResolverFunctionReturnType>\n\tif (\n\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\tconfigObjectOrLinkResolver == null\n\t) {\n\t\tconfig = {\n\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t}\n\t} else {\n\t\tconfig = { ...configObjectOrLinkResolver }\n\t}\n\n\tswitch (linkField.link_type) {\n\t\tcase LinkType.Media:\n\t\tcase LinkType.Web:\n\t\t\treturn (\"url\" in linkField ? linkField.url : null) as AsLinkReturnType<\n\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\tField\n\t\t\t>\n\n\t\tcase LinkType.Document: {\n\t\t\tif (\"id\" in linkField && config.linkResolver) {\n\t\t\t\t// When using link resolver...\n\t\t\t\tconst resolvedURL = config.linkResolver(linkField)\n\n\t\t\t\tif (resolvedURL != null) {\n\t\t\t\t\treturn resolvedURL as AsLinkReturnType<\n\t\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\t\tField\n\t\t\t\t\t>\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"url\" in linkField && linkField.url) {\n\t\t\t\t// When using route resolver...\n\t\t\t\treturn linkField.url as AsLinkReturnType<\n\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\tField\n\t\t\t\t>\n\t\t\t}\n\n\t\t\t// When empty or link resolver and route resolver are not used...\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t\t}\n\n\t\tcase LinkType.Any:\n\t\tdefault:\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AA+Da,MAAA,SA6DT,CAQH,qBAAA,GAEG,wBAGyD;IAC5D,IAAI,CAAC,qBAAqB;QAClB,OAAA;IACR;IAGM,MAAA,YAAA,kBAAA;IAAA,6DAAA;IAAA,2FAAA;IAAA,qEAAA;IAMJ,eAAe,sBACZ,0MACA,sBAAA,EAAoB,mBAAmB;IAItC,MAAA,CAAC,0BAA0B,CAAA,GAAI;IACjC,IAAA;IACJ,IACC,OAAO,+BAA+B,cACtC,8BAA8B,MAC7B;QACQ,SAAA;YACR,cAAc;QAAA;IAAA,OAET;QACG,SAAA;YAAE,GAAG,0BAAA;QAAA;IACf;IAEA,OAAQ,UAAU,SAAA,EAAW;QAC5B,6KAAK,WAAA,CAAS,KAAA;QACd,6KAAK,WAAA,CAAS,GAAA;YACL,OAAA,SAAS,YAAY,UAAU,GAAA,GAAM;QAK9C,6KAAK,WAAA,CAAS,QAAA;YAAU;gBACnB,IAAA,QAAQ,aAAa,OAAO,YAAA,EAAc;oBAEvC,MAAA,cAAc,OAAO,YAAA,CAAa,SAAS;oBAEjD,IAAI,eAAe,MAAM;wBACjB,OAAA;oBAIR;gBACD;gBAEI,IAAA,SAAS,aAAa,UAAU,GAAA,EAAK;oBAExC,OAAO,UAAU,GAAA;gBAIlB;gBAGO,OAAA;YACR;QAEA,6KAAK,WAAA,CAAS,GAAA;QACd;YACQ,OAAA;IACT;AACD","ignoreList":[0]}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 881, "column": 0}, "map": {"version":3,"file":"minifyGraphQLQuery.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/minifyGraphQLQuery.ts"],"sourcesContent":["/**\n * Minifies a GraphQL query by removing whitespace where possible.\n *\n * @param query - GraphQL query to minify.\n *\n * @returns A minified version of `query`.\n */\nexport const minifyGraphQLQuery = (query: string): string => {\n\treturn query.replace(\n\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t(_chars, _spaces, brackets) => brackets,\n\t)\n}\n"],"names":[],"mappings":";;;AAOa,MAAA,qBAAqB,CAAC,UAAyB;IAC3D,OAAO,MAAM,OAAA,CACZ,2BACA,CAAC,QAAQ,SAAS,WAAa,QAAQ;AAEzC","ignoreList":[0]}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"file":"cookie.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/cookie.ts"],"sourcesContent":["/**\n * The well-known name of the cookie used to store a Prismic preview session's\n * ref.\n */\nexport const preview = \"io.prismic.preview\"\n"],"names":[],"mappings":";;;AAIO,MAAM,UAAU","ignoreList":[0]}},
    {"offset": {"line": 901, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"file":"getPreviewCookie.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/getPreviewCookie.ts"],"sourcesContent":["import { preview as previewCookieName } from \"../cookie\"\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\")\n}\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param cookieJar - The stringified cookie store from which to read the\n *   cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getPreviewCookie = (cookieJar: string): string | undefined => {\n\tconst cookies = cookieJar.split(\"; \")\n\n\tlet value: string | undefined\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\")\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\")\n\n\t\tif (name === previewCookieName) {\n\t\t\tvalue = readValue(parts.slice(1).join(\"=\"))\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn value\n}\n"],"names":["previewCookieName"],"mappings":";;;;;AAEA,MAAM,YAAY,CAAC,UAAyB;IACpC,OAAA,MAAM,OAAA,CAAQ,QAAQ,GAAG;AACjC;AAUa,MAAA,mBAAmB,CAAC,cAAyC;IACnE,MAAA,UAAU,UAAU,KAAA,CAAM,IAAI;IAEhC,IAAA;IAEJ,KAAA,MAAW,UAAU,QAAS;QACvB,MAAA,QAAQ,OAAO,KAAA,CAAM,GAAG;QACxB,MAAA,OAAO,UAAU,KAAA,CAAM,CAAC,CAAC,EAAE,OAAA,CAAQ,QAAQ,GAAG;QAEpD,IAAI,iKAASA,UAAAA,EAAmB;YAC/B,QAAQ,UAAU,MAAM,KAAA,CAAM,CAAC,EAAE,IAAA,CAAK,GAAG,CAAC;YAC1C;QACD;IACD;IAEO,OAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 930, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 936, "column": 0}, "map": {"version":3,"file":"castThunk.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/castThunk.ts"],"sourcesContent":["/**\n * Ensures that a value is a thunk. If it is already a thunk, it is returned as\n * is. If it is not a thunk, it is converted to a thunk.\n *\n * @typeParam A - Value returned by the thunk.\n *\n * @param a - Value to ensure is a thunk.\n *\n * @returns `a` as a a thunk.\n */\nexport const castThunk = <A>(a: A | (() => A)): (() => A) => {\n\treturn typeof a === \"function\" ? (a as () => A) : () => a\n}\n"],"names":[],"mappings":";;;AAUa,MAAA,YAAY,CAAI,MAA+B;IAC3D,OAAO,OAAO,MAAM,aAAc,IAAgB,IAAM;AACzD","ignoreList":[0]}},
    {"offset": {"line": 944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"file":"ForbiddenError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/ForbiddenError.ts"],"sourcesContent":["import { PrismicError } from \"./PrismicError\"\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string\n\tmessage: string\n}\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string\n}\n\nexport class ForbiddenError<\n\tTResponse =\n\t\t| ForbiddenErrorRepositoryAPIResponse\n\t\t| ForbiddenErrorQueryAPIResponse,\n> extends PrismicError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,+LAIH,eAAA,CAAuB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"file":"RefNotFoundError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/RefNotFoundError.ts"],"sourcesContent":["import { ForbiddenError } from \"./ForbiddenError\"\n\ntype RefNotFoundErrorAPIResponse = {\n\ttype: \"api_notfound_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 404 for not found refs, it returnd 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefNotFoundError<\n\tTResponse = RefNotFoundErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,mMAEH,iBAAA,CAAyB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 974, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 980, "column": 0}, "map": {"version":3,"file":"RefExpiredError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/RefExpiredError.ts"],"sourcesContent":["import { ForbiddenError } from \"./ForbiddenError\"\n\ntype RefExpiredErrorAPIResponse = {\n\ttype: \"api_validation_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 410 for expired refs, it returnd 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefExpiredError<\n\tTResponse = RefExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,kMAEH,iBAAA,CAAyB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 995, "column": 0}, "map": {"version":3,"file":"ParsingError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/ParsingError.ts"],"sourcesContent":["import { PrismicError } from \"./PrismicError\"\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\"\n\tmessage: string\n\tline: number\n\tcolumn: number\n\tid: number\n\tlocation: string\n}\n\nexport class ParsingError<\n\tTResponse = ParsingErrorAPIResponse,\n> extends PrismicError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAWM,MAAO,6LAEH,eAAA,CAAuB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 1004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1010, "column": 0}, "map": {"version":3,"file":"RepositoryNotFoundError.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/RepositoryNotFoundError.ts"],"sourcesContent":["import { NotFoundError } from \"./NotFoundError\"\n\nexport class RepositoryNotFoundError<\n\tTResponse = undefined,\n> extends NotFoundError<TResponse> {}\n"],"names":[],"mappings":";;;;;AAEM,MAAO,yMAEH,gBAAA,CAAwB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"file":"PreviewTokenExpired.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/errors/PreviewTokenExpired.ts"],"sourcesContent":["import { ForbiddenError } from \"./ForbiddenError\"\n\ntype PreviewTokenExpiredErrorAPIResponse = {\n\ttype: \"api_security_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class PreviewTokenExpiredError<\n\tTResponse = PreviewTokenExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n"],"names":[],"mappings":";;;;;AASM,MAAO,2MAEH,iBAAA,CAAyB;AAAG","ignoreList":[0]}},
    {"offset": {"line": 1034, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1040, "column": 0}, "map": {"version":3,"file":"pLimit.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/pLimit.ts"],"sourcesContent":["/*\n ** Core logic from https://github.com/sindresorhus/p-limit\n ** Many thanks to @sindresorhus\n */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyFunction = (...arguments_: readonly any[]) => unknown\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n/**\n * @param fn - Promise-returning/async function.\n * @param arguments - Any arguments to pass through to `fn`. Support for passing\n *   arguments on to the `fn` is provided in order to be able to avoid creating\n *   unnecessary closures. You probably don't need this optimization unless\n *   you're pushing a lot of functions.\n *\n * @returns The promise returned by calling `fn(...arguments)`.\n */\nexport type LimitFunction = <TArguments extends unknown[], TReturnType>(\n\tfunction_: (\n\t\t...arguments_: TArguments\n\t) => PromiseLike<TReturnType> | TReturnType,\n\t...arguments_: TArguments\n) => Promise<TReturnType>\n\n/**\n * Creates a limiting function that will only execute one promise at a time and\n * respect a given interval between each call.\n *\n * @param args - Options for the function, `interval` is the minimum time to\n *   wait between each promise execution.\n *\n * @returns A limiting function as per configuration, see {@link LimitFunction}.\n */\nexport const pLimit = ({\n\tinterval,\n}: { interval?: number } = {}): LimitFunction => {\n\tconst queue: AnyFunction[] = []\n\tlet busy = false\n\tlet lastCompletion = 0\n\n\tconst resumeNext = () => {\n\t\tif (!busy && queue.length > 0) {\n\t\t\tqueue.shift()?.()\n\t\t\tbusy = true\n\t\t}\n\t}\n\n\tconst next = () => {\n\t\tbusy = false\n\n\t\tresumeNext()\n\t}\n\n\tconst run = async (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\tconst timeSinceLastCompletion = Date.now() - lastCompletion\n\n\t\tif (interval && timeSinceLastCompletion < interval) {\n\t\t\tawait sleep(interval - timeSinceLastCompletion)\n\t\t}\n\t\tconst result = (async () => function_(...arguments_))()\n\n\t\tresolve(result)\n\n\t\ttry {\n\t\t\tawait result\n\t\t} catch {}\n\n\t\tlastCompletion = Date.now()\n\n\t\tnext()\n\t}\n\n\tconst enqueue = (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise((internalResolve) => {\n\t\t\tqueue.push(internalResolve)\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_))\n\t\t;(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve()\n\n\t\t\tif (!busy) {\n\t\t\t\tresumeNext()\n\t\t\t}\n\t\t})()\n\t}\n\n\treturn ((function_: AnyFunction, ...arguments_: unknown[]) =>\n\t\tnew Promise<unknown>((resolve) => {\n\t\t\tenqueue(function_, resolve, arguments_)\n\t\t})) as LimitFunction\n}\n"],"names":[],"mappings":";;;AAQA,MAAM,QAAQ,CAAC,KAAe,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,EAAE,CAAC;AA2BvE,MAAM,SAAS,CAAC,EACtB,QAAA,CAAQ,CAAA,GACkB,CAAA,CAAA,KAAqB;IAC/C,MAAM,QAAuB,CAAA,CAAA;IAC7B,IAAI,OAAO;IACX,IAAI,iBAAiB;IAErB,MAAM,aAAa,MAAK;QAlCzB,IAAA;QAmCE,IAAI,CAAC,QAAQ,MAAM,MAAA,GAAS,GAAG;YAC9B,CAAA,KAAA,MAAM,KAAA,EAAA,KAAN,OAAA,KAAA,IAAA;YACO,OAAA;QACR;IAAA;IAGD,MAAM,OAAO,MAAK;QACV,OAAA;;;IAKR,MAAM,MAAM,OACX,WACA,SACA,eACG;QACG,MAAA,0BAA0B,KAAK,GAAA,CAAA,IAAQ;QAEzC,IAAA,YAAY,0BAA0B,UAAU;YAC7C,MAAA,MAAM,WAAW,uBAAuB;QAC/C;QACA,MAAM,SAAA,CAAU,UAAY,UAAU,GAAG,UAAU,CAAA;QAEnD,QAAQ,MAAM;QAEV,IAAA;YACG,MAAA;QAAA,EAAA,OACC,CAAC;QAET,iBAAiB,KAAK,GAAA;;;IAKvB,MAAM,UAAU,CACf,WACA,SACA,eACG;QAGC,IAAA,QAAQ,CAAC,oBAAmB;YAC/B,MAAM,IAAA,CAAK,eAAe;QAAA,CAC1B,EAAE,IAAA,CAAK,IAAI,IAAA,CAAK,KAAA,GAAW,WAAW,SAAS,UAAU,CAAC;QAC1D,CAAC,YAAW;YAKZ,MAAM,QAAQ,OAAA;YAEd,IAAI,CAAC,MAAM;;YAEX;QAAA,CAAA;;IAIF,OAAQ,CAAC,WAAA,GAA2B,aACnC,IAAI,QAAiB,CAAC,YAAW;YACxB,QAAA,WAAW,SAAS,UAAU;QAAA,CACtC;AACH","ignoreList":[0]}},
    {"offset": {"line": 1089, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1095, "column": 0}, "map": {"version":3,"file":"BaseClient.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/BaseClient.ts"],"sourcesContent":["import { type LimitFunction, pLimit } from \"./lib/pLimit\"\n\nimport { PrismicError } from \"./errors/PrismicError\"\n\n/**\n * The default delay used with APIs not providing rate limit headers.\n *\n * @internal\n */\nexport const UNKNOWN_RATE_LIMIT_DELAY = 1500\n\n/**\n * A universal API to make network requests. A subset of the `fetch()` API.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch}\n */\nexport type FetchLike = (\n\tinput: string,\n\tinit?: RequestInitLike,\n) => Promise<ResponseLike>\n\n/**\n * An object that allows you to abort a `fetch()` request if needed via an\n * `AbortController` object\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n */\n// `any` is used often here to ensure this type is universally valid among\n// different AbortSignal implementations. The types of each property are not\n// important to validate since it is blindly passed to a given `fetch()`\n// function.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AbortSignalLike = any\n\n/**\n * A subset of RequestInit properties to configure a `fetch()` request.\n */\n// Only options relevant to the client are included. Extending from the full\n// RequestInit would cause issues, such as accepting Header objects.\n//\n// An interface is used to allow other libraries to augment the type with\n// environment-specific types.\nexport interface RequestInitLike extends Pick<RequestInit, \"cache\"> {\n\t/**\n\t * The HTTP method to use for the request.\n\t */\n\tmethod?: string\n\n\t/**\n\t * The request body to send with the request.\n\t */\n\t// We want to keep the body type as compatible as possible, so\n\t// we only declare the type we need and accept anything else.\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tbody?: any | FormData | string\n\n\t/**\n\t * An object literal to set the `fetch()` request's headers.\n\t */\n\theaders?: Record<string, string>\n\n\t/**\n\t * An AbortSignal to set the `fetch()` request's signal.\n\t *\n\t * See:\n\t * [https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)\n\t */\n\t// NOTE: `AbortSignalLike` is `any`! It is left as `AbortSignalLike`\n\t// for backwards compatibility (the type is exported) and to signal to\n\t// other readers that this should be an AbortSignal-like object.\n\tsignal?: AbortSignalLike\n}\n\n/**\n * The minimum required properties from Response.\n */\nexport interface ResponseLike {\n\tok: boolean\n\tstatus: number\n\theaders: HeadersLike\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tjson(): Promise<any>\n\ttext(): Promise<string>\n\tblob(): Promise<Blob>\n}\n\n/**\n * The minimum required properties from Headers.\n */\nexport interface HeadersLike {\n\tget(name: string): string | null\n}\n\n/**\n * The minimum required properties to treat as an HTTP Request for automatic\n * Prismic preview support.\n */\nexport type HttpRequestLike =\n\t| /**\n\t * Web API Request\n\t *\n\t * @see http://developer.mozilla.org/en-US/docs/Web/API/Request\n\t */\n\t{\n\t\t\theaders?: {\n\t\t\t\tget(name: string): string | null\n\t\t\t}\n\t\t\turl?: string\n\t  }\n\n\t/**\n\t * Express-style Request\n\t */\n\t| {\n\t\t\theaders?: {\n\t\t\t\tcookie?: string\n\t\t\t}\n\t\t\tquery?: Record<string, unknown>\n\t  }\n\n/**\n * Configuration for clients that determine how APIs are queried.\n */\nexport type BaseClientConfig = {\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike\n\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike\n}\n\n/**\n * Parameters for any client method that use `fetch()`.\n */\nexport type FetchParams = {\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike\n\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * @deprecated Move the `signal` parameter into `fetchOptions.signal`:\n\t *\n\t * @see \\<https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\\>\n\t */\n\tsignal?: AbortSignalLike\n}\n\n/**\n * The result of a `fetch()` job.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype FetchJobResult<TJSON = any> = {\n\tstatus: number\n\theaders: HeadersLike\n\tjson: TJSON\n\ttext?: string\n}\n\nexport abstract class BaseClient {\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike\n\n\tfetchOptions?: RequestInitLike\n\n\t/**\n\t * Active queued `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n\t */\n\tprivate queuedFetchJobs: Record<string, LimitFunction> = {}\n\n\t/**\n\t * Active deduped `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n\t */\n\tprivate dedupedFetchJobs: Record<\n\t\tstring,\n\t\tMap<AbortSignalLike | undefined, Promise<FetchJobResult>>\n\t> = {}\n\n\tconstructor(options: BaseClientConfig) {\n\t\tthis.fetchOptions = options.fetchOptions\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch as FetchLike\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis)\n\t\t}\n\t}\n\n\tprotected async fetch(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<FetchJobResult> {\n\t\tconst requestInit: RequestInitLike = {\n\t\t\t...this.fetchOptions,\n\t\t\t...params.fetchOptions,\n\t\t\theaders: {\n\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t...params.fetchOptions?.headers,\n\t\t\t},\n\t\t\tsignal:\n\t\t\t\tparams.fetchOptions?.signal ||\n\t\t\t\tparams.signal ||\n\t\t\t\tthis.fetchOptions?.signal,\n\t\t}\n\n\t\t// Request with a `body` are throttled, others are deduped.\n\t\tif (params.fetchOptions?.body) {\n\t\t\treturn this.queueFetch(url, requestInit)\n\t\t} else {\n\t\t\treturn this.dedupeFetch(url, requestInit)\n\t\t}\n\t}\n\n\tprivate queueFetch(\n\t\turl: string,\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<FetchJobResult> {\n\t\t// Rate limiting is done per hostname.\n\t\tconst hostname = new URL(url).hostname\n\n\t\tif (!this.queuedFetchJobs[hostname]) {\n\t\t\tthis.queuedFetchJobs[hostname] = pLimit({\n\t\t\t\tinterval: UNKNOWN_RATE_LIMIT_DELAY,\n\t\t\t})\n\t\t}\n\n\t\treturn this.queuedFetchJobs[hostname](() =>\n\t\t\tthis.createFetchJob(url, requestInit),\n\t\t)\n\t}\n\n\tprivate dedupeFetch(\n\t\turl: string,\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<FetchJobResult> {\n\t\tlet job: Promise<FetchJobResult>\n\n\t\t// `fetchJobs` is keyed twice: first by the URL and again by is\n\t\t// signal, if one exists.\n\t\t//\n\t\t// Using two keys allows us to reuse fetch requests for\n\t\t// equivalent URLs, but eject when we detect unique signals.\n\t\tif (\n\t\t\tthis.dedupedFetchJobs[url] &&\n\t\t\tthis.dedupedFetchJobs[url].has(requestInit.signal)\n\t\t) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\tjob = this.dedupedFetchJobs[url].get(requestInit.signal)!\n\t\t} else {\n\t\t\tthis.dedupedFetchJobs[url] = this.dedupedFetchJobs[url] || new Map()\n\n\t\t\tjob = this.createFetchJob(url, requestInit).finally(() => {\n\t\t\t\tthis.dedupedFetchJobs[url]?.delete(requestInit.signal)\n\n\t\t\t\tif (this.dedupedFetchJobs[url]?.size === 0) {\n\t\t\t\t\tdelete this.dedupedFetchJobs[url]\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis.dedupedFetchJobs[url].set(requestInit.signal, job)\n\t\t}\n\n\t\treturn job\n\t}\n\n\tprivate createFetchJob(\n\t\turl: string,\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<FetchJobResult> {\n\t\treturn this.fetchFn(url, requestInit).then(async (res) => {\n\t\t\t// We can assume Prismic REST API responses\n\t\t\t// will have a `application/json`\n\t\t\t// Content Type. If not, this will\n\t\t\t// throw, signaling an invalid\n\t\t\t// response.\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tlet json: any = undefined\n\t\t\tlet text: string | undefined = undefined\n\t\t\tif (res.ok) {\n\t\t\t\ttry {\n\t\t\t\t\tjson = await res.json()\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\ttext = await res.text()\n\t\t\t\t\tjson = JSON.parse(text)\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tstatus: res.status,\n\t\t\t\theaders: res.headers,\n\t\t\t\tjson,\n\t\t\t\ttext,\n\t\t\t}\n\t\t})\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"file":"Client.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/Client.ts"],"sourcesContent":["import { appendFilters } from \"./lib/appendFilters\"\nimport { castThunk } from \"./lib/castThunk\"\nimport { devMsg } from \"./lib/devMsg\"\nimport { everyTagFilter } from \"./lib/everyTagFilter\"\nimport { findMasterRef } from \"./lib/findMasterRef\"\nimport { findRefByID } from \"./lib/findRefByID\"\nimport { findRefByLabel } from \"./lib/findRefByLabel\"\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\"\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\"\nimport { someTagsFilter } from \"./lib/someTagsFilter\"\nimport { typeFilter } from \"./lib/typeFilter\"\n\nimport type { Query } from \"./types/api/query\"\nimport type { Ref } from \"./types/api/ref\"\nimport type { Form, Repository } from \"./types/api/repository\"\nimport type { PrismicDocument } from \"./types/value/document\"\n\nimport { ForbiddenError } from \"./errors/ForbiddenError\"\nimport { NotFoundError } from \"./errors/NotFoundError\"\nimport { ParsingError } from \"./errors/ParsingError\"\nimport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired\"\nimport { PrismicError } from \"./errors/PrismicError\"\nimport { RefExpiredError } from \"./errors/RefExpiredError\"\nimport { RefNotFoundError } from \"./errors/RefNotFoundError\"\nimport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError\"\n\nimport type { LinkResolverFunction } from \"./helpers/asLink\"\nimport { asLink } from \"./helpers/asLink\"\n\nimport {\n\ttype AbortSignalLike,\n\tBaseClient,\n\ttype BaseClientConfig,\n\ttype FetchParams,\n\ttype HttpRequestLike,\n} from \"./BaseClient\"\nimport type { BuildQueryURLArgs } from \"./buildQueryURL\"\nimport { buildQueryURL } from \"./buildQueryURL\"\nimport { filter } from \"./filter\"\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\"\nimport { getRepositoryName } from \"./getRepositoryName\"\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\"\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500\n\n/**\n * The default number of milliseconds to wait before retrying a rate-limited\n * `fetch()` request (429 response code). The default value is only used if the\n * response does not include a `retry-after` header.\n *\n * The API allows up to 200 requests per second.\n */\nconst DEFUALT_RETRY_AFTER_MS = 1000\n\n/**\n * The maximum number of attemps to retry a query with an invalid ref. We allow\n * multiple attempts since each attempt may use a different (and possibly\n * invalid) ref. Capping the number of attemps prevents infinite loops.\n */\nconst MAX_INVALID_REF_RETRY_ATTEMPS = 3\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends PrismicDocument,\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID\n\t\t\treleaseID: string\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel\n\t\t\treleaseLabel: string\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual\n\t\t\tref: RefStringOrThunk\n\t  }\n)\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>)\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The full Rest API V2 endpoint for the repository. This is only helpful if\n\t * you're using Prismic behind a proxy which we do not recommend.\n\t *\n\t * @defaultValue `getRepositoryEndpoint(repositoryNameOrEndpoint)`\n\t */\n\tdocumentAPIEndpoint?: string\n\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>\n} & BaseClientConfig\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number\n}\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: LinkResolverFunction<LinkResolverReturnType>\n\n\t/**\n\t * A fallback URL if the link resolver does not return a value.\n\t */\n\tdefaultURL: string\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string\n}\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<\n\tTDocuments extends PrismicDocument = PrismicDocument,\n> extends BaseClient {\n\t#repositoryName: string | undefined\n\n\t/**\n\t * The Prismic repository's name.\n\t */\n\tset repositoryName(value: string) {\n\t\tthis.#repositoryName = value\n\t}\n\n\t/**\n\t * The Prismic repository's name.\n\t */\n\tget repositoryName(): string {\n\t\tif (!this.#repositoryName) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`A repository name is required for this method but one could not be inferred from the provided API endpoint (\\`${this.documentAPIEndpoint}\\`). To fix this error, provide a repository name when creating the client. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn this.#repositoryName\n\t}\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tdocumentAPIEndpoint: string\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t *\n\t * @deprecated Use `documentAPIEndpoint` instead.\n\t */\n\t// TODO: Remove in v8.\n\tset endpoint(value: string) {\n\t\tthis.documentAPIEndpoint = value\n\t}\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t *\n\t * @deprecated Use `documentAPIEndpoint` instead.\n\t */\n\t// TODO: Remove in v8.\n\tget endpoint(): string {\n\t\treturn this.documentAPIEndpoint\n\t}\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during\n\t * queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t}\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: Repository | undefined\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as in some Node.js versions, the `fetch` option must be provided as\n\t * part of the `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tsuper(options)\n\n\t\tif (\n\t\t\t(options.documentAPIEndpoint ||\n\t\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint)) &&\n\t\t\tprocess.env.NODE_ENV === \"development\"\n\t\t) {\n\t\t\tconst documentAPIEndpoint =\n\t\t\t\toptions.documentAPIEndpoint || repositoryNameOrEndpoint\n\n\t\t\t// Matches non-API v2 `.prismic.io` endpoints, see: https://regex101.com/r/xRsavu/1\n\t\t\tif (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(documentAPIEndpoint)) {\n\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst hostname = new URL(documentAPIEndpoint).hostname.toLowerCase()\n\n\t\t\t// Matches non-.cdn `.prismic.io` endpoints\n\t\t\tif (\n\t\t\t\thostname.endsWith(\".prismic.io\") &&\n\t\t\t\t!hostname.endsWith(\".cdn.prismic.io\")\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] The client was created with a non-CDN endpoint. Convert it to the CDN endpoint for better performance. For more details, see ${devMsg(\"endpoint-must-use-cdn\")}`,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Warn if the user provided both a repository endpoint and an `documentAPIEndpoint` and they are different\n\t\t\tif (\n\t\t\t\toptions.documentAPIEndpoint &&\n\t\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint) &&\n\t\t\t\trepositoryNameOrEndpoint !== options.documentAPIEndpoint\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] Multiple incompatible endpoints were provided. Create the client using a repository name to prevent this error. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tthis.documentAPIEndpoint = repositoryNameOrEndpoint\n\t\t\ttry {\n\t\t\t\tthis.repositoryName = getRepositoryName(repositoryNameOrEndpoint)\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] A repository name could not be inferred from the provided endpoint (\\`${repositoryNameOrEndpoint}\\`). Some methods will be disabled. Create the client using a repository name to prevent this warning. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.documentAPIEndpoint =\n\t\t\t\toptions.documentAPIEndpoint ||\n\t\t\t\tgetRepositoryEndpoint(repositoryNameOrEndpoint)\n\t\t\tthis.repositoryName = repositoryNameOrEndpoint\n\t\t}\n\n\t\tthis.accessToken = options.accessToken\n\t\tthis.routes = options.routes\n\t\tthis.brokenRoute = options.brokenRoute\n\t\tthis.defaultParams = options.defaultParams\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref)\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this)\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the\n\t * browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews()\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the\n\t * server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req)\n\t * })\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's\n\t *   cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req\n\t\tthis.refState.autoPreviewsEnabled = true\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews()\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\tconst { data } = await this._get<TDocument>(params)\n\n\t\treturn data\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams = { ...params }\n\t\tif (!(params && params.page) && !params?.pageSize) {\n\t\t\tactualParams.pageSize = this.defaultParams?.pageSize ?? 1\n\t\t}\n\t\tconst { data, url } = await this._get<TDocument>(actualParams)\n\n\t\tconst firstResult = data.results[0]\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult\n\t\t}\n\n\t\tthrow new NotFoundError(\"No documents were returned\", url, undefined)\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by filters such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no filters are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t}\n\n\t\tconst documents: TDocument[] = []\n\t\tlet latestResult: Query<TDocument> | undefined\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page })\n\t\t\tdocuments.push(...latestResult.results)\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY))\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit)\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t *\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.id\", id)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and\n\t * custom type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom\n\t * Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and\n\t * custom type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific\n\t * custom type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable custom type which\n\t * allows multiple instances of itself.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the singleton custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the custom type, if a matching document\n\t *   exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific custom type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the custom type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom\n\t * Type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the custom type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendFilters(params, typeFilter(documentType)))\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a\n\t * specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(appendFilters(params, someTagsFilter(tag)))\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the\n\t *   tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllBySomeTags([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.documentAPIEndpoint)\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t}\n\n\t\treturn await this.fetch<Repository>(url.toString(), params)\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<Ref[]> {\n\t\tconst repository = await this.getRepository(params)\n\n\t\treturn repository.refs\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findRefByID(refs, id)\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findRefByLabel(refs, label)\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findMasterRef(refs)\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<Ref[]> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef)\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\n\t\treturn findRefByID(releases, id)\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\n\t\treturn findRefByLabel(releases, label)\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params)\n\n\t\t\tconst url = new URL(tagsForm.action)\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params)\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params)\n\n\t\t\treturn repository.tags\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\tfetchOptions,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref =\n\t\t\tparams.ref || (await this.getResolvedRefString({ signal, fetchOptions }))\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal, fetchOptions }))\n\t\t\t\t.integrationFieldsRef ||\n\t\t\tundefined\n\n\t\treturn buildQueryURL(this.documentAPIEndpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t})\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID\n\t\tlet previewToken: string | undefined | null = args.previewToken\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search)\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string)\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string)\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\t// Including \"missing-host://\" by default\n\t\t\t\t// handles a case where Next.js Route Handlers\n\t\t\t\t// only provide the pathname and search\n\t\t\t\t// parameters in the `url` property\n\t\t\t\t// (e.g. `/api/preview?foo=bar`).\n\t\t\t\tconst searchParams = new URL(\n\t\t\t\t\tthis.refState.httpRequest.url,\n\t\t\t\t\t\"missing-host://\",\n\t\t\t\t).searchParams\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t\tsignal: args.signal,\n\t\t\t\tfetchOptions: args.fetchOptions,\n\t\t\t})\n\n\t\t\tconst url = asLink(document, { linkResolver: args.linkResolver })\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future\n\t * queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent()\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query\n\t *   content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t}\n\t}\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphQLClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphQLFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * })\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are\n\t *   supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t *\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository()\n\t\tconst ref = await this.getResolvedRefString()\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t}\n\n\t\tif (cachedRepository.integrationFieldsRef) {\n\t\t\tunsanitizedHeaders[\"Prismic-integration-field-ref\"] =\n\t\t\t\tcachedRepository.integrationFieldsRef\n\t\t}\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {}\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders]\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t)\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref)\n\n\t\tconst query = url.searchParams.get(\"query\")\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t)\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(params?: FetchParams): Promise<Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL\n\t\t\tthis.cachedRepository = await this.getRepository(params)\n\t\t}\n\n\t\treturn this.cachedRepository\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t *\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params)\n\t\tconst form = cachedRepository.forms[name]\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn form\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref\n\t * thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n\t *   fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined\n\n\t\t\tlet cookieJar: string | null | undefined\n\n\t\t\tif (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\")\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie\n\t\t\t\t}\n\t\t\t} else if (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getPreviewCookie(cookieJar)\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params)\n\n\t\tconst refModeType = this.refState.mode\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)()\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref\n\t}\n\n\t/**\n\t * The private implementation of `this.get`. It returns the API response and\n\t * the URL used to make the request. The URL is sometimes used in the public\n\t * method to include in thrown errors.\n\t *\n\t * This method retries requests that throw `RefNotFoundError` or\n\t * `RefExpiredError`. It contains special logic to retry with the latest\n\t * master ref, provided in the API's error message.\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns An object containing the paginated response containing the result\n\t *   of the query and the URL used to make the API request.\n\t */\n\tprivate async _get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t\tattemptCount = 0,\n\t): Promise<{ data: Query<TDocument>; url: string }> {\n\t\tconst url = await this.buildQueryURL(params)\n\n\t\ttry {\n\t\t\tconst data = await this.fetch<Query<TDocument>>(url, params)\n\n\t\t\treturn { data, url }\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\terror instanceof RefNotFoundError || error instanceof RefExpiredError\n\t\t\t\t) ||\n\t\t\t\tattemptCount >= MAX_INVALID_REF_RETRY_ATTEMPS - 1\n\t\t\t) {\n\t\t\t\tthrow error\n\t\t\t}\n\n\t\t\t// If no explicit ref is given (i.e. the master ref from\n\t\t\t// /api/v2 is used), clear the cached repository value.\n\t\t\t// Clearing the cached value prevents other methods from\n\t\t\t// using a known-stale ref.\n\t\t\tif (!params?.ref) {\n\t\t\t\tthis.cachedRepository = undefined\n\t\t\t}\n\n\t\t\tconst masterRef = error.message.match(/Master ref is: (?<ref>.*)$/)\n\t\t\t\t?.groups?.ref\n\t\t\tif (!masterRef) {\n\t\t\t\tthrow error\n\t\t\t}\n\n\t\t\tconst badRef = new URL(url).searchParams.get(\"ref\")\n\t\t\tconst issue = error instanceof RefNotFoundError ? \"invalid\" : \"expired\"\n\t\t\tconsole.warn(\n\t\t\t\t`The ref (${badRef}) was ${issue}. Now retrying with the latest master ref (${masterRef}). If you were previewing content, the response will not include draft content.`,\n\t\t\t)\n\n\t\t\treturn await this._get({ ...params, ref: masterRef }, attemptCount + 1)\n\t\t}\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t *\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprotected async fetch<T = unknown>(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\tconst res = await super.fetch(url, params)\n\n\t\tif (res.status !== 404 && res.status !== 429 && res.json == null) {\n\t\t\tthrow new PrismicError(undefined, url, res.json || res.text)\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200:\n\t\t\tcase 201: {\n\t\t\t\treturn res.json\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid filter syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tres.json.error || res.json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tres.json,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Not Found\n\t\t\t// - Incorrect repository name (this response has an empty body)\n\t\t\t// - Ref does not exist\n\t\t\t// - Preview token is expired\n\t\t\tcase 404: {\n\t\t\t\tif (res.json === undefined) {\n\t\t\t\t\tthrow new RepositoryNotFoundError(\n\t\t\t\t\t\t`Prismic repository not found. Check that \"${this.documentAPIEndpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\turl.startsWith(this.documentAPIEndpoint) ? undefined : res.text,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (res.json.type === \"api_notfound_error\") {\n\t\t\t\t\tthrow new RefNotFoundError(res.json.message, url, res.json)\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tres.json.type === \"api_security_error\" &&\n\t\t\t\t\t/preview token.*expired/i.test(res.json.message)\n\t\t\t\t) {\n\t\t\t\t\tthrow new PreviewTokenExpiredError(res.json.message, url, res.json)\n\t\t\t\t}\n\n\t\t\t\tthrow new NotFoundError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Gone\n\t\t\t// - Ref is expired\n\t\t\tcase 410: {\n\t\t\t\tthrow new RefExpiredError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Too Many Requests\n\t\t\t// - Exceeded the maximum number of requests per second\n\t\t\tcase 429: {\n\t\t\t\tconst parsedRetryAfter = Number(res.headers.get(\"retry-after\"))\n\t\t\t\tconst delay = Number.isNaN(parsedRetryAfter)\n\t\t\t\t\t? DEFUALT_RETRY_AFTER_MS\n\t\t\t\t\t: parsedRetryAfter\n\n\t\t\t\treturn await new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(await this.fetch(url, params))\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, res.json)\n\t}\n}\n"],"names":["RefStateMode"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2466, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2472, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/model/types.ts"],"sourcesContent":["import type { CustomTypeModelBooleanField } from \"./boolean\"\nimport type { CustomTypeModelColorField } from \"./color\"\nimport type { CustomTypeModelContentRelationshipField } from \"./contentRelationship\"\nimport type { CustomTypeModelDateField } from \"./date\"\nimport type { CustomTypeModelEmbedField } from \"./embed\"\nimport type { CustomTypeModelGeoPointField } from \"./geoPoint\"\nimport type {\n\tCustomTypeModelGroupField,\n\tCustomTypeModelNestedGroupField,\n} from \"./group\"\nimport type { CustomTypeModelImageField } from \"./image\"\nimport type { CustomTypeModelIntegrationField } from \"./integration\"\nimport type { CustomTypeModelKeyTextField } from \"./keyText\"\nimport type { CustomTypeModelLinkField } from \"./link\"\nimport type { CustomTypeModelLinkToMediaField } from \"./linkToMedia\"\nimport type { CustomTypeModelNumberField } from \"./number\"\nimport type { CustomTypeModelRangeField } from \"./range\"\nimport type { CustomTypeModelRichTextField } from \"./richText\"\nimport type { CustomTypeModelSelectField } from \"./select\"\nimport type { CustomTypeModelSeparatorField } from \"./separator\"\nimport type { CustomTypeModelSliceZoneField } from \"./sliceZone\"\nimport type { CustomTypeModelTimestampField } from \"./timestamp\"\nimport type { CustomTypeModelTitleField } from \"./title\"\nimport type { CustomTypeModelUIDField } from \"./uid\"\n\n/**\n * Type identifier for a custom type field.\n */\nexport const CustomTypeModelFieldType = {\n\tBoolean: \"Boolean\",\n\tColor: \"Color\",\n\tDate: \"Date\",\n\tEmbed: \"Embed\",\n\tGeoPoint: \"GeoPoint\",\n\tGroup: \"Group\",\n\tImage: \"Image\",\n\tIntegration: \"IntegrationFields\",\n\tLink: \"Link\",\n\tNumber: \"Number\",\n\tSelect: \"Select\",\n\tSlices: \"Slices\",\n\tStructuredText: \"StructuredText\",\n\tText: \"Text\",\n\tTimestamp: \"Timestamp\",\n\tUID: \"UID\",\n\t/**\n\t * @deprecated - Renamed to `Integration`.\n\t */\n\tIntegrationFields: \"IntegrationFields\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Number` instead.\n\t */\n\tRange: \"Range\",\n\t/**\n\t * @deprecated - Legacy field type. Do not use.\n\t */\n\tSeparator: \"Separator\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Slices` instead.\n\t */\n\tLegacySlices: \"Choice\",\n} as const\n\n/**\n * A custom type field.\n */\nexport type CustomTypeModelField =\n\t| CustomTypeModelUIDField\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelSliceZoneField\n\t| CustomTypeModelFieldForNestedGroup\n\n/**\n * Any custom type field that is valid for a slice's primary section.\n */\nexport type CustomTypeModelFieldForSlicePrimary =\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelFieldForNestedGroup\n\n/**\n * Any custom type field that is valid for a group field.\n */\nexport type CustomTypeModelFieldForGroup =\n\t| CustomTypeModelNestedGroupField\n\t| CustomTypeModelFieldForNestedGroup\n\n/**\n * Any custom type field that is valid for a nested group field.\n */\nexport type CustomTypeModelFieldForNestedGroup =\n\t| CustomTypeModelBooleanField\n\t| CustomTypeModelColorField\n\t| CustomTypeModelDateField\n\t| CustomTypeModelEmbedField\n\t| CustomTypeModelGeoPointField\n\t| CustomTypeModelImageField\n\t| CustomTypeModelIntegrationField\n\t| CustomTypeModelContentRelationshipField\n\t| CustomTypeModelLinkField\n\t| CustomTypeModelLinkToMediaField\n\t| CustomTypeModelNumberField\n\t| CustomTypeModelRangeField\n\t| CustomTypeModelSelectField\n\t| CustomTypeModelRichTextField\n\t| CustomTypeModelTitleField\n\t| CustomTypeModelKeyTextField\n\t| CustomTypeModelTimestampField\n\t| CustomTypeModelSeparatorField\n"],"names":[],"mappings":";;;AA4BO,MAAM,2BAA2B;IACvC,SAAS;IACT,OAAO;IACP,MAAM;IACN,OAAO;IACP,UAAU;IACV,OAAO;IACP,OAAO;IACP,aAAa;IACb,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,gBAAgB;IAChB,MAAM;IACN,WAAW;IACX,KAAK;IAAA;;GAAA,GAIL,mBAAmB;IAAA;;GAAA,GAInB,OAAO;IAAA;;GAAA,GAIP,WAAW;IAAA;;GAAA,GAIX,cAAc","ignoreList":[0]}},
    {"offset": {"line": 2507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2513, "column": 0}, "map": {"version":3,"file":"link.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/model/link.ts"],"sourcesContent":["import type { CustomTypeModelFieldType } from \"./types\"\n\n/**\n * A link custom type field.\n *\n * More details: {@link https://prismic.io/docs/link}\n */\nexport interface CustomTypeModelLinkField {\n\ttype: typeof CustomTypeModelFieldType.Link\n\tconfig?: {\n\t\tlabel?: string | null\n\t\tplaceholder?: string\n\t\tselect?:\n\t\t\t| null\n\t\t\t| (typeof CustomTypeModelLinkSelectType)[keyof typeof CustomTypeModelLinkSelectType]\n\t\tallowText?: boolean\n\t\tallowTargetBlank?: boolean\n\t\trepeat?: boolean\n\t}\n}\n\n/**\n * Type of a link custom type field.\n *\n * More details: {@link https://prismic.io/docs/link}\n */\nexport const CustomTypeModelLinkSelectType = {\n\tDocument: \"document\",\n\tMedia: \"media\",\n\tWeb: \"web\",\n} as const\n"],"names":[],"mappings":";;;AA0BO,MAAM,gCAAgC;IAC5C,UAAU;IACV,OAAO;IACP,KAAK","ignoreList":[0]}},
    {"offset": {"line": 2523, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2529, "column": 0}, "map": {"version":3,"file":"slice.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/model/slice.ts"],"sourcesContent":["import type { CustomTypeModelFieldForNestedGroup } from \"./types\"\n\nimport type { CustomTypeModelNestedGroupField } from \"./group\"\nimport type { CustomTypeModelSliceType } from \"./sliceZone\"\n\n/**\n * A Slice for a custom type.\n *\n * More details: {@link https://prismic.io/docs/slice}\n *\n * @typeParam NonRepeatFields - A record of fields that cannnot be repeated.\n * @typeParam RepeatFields - A record of fields that can be repeated.\n */\nexport interface CustomTypeModelSlice<\n\tNonRepeatFields extends Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForNestedGroup\n\t> = Record<string, CustomTypeModelFieldForNestedGroup>,\n\tRepeatFields extends Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForNestedGroup\n\t> = Record<string, CustomTypeModelFieldForNestedGroup>,\n> {\n\ttype: typeof CustomTypeModelSliceType.Slice\n\tfieldset?: string | null\n\tdescription?: string\n\ticon?: string\n\tdisplay?:\n\t\t| (typeof CustomTypeModelSliceDisplay)[keyof typeof CustomTypeModelSliceDisplay]\n\t\t| string\n\t\"non-repeat\"?: NonRepeatFields\n\trepeat?: RepeatFields\n}\n\n/**\n * Display type for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport const CustomTypeModelSliceDisplay = {\n\tList: \"list\",\n\tGrid: \"grid\",\n} as const\n\n/**\n * @deprecated - Legacy slice type. Do not use.\n */\nexport type CustomTypeModelLegacySlice =\n\t| CustomTypeModelNestedGroupField\n\t| CustomTypeModelFieldForNestedGroup\n"],"names":[],"mappings":";;;AAuCO,MAAM,8BAA8B;IAC1C,MAAM;IACN,MAAM","ignoreList":[0]}},
    {"offset": {"line": 2538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2544, "column": 0}, "map": {"version":3,"file":"sliceZone.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/model/sliceZone.ts"],"sourcesContent":["import type { CustomTypeModelFieldType } from \"./types\"\n\nimport type { CustomTypeModelLegacySlice, CustomTypeModelSlice } from \"./slice\"\n\n/**\n * A Slice Zone custom type field.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSliceZoneField<\n\tSlices extends Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t> = Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t>,\n> {\n\ttype:\n\t\t| typeof CustomTypeModelFieldType.Slices\n\t\t| typeof CustomTypeModelFieldType.LegacySlices\n\tfieldset?: string | null\n\tconfig?: {\n\t\tlabels?: Record<string, readonly CustomTypeModelSliceLabel[]> | null\n\t\tchoices?: Slices\n\t}\n}\n\n/**\n * Label for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSliceLabel {\n\tname: string\n\tdisplay?: string\n}\n\n/**\n * Type identifier for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport const CustomTypeModelSliceType = {\n\tSlice: \"Slice\",\n\tSharedSlice: \"SharedSlice\",\n} as const\n\n/**\n * A shared Slice for a custom type.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSharedSlice {\n\ttype: typeof CustomTypeModelSliceType.SharedSlice\n}\n"],"names":[],"mappings":";;;AA+CO,MAAM,2BAA2B;IACvC,OAAO;IACP,aAAa","ignoreList":[0]}},
    {"offset": {"line": 2553, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2559, "column": 0}, "map": {"version":3,"file":"validateAssetMetadata.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/validateAssetMetadata.ts"],"sourcesContent":["import { PrismicError } from \"../errors/PrismicError\"\n\nimport type { CreateAssetParams } from \"../WriteClient\"\n\n/**\n * Max length for asset notes accepted by the API.\n */\nconst ASSET_NOTES_MAX_LENGTH = 500\n\n/**\n * Max length for asset credits accepted by the API.\n */\nconst ASSET_CREDITS_MAX_LENGTH = 500\n\n/**\n * Max length for asset alt text accepted by the API.\n */\nconst ASSET_ALT_MAX_LENGTH = 500\n\n/**\n * Min length for asset tags accepted by the API.\n */\nconst ASSET_TAG_MIN_LENGTH = 3\n\n/**\n * Max length for asset tags accepted by the API.\n */\nconst ASSET_TAG_MAX_LENGTH = 20\n\n/**\n * Validates an asset's metadata, throwing an error if any of the metadata are\n * invalid.\n *\n * @param assetMetadata - The asset metadata to validate.\n *\n * @internal\n */\nexport const validateAssetMetadata = ({\n\tnotes,\n\tcredits,\n\talt,\n\ttags,\n}: CreateAssetParams): void => {\n\tconst errors: string[] = []\n\n\tif (notes && notes.length > ASSET_NOTES_MAX_LENGTH) {\n\t\terrors.push(\n\t\t\t`\\`notes\\` must be at most ${ASSET_NOTES_MAX_LENGTH} characters`,\n\t\t)\n\t}\n\n\tif (credits && credits.length > ASSET_CREDITS_MAX_LENGTH) {\n\t\terrors.push(\n\t\t\t`\\`credits\\` must be at most ${ASSET_CREDITS_MAX_LENGTH} characters`,\n\t\t)\n\t}\n\n\tif (alt && alt.length > ASSET_ALT_MAX_LENGTH) {\n\t\terrors.push(`\\`alt\\` must be at most ${ASSET_ALT_MAX_LENGTH} characters`)\n\t}\n\n\tif (\n\t\ttags &&\n\t\ttags.length &&\n\t\ttags.some(\n\t\t\t(tag) =>\n\t\t\t\ttag.length < ASSET_TAG_MIN_LENGTH || tag.length > ASSET_TAG_MAX_LENGTH,\n\t\t)\n\t) {\n\t\terrors.push(\n\t\t\t`tags must be at least 3 characters long and 20 characters at most`,\n\t\t)\n\t}\n\n\tif (errors.length) {\n\t\tthrow new PrismicError(\n\t\t\t`Errors validating asset metadata: ${errors.join(\", \")}`,\n\t\t\tundefined,\n\t\t\t{ notes, credits, alt, tags },\n\t\t)\n\t}\n}\n"],"names":[],"mappings":";;;;;AAOA,MAAM,yBAAyB;AAK/B,MAAM,2BAA2B;AAKjC,MAAM,uBAAuB;AAK7B,MAAM,uBAAuB;AAK7B,MAAM,uBAAuB;AAUtB,MAAM,wBAAwB,CAAC,EACrC,KAAA,EACA,OAAA,EACA,GAAA,EACA,IAAA,EAAA,KAC6B;IAC7B,MAAM,SAAmB,CAAA,CAAA;IAErB,IAAA,SAAS,MAAM,MAAA,GAAS,wBAAwB;QAC5C,OAAA,IAAA,CACN,CAAA,0BAAA,EAA6B,sBAAsB,CAAA,WAAA,CAAa;IAElE;IAEI,IAAA,WAAW,QAAQ,MAAA,GAAS,0BAA0B;QAClD,OAAA,IAAA,CACN,CAAA,4BAAA,EAA+B,wBAAwB,CAAA,WAAA,CAAa;IAEtE;IAEI,IAAA,OAAO,IAAI,MAAA,GAAS,sBAAsB;QACtC,OAAA,IAAA,CAAK,CAAA,wBAAA,EAA2B,oBAAoB,CAAA,WAAA,CAAa;IACzE;IAEA,IACC,QACA,KAAK,MAAA,IACL,KAAK,IAAA,CACJ,CAAC,MACA,IAAI,MAAA,GAAS,wBAAwB,IAAI,MAAA,GAAS,oBAAoB,GAEvE;QACD,OAAO,IAAA,CACN,CAAA,iEAAA,CAAmE;IAErE;IAEA,IAAI,OAAO,MAAA,EAAQ;QAClB,MAAM,4KAAI,eAAA,CACT,CAAA,kCAAA,EAAqC,OAAO,IAAA,CAAK,IAAI,CAAC,EAAA,EACtD,KAAA,GACA;YAAE;YAAO;YAAS;YAAK;QAAA,CAAM;IAE/B;AACD","ignoreList":[0]}},
    {"offset": {"line": 2594, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2600, "column": 0}, "map": {"version":3,"file":"Asset.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/migration/Asset.ts"],"sourcesContent":["import type { Asset } from \"../api/asset/asset\"\nimport type { FilledImageFieldImage } from \"../value/image\"\nimport type { EmptyLinkField } from \"../value/link\"\nimport type { LinkToMediaField } from \"../value/linkToMedia\"\nimport { type RTImageNode } from \"../value/richText\"\n\nimport type { InjectMigrationSpecificTypes } from \"./Document\"\n\n/**\n * An asset to be uploaded to Prismic media library.\n */\nexport type MigrationAssetConfig = {\n\t/**\n\t * ID the assets is indexed with on the migration instance.\n\t *\n\t * @remarks\n\t * This property's value is not necessarily the same as the as the one in the\n\t * `file` property. It is mainly used for deduplication within a `Migration`\n\t * instance.\n\t */\n\tid: string | URL | File | NonNullable<ConstructorParameters<File>[0]>[0]\n\n\t/**\n\t * File to be uploaded as an asset.\n\t */\n\tfile: string | URL | File | NonNullable<ConstructorParameters<File>[0]>[0]\n\n\t/**\n\t * Filename of the asset.\n\t */\n\tfilename: string\n\n\t/**\n\t * Notes about the asset. Notes are private and only visible in Prismic media\n\t * library.\n\t */\n\tnotes?: string\n\n\t/**\n\t * Credits and copyright for the asset if any.\n\t */\n\tcredits?: string\n\n\t/**\n\t * Alternate text for the asset.\n\t */\n\talt?: string\n\n\t/**\n\t * Tags associated with the asset.\n\t *\n\t * @remarks\n\t * Tags should be at least 3 characters long and 20 characters at most.\n\t */\n\ttags?: string[]\n}\n\n/**\n * An image field in a migration.\n */\nexport type MigrationImage =\n\t| PrismicMigrationAsset\n\t| ({\n\t\t\t/**\n\t\t\t * A reference to the migration asset used to resolve the image field's\n\t\t\t * value.\n\t\t\t */\n\t\t\tid: PrismicMigrationAsset\n\t  } & Record<string, PrismicMigrationAsset>)\n\n/**\n * A link to media field in a migration.\n */\nexport type MigrationLinkToMedia = Pick<\n\tLinkToMediaField<\"filled\">,\n\t\"link_type\"\n> &\n\tPartial<Pick<LinkToMediaField<\"filled\">, \"text\">> & {\n\t\t/**\n\t\t * A reference to the migration asset used to resolve the link to media\n\t\t * field's value.\n\t\t */\n\t\tid: PrismicMigrationAsset\n\t}\n\n/**\n * The minimum amount of information needed to represent a link to media field\n * with the migration API.\n */\nexport type MigrationLinkToMediaField =\n\t| Pick<LinkToMediaField<\"filled\">, \"link_type\" | \"id\" | \"text\">\n\t| EmptyLinkField<\"Media\">\n\n/**\n * A rich text image node in a migration.\n */\nexport type MigrationRTImageNode = InjectMigrationSpecificTypes<\n\tPick<RTImageNode, \"type\" | \"linkTo\">\n> & {\n\t/**\n\t * A reference to the migration asset used to resolve the rich text image\n\t * node's value.\n\t */\n\tid: PrismicMigrationAsset\n}\n\n/**\n * A migration asset used with the Prismic Migration API.\n */\nexport class PrismicMigrationAsset {\n\t/**\n\t * Asset object from Prismic, available once created.\n\t */\n\tasset?: Asset\n\n\t/**\n\t * Configuration of the asset.\n\t */\n\tconfig: MigrationAssetConfig\n\n\t/**\n\t * The initial field value this migration field was created with.\n\t */\n\toriginalField?:\n\t\t| FilledImageFieldImage\n\t\t| LinkToMediaField<\"filled\">\n\t\t| RTImageNode\n\n\t/**\n\t * Creates a migration asset used with the Prismic Migration API.\n\t *\n\t * @param config - Configuration of the asset.\n\t * @param initialField - The initial field value if any.\n\t *\n\t * @returns A migration asset instance.\n\t */\n\tconstructor(\n\t\tconfig: MigrationAssetConfig,\n\t\tinitialField?:\n\t\t\t| FilledImageFieldImage\n\t\t\t| LinkToMediaField<\"filled\">\n\t\t\t| RTImageNode,\n\t) {\n\t\tthis.config = config\n\t\tthis.originalField = initialField\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;MA6Ga,sBAAqB;IAAA;;;;;;;GAAA,GA2BjC,YACC,MAAA,EACA,YAAA,CAGc;QA5Bf;;KAAA,GAAA,cAAA,IAAA,EAAA;QAKA;;KAAA,GAAA,cAAA,IAAA,EAAA;QAKA;;KAAA,GAAA,cAAA,IAAA,EAAA;QAoBC,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,aAAA,GAAgB;IACtB;AACA","ignoreList":[0]}},
    {"offset": {"line": 2635, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2641, "column": 0}, "map": {"version":3,"file":"Document.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/migration/Document.ts"],"sourcesContent":["import type { FilledContentRelationshipField } from \"../value/contentRelationship\"\nimport type { PrismicDocument, PrismicDocumentWithUID } from \"../value/document\"\nimport type { AnyOEmbed, EmbedField, OEmbedExtra } from \"../value/embed\"\nimport type { FilledImageFieldImage } from \"../value/image\"\nimport type { FilledLinkToMediaField } from \"../value/linkToMedia\"\nimport type { RTImageNode } from \"../value/richText\"\nimport type { SharedSlice } from \"../value/sharedSlice\"\n\nimport type {\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"./Asset\"\nimport type { MigrationContentRelationship } from \"./ContentRelationship\"\n\n/**\n * A utility type that extends any fields in a record with their migration\n * fields equivalent.\n *\n * @typeParam T - Type of the record to extend.\n */\nexport type InjectMigrationSpecificTypes<T> = T extends RTImageNode\n\t?\n\t\t\t| T\n\t\t\t| (Omit<T, \"linkTo\"> & InjectMigrationSpecificTypes<Pick<T, \"linkTo\">>)\n\t\t\t| MigrationRTImageNode\n\t\t\t| undefined\n\t: T extends FilledImageFieldImage\n\t\t? T | MigrationImage | undefined\n\t\t: T extends FilledLinkToMediaField\n\t\t\t? T | MigrationLinkToMedia | undefined\n\t\t\t: T extends FilledContentRelationshipField\n\t\t\t\t? T | MigrationContentRelationship\n\t\t\t\t: T extends EmbedField<AnyOEmbed & OEmbedExtra, \"filled\">\n\t\t\t\t\t? T | Pick<T, \"embed_url\">\n\t\t\t\t\t: T extends SharedSlice\n\t\t\t\t\t\t?\n\t\t\t\t\t\t\t\t| T\n\t\t\t\t\t\t\t\t| InjectMigrationSpecificTypes<\n\t\t\t\t\t\t\t\t\t\tOmit<T, \"id\" | \"slice_label\" | \"version\">\n\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\t\t\tT extends Record<any, any>\n\t\t\t\t\t\t\t? { [P in keyof T]: InjectMigrationSpecificTypes<T[P]> }\n\t\t\t\t\t\t\t: T extends Array<infer U>\n\t\t\t\t\t\t\t\t? Array<InjectMigrationSpecificTypes<U>>\n\t\t\t\t\t\t\t\t: T\n\n/**\n * A utility type that ties the type and data of a Prismic document, creating a\n * strict union.\n */\ntype TiedDocumentTypeAndData<TDocument extends PrismicDocument> =\n\tTDocument extends PrismicDocument<infer TData, infer TType>\n\t\t? {\n\t\t\t\t/**\n\t\t\t\t * Type of the document.\n\t\t\t\t */\n\t\t\t\ttype: TType\n\n\t\t\t\t/**\n\t\t\t\t * Data contained in the document.\n\t\t\t\t */\n\t\t\t\tdata: InjectMigrationSpecificTypes<TData>\n\t\t\t} & (TDocument extends PrismicDocumentWithUID\n\t\t\t\t? Pick<TDocument, \"uid\">\n\t\t\t\t: Partial<Pick<TDocument, \"uid\">>)\n\t\t: never\n\n/**\n * A pending Prismic document to be created with the Migration API.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport type PendingPrismicDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> = Pick<TDocument, \"lang\"> &\n\tPartial<Pick<TDocument, \"tags\">> &\n\tTiedDocumentTypeAndData<TDocument>\n\n/**\n * An existing Prismic document to be updated with the Migration API.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport type ExistingPrismicDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> = Omit<TDocument, \"uid\" | \"type\" | \"data\"> &\n\tTiedDocumentTypeAndData<TDocument>\n\n/**\n * A Prismic document to be sent to the Migration API.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport type MigrationDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> = PendingPrismicDocument<TDocument> | ExistingPrismicDocument<TDocument>\n\n/**\n * A Prismic migration document instance.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport class PrismicMigrationDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> {\n\t/**\n\t * The document to be sent to the Migration API.\n\t */\n\tdocument: MigrationDocument<TDocument> & Partial<Pick<TDocument, \"id\">>\n\n\t/**\n\t * The name of the document displayed in the editor.\n\t */\n\ttitle?: string\n\n\t/**\n\t * The link to the master language document to relate the document to if any.\n\t */\n\tmasterLanguageDocument?: MigrationContentRelationship\n\n\t/**\n\t * Original Prismic document when the migration document came from another\n\t * Prismic repository.\n\t *\n\t * @remarks\n\t * When migrating a document from another repository, one might want to alter\n\t * it with migration specific types, hence accepting an\n\t * `ExistingPrismicDocument` instead of a regular `PrismicDocument`.\n\t */\n\toriginalPrismicDocument?: ExistingPrismicDocument<PrismicDocument>\n\n\t/**\n\t * Creates a Prismic migration document instance.\n\t *\n\t * @param document - The document to be sent to the Migration API.\n\t * @param title - The name of the document displayed in the editor.\n\t * @param params - Parameters to create/update the document with on the\n\t *   Migration API.\n\t *\n\t * @returns A Prismic migration document instance.\n\t */\n\tconstructor(\n\t\tdocument: MigrationDocument<TDocument>,\n\t\ttitle?: string,\n\t\tparams?: {\n\t\t\tmasterLanguageDocument?: MigrationContentRelationship\n\t\t\toriginalPrismicDocument?: ExistingPrismicDocument<PrismicDocument>\n\t\t},\n\t) {\n\t\tthis.document = document\n\t\tthis.title = title\n\t\tthis.masterLanguageDocument = params?.masterLanguageDocument\n\t\tthis.originalPrismicDocument = params?.originalPrismicDocument\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;MAwGa,yBAAwB;IAAA;;;;;;;;;GAAA,GAuCpC,YACC,QAAA,EACA,KAAA,EACA,MAAA,CAGC;QAvCF;;KAAA,GAAA,cAAA,IAAA,EAAA;QAKA;;KAAA,GAAA,cAAA,IAAA,EAAA;QAKA;;KAAA,GAAA,cAAA,IAAA,EAAA;QAWA;;;;;;;;KAAA,GAAA,cAAA,IAAA,EAAA;QAoBC,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,sBAAA,GAAyB,UAAA,OAAA,KAAA,IAAA,OAAQ,sBAAA;QACtC,IAAA,CAAK,uBAAA,GAA0B,UAAA,OAAA,KAAA,IAAA,OAAQ,uBAAA;IACxC;AACA","ignoreList":[0]}},
    {"offset": {"line": 2689, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2695, "column": 0}, "map": {"version":3,"file":"isValue.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/isValue.ts"],"sourcesContent":["import type { InjectMigrationSpecificTypes } from \"../types/migration/Document\"\nimport type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { GroupField } from \"../types/value/group\"\nimport type { ImageField } from \"../types/value/image\"\nimport { LinkType } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\nimport { type RTImageNode, RichTextNodeType } from \"../types/value/richText\"\nimport type { SliceZone } from \"../types/value/sliceZone\"\nimport type { AnyRegularField } from \"../types/value/types\"\n\n/**\n * Unknown value to check if it's a specific field type.\n *\n * @remarks\n * Explicit types are added to help ensure narrowing is done effectively.\n */\ntype UnknownValue =\n\t| PrismicDocument\n\t| InjectMigrationSpecificTypes<AnyRegularField | GroupField | SliceZone>\n\t| unknown\n\n/**\n * Checks if a value is a link to media field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a link to media field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const filledLinkToMedia = (\n\tvalue: UnknownValue,\n): value is FilledLinkToMediaField => {\n\tif (value && typeof value === \"object\" && !(\"version\" in value)) {\n\t\tif (\n\t\t\t\"link_type\" in value &&\n\t\t\tvalue.link_type === LinkType.Media &&\n\t\t\t\"id\" in value &&\n\t\t\t\"name\" in value &&\n\t\t\t\"kind\" in value &&\n\t\t\t\"url\" in value &&\n\t\t\t\"size\" in value\n\t\t) {\n\t\t\tvalue\n\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is like an image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is like an image field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nconst imageLike = (\n\tvalue: UnknownValue,\n): value is ImageField<string, \"filled\"> | RTImageNode => {\n\tif (\n\t\tvalue &&\n\t\ttypeof value === \"object\" &&\n\t\t(!(\"version\" in value) || typeof value.version === \"object\")\n\t) {\n\t\tif (\n\t\t\t\"id\" in value &&\n\t\t\t\"url\" in value &&\n\t\t\ttypeof value.url === \"string\" &&\n\t\t\t\"dimensions\" in value &&\n\t\t\t\"edit\" in value &&\n\t\t\t\"alt\" in value &&\n\t\t\t\"copyright\" in value\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is an image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is an image field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const filledImage = (\n\tvalue: UnknownValue,\n): value is ImageField<string, \"filled\"> => {\n\tif (\n\t\timageLike(value) &&\n\t\t(!(\"type\" in value) || value.type !== RichTextNodeType.image)\n\t) {\n\t\tvalue\n\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is a rich text image node.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a rich text image node, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const rtImageNode = (value: UnknownValue): value is RTImageNode => {\n\tif (\n\t\timageLike(value) &&\n\t\t\"type\" in value &&\n\t\tvalue.type === RichTextNodeType.image\n\t) {\n\t\tvalue\n\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is a content relationship field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a content relationship, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const filledContentRelationship = (\n\tvalue: UnknownValue,\n): value is FilledContentRelationshipField => {\n\tif (value && typeof value === \"object\" && !(\"version\" in value)) {\n\t\tif (\n\t\t\t\"link_type\" in value &&\n\t\t\tvalue.link_type === LinkType.Document &&\n\t\t\t\"id\" in value &&\n\t\t\t\"type\" in value &&\n\t\t\t\"tags\" in value &&\n\t\t\t\"lang\" in value\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is a Prismic document.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a Prismic document, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const prismicDocument = (\n\tvalue: UnknownValue,\n): value is PrismicDocument => {\n\ttry {\n\t\treturn (\n\t\t\ttypeof value === \"object\" &&\n\t\t\tvalue !== null &&\n\t\t\t\"id\" in value &&\n\t\t\t\"href\" in value &&\n\t\t\ttypeof value.href === \"string\" &&\n\t\t\tnew URL(value.href) &&\n\t\t\t\"type\" in value &&\n\t\t\t\"lang\" in value &&\n\t\t\t\"tags\" in value &&\n\t\t\tArray.isArray(value.tags)\n\t\t)\n\t} catch {\n\t\treturn false\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAgCa,MAAA,oBAAoB,CAChC,UACoC;IACpC,IAAI,SAAS,OAAO,UAAU,YAAY,CAAA,CAAE,aAAa,KAAA,GAAQ;QAChE,IACC,eAAe,SACf,MAAM,SAAA,6KAAc,WAAA,CAAS,KAAA,IAC7B,QAAQ,SACR,UAAU,SACV,UAAU,SACV,SAAS,SACT,UAAU,OACT;YAGM,OAAA;QACR;IACD;IAEO,OAAA;AACR;AAYA,MAAM,YAAY,CACjB,UACwD;IAEvD,IAAA,SACA,OAAO,UAAU,YAAA,CAChB,CAAA,CAAE,aAAa,KAAA,KAAU,OAAO,MAAM,OAAA,KAAY,QAAA,GAClD;QACD,IACC,QAAQ,SACR,SAAS,SACT,OAAO,MAAM,GAAA,KAAQ,YACrB,gBAAgB,SAChB,UAAU,SACV,SAAS,SACT,eAAe,OACd;YACM,OAAA;QACR;IACD;IAEO,OAAA;AACR;AAYa,MAAA,cAAc,CAC1B,UAC0C;IAEzC,IAAA,UAAU,KAAK,KAAA,CACd,CAAA,CAAE,UAAU,KAAA,KAAU,MAAM,IAAA,iLAAS,mBAAA,CAAiB,KAAA,GACtD;QAGM,OAAA;IACR;IAEO,OAAA;AACR;AAYa,MAAA,cAAc,CAAC,UAA6C;IAEvE,IAAA,UAAU,KAAK,KACf,UAAU,SACV,MAAM,IAAA,iLAAS,mBAAA,CAAiB,KAAA,EAC/B;QAGM,OAAA;IACR;IAEO,OAAA;AACR;AAYa,MAAA,4BAA4B,CACxC,UAC4C;IAC5C,IAAI,SAAS,OAAO,UAAU,YAAY,CAAA,CAAE,aAAa,KAAA,GAAQ;QAChE,IACC,eAAe,SACf,MAAM,SAAA,6KAAc,WAAA,CAAS,QAAA,IAC7B,QAAQ,SACR,UAAU,SACV,UAAU,SACV,UAAU,OACT;YACM,OAAA;QACR;IACD;IAEO,OAAA;AACR;AAYa,MAAA,kBAAkB,CAC9B,UAC6B;IACzB,IAAA;QAEF,OAAA,OAAO,UAAU,YACjB,UAAU,QACV,QAAQ,SACR,UAAU,SACV,OAAO,MAAM,IAAA,KAAS,YACtB,IAAI,IAAI,MAAM,IAAI,KAClB,UAAU,SACV,UAAU,SACV,UAAU,SACV,MAAM,OAAA,CAAQ,MAAM,IAAI;IAAA,EAAA,OAElB;QACA,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 2751, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2757, "column": 0}, "map": {"version":3,"file":"Migration.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/Migration.ts"],"sourcesContent":["import * as is from \"./lib/isValue\"\nimport { validateAssetMetadata } from \"./lib/validateAssetMetadata\"\n\nimport type { Asset } from \"./types/api/asset/asset\"\nimport type {\n\tMigrationAssetConfig,\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"./types/migration/Asset\"\nimport { PrismicMigrationAsset } from \"./types/migration/Asset\"\nimport type { MigrationContentRelationship } from \"./types/migration/ContentRelationship\"\nimport { PrismicMigrationDocument } from \"./types/migration/Document\"\nimport type {\n\tExistingPrismicDocument,\n\tPendingPrismicDocument,\n} from \"./types/migration/Document\"\nimport type { PrismicDocument } from \"./types/value/document\"\nimport type { FilledImageFieldImage } from \"./types/value/image\"\nimport { type FilledLinkToWebField, LinkType } from \"./types/value/link\"\nimport type { FilledLinkToMediaField } from \"./types/value/linkToMedia\"\nimport { RichTextNodeType } from \"./types/value/richText\"\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends { type: string },\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * A helper that allows preparing your migration to Prismic.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Migration<TDocuments extends PrismicDocument = PrismicDocument> {\n\t/**\n\t * Assets registered in the migration.\n\t *\n\t * @internal\n\t */\n\t_assets: Map<MigrationAssetConfig[\"file\"], PrismicMigrationAsset> = new Map()\n\n\t/**\n\t * Documents registered in the migration.\n\t *\n\t * @internal\n\t */\n\t_documents: PrismicMigrationDocument<TDocuments>[] = []\n\n\t/**\n\t * Registers an asset to be created in the migration from an asset object.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param asset - An asset object from Prismic Asset API.\n\t *\n\t * @returns A migration asset field instance.\n\t *\n\t * @internal\n\t */\n\tcreateAsset(asset: Asset): PrismicMigrationAsset\n\n\t/**\n\t * Registers an asset to be created in the migration from an image or link to\n\t * media field.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param imageOrLinkToMediaField - An image or link to media field from\n\t *   Prismic Document API.\n\t *\n\t * @returns A migration asset field instance.\n\t *\n\t * @internal\n\t */\n\tcreateAsset(\n\t\timageOrLinkToMediaField: FilledImageFieldImage | FilledLinkToMediaField,\n\t): PrismicMigrationAsset\n\n\t/**\n\t * Registers an asset to be created in the migration from a file.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param file - The URL or content of the file to be created.\n\t * @param filename - The filename of the asset.\n\t * @param params - Additional asset data.\n\t *\n\t * @returns A migration asset field instance.\n\t */\n\tcreateAsset(\n\t\tfile: MigrationAssetConfig[\"file\"],\n\t\tfilename: MigrationAssetConfig[\"filename\"],\n\t\tparams?: {\n\t\t\tnotes?: string\n\t\t\tcredits?: string\n\t\t\talt?: string\n\t\t\ttags?: string[]\n\t\t},\n\t): PrismicMigrationAsset\n\n\t/**\n\t * Registers an asset to be created in the migration from a file, an asset\n\t * object, or an image or link to media field.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @returns A migration asset field instance.\n\t */\n\tcreateAsset(\n\t\tfileOrAssetOrField:\n\t\t\t| MigrationAssetConfig[\"file\"]\n\t\t\t| Asset\n\t\t\t| FilledImageFieldImage\n\t\t\t| FilledLinkToMediaField,\n\t\tfilename?: MigrationAssetConfig[\"filename\"],\n\t\t{\n\t\t\tnotes,\n\t\t\tcredits,\n\t\t\talt,\n\t\t\ttags,\n\t\t}: {\n\t\t\tnotes?: string\n\t\t\tcredits?: string\n\t\t\talt?: string\n\t\t\ttags?: string[]\n\t\t} = {},\n\t): PrismicMigrationAsset {\n\t\tlet config: MigrationAssetConfig\n\t\tlet maybeInitialField: FilledImageFieldImage | undefined\n\t\tif (typeof fileOrAssetOrField === \"object\" && \"url\" in fileOrAssetOrField) {\n\t\t\tif (\n\t\t\t\t\"dimensions\" in fileOrAssetOrField ||\n\t\t\t\t\"link_type\" in fileOrAssetOrField\n\t\t\t) {\n\t\t\t\tconst url = fileOrAssetOrField.url.split(\"?\")[0]\n\t\t\t\tconst filename =\n\t\t\t\t\t\"name\" in fileOrAssetOrField\n\t\t\t\t\t\t? fileOrAssetOrField.name\n\t\t\t\t\t\t: url.split(\"/\").pop()!.split(\"_\").pop()!\n\t\t\t\tconst credits =\n\t\t\t\t\t\"copyright\" in fileOrAssetOrField && fileOrAssetOrField.copyright\n\t\t\t\t\t\t? fileOrAssetOrField.copyright\n\t\t\t\t\t\t: undefined\n\t\t\t\tconst alt =\n\t\t\t\t\t\"alt\" in fileOrAssetOrField && fileOrAssetOrField.alt\n\t\t\t\t\t\t? fileOrAssetOrField.alt\n\t\t\t\t\t\t: undefined\n\n\t\t\t\tif (\"dimensions\" in fileOrAssetOrField) {\n\t\t\t\t\tmaybeInitialField = fileOrAssetOrField\n\t\t\t\t}\n\n\t\t\t\tconfig = {\n\t\t\t\t\tid: fileOrAssetOrField.id,\n\t\t\t\t\tfile: url,\n\t\t\t\t\tfilename,\n\t\t\t\t\tnotes: undefined,\n\t\t\t\t\tcredits,\n\t\t\t\t\talt,\n\t\t\t\t\ttags: undefined,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconfig = {\n\t\t\t\t\tid: fileOrAssetOrField.id,\n\t\t\t\t\tfile: fileOrAssetOrField.url,\n\t\t\t\t\tfilename: fileOrAssetOrField.filename,\n\t\t\t\t\tnotes: fileOrAssetOrField.notes,\n\t\t\t\t\tcredits: fileOrAssetOrField.credits,\n\t\t\t\t\talt: fileOrAssetOrField.alt,\n\t\t\t\t\ttags: fileOrAssetOrField.tags?.map(({ name }) => name),\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = {\n\t\t\t\tid: fileOrAssetOrField,\n\t\t\t\tfile: fileOrAssetOrField,\n\t\t\t\tfilename: filename!,\n\t\t\t\tnotes,\n\t\t\t\tcredits,\n\t\t\t\talt,\n\t\t\t\ttags,\n\t\t\t}\n\t\t}\n\n\t\tvalidateAssetMetadata(config)\n\n\t\t// We create a detached instance of the asset each time to serialize it properly\n\t\tconst migrationAsset = new PrismicMigrationAsset(config, maybeInitialField)\n\n\t\tconst maybeAsset = this._assets.get(config.id)\n\t\tif (maybeAsset) {\n\t\t\t// Consolidate existing asset with new asset value if possible\n\t\t\tmaybeAsset.config.notes = maybeAsset.config.notes || config.notes\n\t\t\tmaybeAsset.config.credits = maybeAsset.config.credits || config.credits\n\t\t\tmaybeAsset.config.alt = maybeAsset.config.alt || config.alt\n\t\t\tmaybeAsset.config.tags = Array.from(\n\t\t\t\tnew Set([...(maybeAsset.config.tags || []), ...(config.tags || [])]),\n\t\t\t)\n\t\t} else {\n\t\t\tthis._assets.set(config.id, migrationAsset)\n\t\t}\n\n\t\treturn migrationAsset\n\t}\n\n\t/**\n\t * Registers a document to be created in the migration.\n\t *\n\t * @remarks\n\t * This method does not create the document in Prismic right away. Instead, it\n\t * registers it in your migration. The document will be created when the\n\t * migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @typeParam TType - Type of the Prismic document to create.\n\t *\n\t * @param document - The document to create.\n\t * @param title - The title of the document to create which will be displayed\n\t *   in the editor.\n\t * @param params - Document master language document ID.\n\t *\n\t * @returns A migration document instance.\n\t */\n\tcreateDocument<TType extends TDocuments[\"type\"]>(\n\t\tdocument: ExtractDocumentType<PendingPrismicDocument<TDocuments>, TType>,\n\t\ttitle: string,\n\t\tparams?: {\n\t\t\tmasterLanguageDocument?: MigrationContentRelationship\n\t\t},\n\t): PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>> {\n\t\tconst doc = new PrismicMigrationDocument<\n\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t>(document, title, params)\n\n\t\tthis._documents.push(doc)\n\n\t\treturn doc\n\t}\n\n\t/**\n\t * Registers an existing document to be updated in the migration.\n\t *\n\t * @remarks\n\t * This method does not update the document in Prismic right away. Instead, it\n\t * registers it in your migration. The document will be updated when the\n\t * migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @typeParam TType - Type of Prismic documents to update.\n\t *\n\t * @param document - The document to update.\n\t * @param title - The title of the document to update which will be displayed\n\t *   in the editor.\n\t *\n\t * @returns A migration document instance.\n\t */\n\tupdateDocument<TType extends TDocuments[\"type\"]>(\n\t\tdocument: ExtractDocumentType<ExistingPrismicDocument<TDocuments>, TType>,\n\t\t// Title is optional for existing documents as we might not want to update it.\n\t\ttitle?: string,\n\t): PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>> {\n\t\tconst doc = new PrismicMigrationDocument<\n\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t>(document, title)\n\n\t\tthis._documents.push(doc)\n\n\t\treturn doc\n\t}\n\n\t/**\n\t * Registers a document from another Prismic repository to be created in the\n\t * migration.\n\t *\n\t * @remarks\n\t * This method does not create the document in Prismic right away. Instead, it\n\t * registers it in your migration. The document will be created when the\n\t * migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param document - The document from Prismic to create.\n\t * @param title - The title of the document to create which will be displayed\n\t *   in the editor.\n\t *\n\t * @returns A migration document instance.\n\t */\n\tcreateDocumentFromPrismic<TType extends TDocuments[\"type\"]>(\n\t\tdocument: ExtractDocumentType<ExistingPrismicDocument<TDocuments>, TType>,\n\t\ttitle: string,\n\t): PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>> {\n\t\tconst doc = new PrismicMigrationDocument(\n\t\t\tthis.#migratePrismicDocumentData({\n\t\t\t\ttype: document.type,\n\t\t\t\tlang: document.lang,\n\t\t\t\tuid: document.uid,\n\t\t\t\ttags: document.tags,\n\t\t\t\tdata: document.data,\n\t\t\t}) as PendingPrismicDocument<ExtractDocumentType<TDocuments, TType>>,\n\t\t\ttitle,\n\t\t\t{ originalPrismicDocument: document },\n\t\t)\n\n\t\tthis._documents.push(doc)\n\n\t\treturn doc\n\t}\n\n\t/**\n\t * Queries a document from the migration instance with a specific UID and\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const contentRelationship = migration.createContentRelationship(() =>\n\t * \tmigration.getByUID(\"blog_post\", \"my-first-post\"),\n\t * )\n\t * ```\n\t *\n\t * @typeParam TType - Type of the Prismic document returned.\n\t *\n\t * @param type - The API ID of the document's custom type.\n\t * @param uid - The UID of the document.\n\t *\n\t * @returns The migration document instance with a UID matching the `uid`\n\t *   parameter, if a matching document is found.\n\t */\n\tgetByUID<TType extends TDocuments[\"type\"]>(\n\t\ttype: TType,\n\t\tuid: string,\n\t):\n\t\t| PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>>\n\t\t| undefined {\n\t\treturn this._documents.find(\n\t\t\t(\n\t\t\t\tdoc,\n\t\t\t): doc is PrismicMigrationDocument<\n\t\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t\t> => doc.document.type === type && doc.document.uid === uid,\n\t\t)\n\t}\n\n\t/**\n\t * Queries a singleton document from the migration instance for a specific\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const contentRelationship = migration.createContentRelationship(() =>\n\t * \tmigration.getSingle(\"settings\"),\n\t * )\n\t * ```\n\t *\n\t * @typeParam TType - Type of the Prismic document returned.\n\t *\n\t * @param type - The API ID of the singleton custom type.\n\t *\n\t * @returns The migration document instance for the custom type, if a matching\n\t *   document is found.\n\t */\n\tgetSingle<TType extends TDocuments[\"type\"]>(\n\t\ttype: TType,\n\t):\n\t\t| PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>>\n\t\t| undefined {\n\t\treturn this._documents.find(\n\t\t\t(\n\t\t\t\tdoc,\n\t\t\t): doc is PrismicMigrationDocument<\n\t\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t\t> => doc.document.type === type,\n\t\t)\n\t}\n\n\t/**\n\t * Migrates a Prismic document data from another repository so that it can be\n\t * created through the current repository's Migration API.\n\t *\n\t * @param input - The Prismic document data to migrate.\n\t *\n\t * @returns The migrated Prismic document data.\n\t */\n\t#migratePrismicDocumentData(input: unknown): unknown {\n\t\tif (is.filledContentRelationship(input)) {\n\t\t\tif (input.isBroken) {\n\t\t\t\treturn {\n\t\t\t\t\tlink_type: LinkType.Document,\n\t\t\t\t\t// ID needs to be 16 characters long to be considered valid by the API\n\t\t\t\t\tid: \"_____broken_____\",\n\t\t\t\t\tisBroken: true,\n\t\t\t\t\ttext: input.text,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tlink_type: LinkType.Document,\n\t\t\t\tid: () => this._getByOriginalID(input.id),\n\t\t\t\ttext: input.text,\n\t\t\t}\n\t\t}\n\n\t\tif (is.filledLinkToMedia(input)) {\n\t\t\treturn {\n\t\t\t\tlink_type: LinkType.Media,\n\t\t\t\tid: this.createAsset(input),\n\t\t\t\ttext: input.text,\n\t\t\t}\n\t\t}\n\n\t\tif (is.rtImageNode(input)) {\n\t\t\t// Rich text image nodes\n\t\t\tconst rtImageNode: MigrationRTImageNode = {\n\t\t\t\ttype: RichTextNodeType.image,\n\t\t\t\tid: this.createAsset(input),\n\t\t\t}\n\n\t\t\tif (input.linkTo) {\n\t\t\t\trtImageNode.linkTo = this.#migratePrismicDocumentData(input.linkTo) as\n\t\t\t\t\t| MigrationContentRelationship\n\t\t\t\t\t| MigrationLinkToMedia\n\t\t\t\t\t| FilledLinkToWebField\n\t\t\t}\n\n\t\t\treturn rtImageNode\n\t\t}\n\n\t\tif (is.filledImage(input)) {\n\t\t\tconst image: MigrationImage = {\n\t\t\t\tid: this.createAsset(input),\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tid: _id,\n\t\t\t\turl: _url,\n\t\t\t\tdimensions: _dimensions,\n\t\t\t\tedit: _edit,\n\t\t\t\talt: _alt,\n\t\t\t\tcopyright: _copyright,\n\t\t\t\t...thumbnails\n\t\t\t} = input\n\n\t\t\tfor (const name in thumbnails) {\n\t\t\t\tif (is.filledImage(thumbnails[name])) {\n\t\t\t\t\timage[name] = this.createAsset(thumbnails[name])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn image\n\t\t}\n\n\t\tif (Array.isArray(input)) {\n\t\t\treturn input.map((element) => this.#migratePrismicDocumentData(element))\n\t\t}\n\n\t\tif (input && typeof input === \"object\") {\n\t\t\tconst res: Record<PropertyKey, unknown> = {}\n\n\t\t\tfor (const key in input) {\n\t\t\t\tres[key] = this.#migratePrismicDocumentData(\n\t\t\t\t\tinput[key as keyof typeof input],\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn res\n\t\t}\n\n\t\treturn input\n\t}\n\n\t/**\n\t * Queries a document from the migration instance for a specific original ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const contentRelationship = migration.createContentRelationship(() =>\n\t * \tmigration._getByOriginalID(\"YhdrDxIAACgAcp_b\"),\n\t * )\n\t * ```\n\t *\n\t * @typeParam TType - Type of the Prismic document returned.\n\t *\n\t * @param id - The original ID of the Prismic document.\n\t *\n\t * @returns The migration document instance for the original ID, if a matching\n\t *   document is found.\n\t *\n\t * @internal\n\t */\n\t_getByOriginalID<TType extends TDocuments[\"type\"]>(\n\t\tid: string,\n\t):\n\t\t| PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>>\n\t\t| undefined {\n\t\treturn this._documents.find(\n\t\t\t(\n\t\t\t\tdoc,\n\t\t\t): doc is PrismicMigrationDocument<\n\t\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t\t> => doc.originalPrismicDocument?.id === id,\n\t\t)\n\t}\n}\n"],"names":["filename","credits","alt","is.filledContentRelationship","is.filledLinkToMedia","is.rtImageNode","rtImageNode","is.filledImage"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3076, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3082, "column": 0}, "map": {"version":3,"file":"embed.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/value/embed.ts"],"sourcesContent":["import type { EmptyObjectField, FieldState } from \"./types\"\n\n/**\n * oEmbed 1.0 possible types.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport const OEmbedType = {\n\tPhoto: \"photo\",\n\tVideo: \"video\",\n\tLink: \"link\",\n\tRich: \"rich\",\n} as const\n\n/**\n * oEmbed response base fields. Those are every mandatory fields an oEmbed\n * response must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\ntype OEmbedBase<TType extends (typeof OEmbedType)[keyof typeof OEmbedType]> = {\n\t/**\n\t * oEmbed resource type.\n\t */\n\ttype: TType\n\n\t/**\n\t * oEmbed version number, this must be \"1.0\".\n\t */\n\tversion: string\n}\n\n/**\n * oEmbed response extra fields. Those are every non-mandatory and unknown\n * fields an oEmbed response can feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type OEmbedExtra = {\n\t/**\n\t * oEmbed text title, describing the resource.\n\t */\n\ttitle?: string | null\n\n\t/**\n\t * oEmbed resource author/owner name.\n\t */\n\tauthor_name?: string | null\n\n\t/**\n\t * oEmbed resource author/owner URL.\n\t */\n\tauthor_url?: string | null\n\n\t/**\n\t * oEmbed resource provider name.\n\t */\n\tprovider_name?: string | null\n\n\t/**\n\t * oEmbed resource provider URL.\n\t */\n\tprovider_url?: string | null\n\n\t/**\n\t * oEmbed suggested cache lifetime for the resource, in seconds.\n\t */\n\tcache_age?: number | null\n\n\t/**\n\t * oEmbed resource thumbnail URL.\n\t */\n\tthumbnail_url?: string | null\n\n\t/**\n\t * oEmbed resource thumbnail width.\n\t */\n\tthumbnail_width?: number | null\n\n\t/**\n\t * oEmbed resource thumbnail height.\n\t */\n\tthumbnail_height?: number | null\n\n\t/**\n\t * Providers may optionally include any parameters not specified in this\n\t * document (so long as they use the same key-value format) and consumers may\n\t * choose to ignore these. Consumers must ignore parameters they do not\n\t * understand.\n\t *\n\t * @see oEmbed specification: {@link https://oembed.com}\n\t */\n\t[key: string]: unknown | null\n}\n\n/**\n * oEmbed photo type. Those are every mandatory fields an oEmbed photo response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type PhotoOEmbed = OEmbedBase<typeof OEmbedType.Photo> & {\n\t/**\n\t * oEmbed source URL of the image.\n\t */\n\turl: string\n\n\t/**\n\t * oEmbed width in pixels of the image.\n\t */\n\twidth: number\n\n\t/**\n\t * oEmbed height in pixels of the image.\n\t */\n\theight: number\n}\n\n/**\n * oEmbed video type. Those are every mandatory fields an oEmbed video response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type VideoOEmbed = OEmbedBase<typeof OEmbedType.Video> & {\n\t/**\n\t * oEmbed HTML required to embed a video player.\n\t */\n\thtml: string\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number\n}\n\n/**\n * oEmbed link type. Those are every mandatory fields an oEmbed link response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type LinkOEmbed = OEmbedBase<typeof OEmbedType.Link>\n\n/**\n * oEmbed rich type. Those are every mandatory fields an oEmbed rich response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type RichOEmbed = OEmbedBase<typeof OEmbedType.Rich> & {\n\t/**\n\t * oEmbed HTML required to display the resource.\n\t */\n\thtml: string\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number\n}\n\n/**\n * Any of the possible types of oEmbed response. Those contains only mandatory\n * fields their respective oEmbed response type must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type AnyOEmbed = PhotoOEmbed | VideoOEmbed | LinkOEmbed | RichOEmbed\n\n/**\n * An embed field.\n *\n * @typeParam Data - Data provided by the URL's oEmbed provider.\n * @typeParam State - State of the field which determines its shape.\n *\n * @see More details: {@link https://prismic.io/docs/embed}\n */\nexport type EmbedField<\n\tData extends AnyOEmbed = AnyOEmbed & OEmbedExtra,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyObjectField\n\t: Data & {\n\t\t\tembed_url: string\n\t\t\thtml: string | null\n\t\t}\n"],"names":[],"mappings":";;;AAOO,MAAM,aAAa;IACzB,OAAO;IACP,OAAO;IACP,MAAM;IACN,MAAM","ignoreList":[0]}},
    {"offset": {"line": 3093, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3099, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/types/webhook/types.ts"],"sourcesContent":["import type { WebhookBodyAPIUpdate } from \"./apiUpdate\"\nimport type { WebhookBodyTestTrigger } from \"./testTrigger\"\n\nexport type WebhookBody = WebhookBodyAPIUpdate | WebhookBodyTestTrigger\n\n/**\n * Types of Prismic Webhooks.\n *\n * @see More details: {@link https://prismic.io/docs/webhooks}\n */\nexport const WebhookType = {\n\tAPIUpdate: \"api-update\",\n\tTestTrigger: \"test-trigger\",\n} as const\n\nexport interface WebhookBodyBase {\n\ttype: (typeof WebhookType)[keyof typeof WebhookType]\n\tdomain: string\n\tapiUrl: string\n\tsecret: string | null\n}\n"],"names":[],"mappings":";;;AAUO,MAAM,cAAc;IAC1B,WAAW;IACX,aAAa","ignoreList":[0]}},
    {"offset": {"line": 3108, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3114, "column": 0}, "map": {"version":3,"file":"isMigrationValue.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/isMigrationValue.ts"],"sourcesContent":["import type {\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"../types/migration/Asset\"\nimport { PrismicMigrationAsset } from \"../types/migration/Asset\"\nimport type { MigrationContentRelationship } from \"../types/migration/ContentRelationship\"\nimport {\n\ttype InjectMigrationSpecificTypes,\n\tPrismicMigrationDocument,\n} from \"../types/migration/Document\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { GroupField } from \"../types/value/group\"\nimport { LinkType } from \"../types/value/link\"\nimport { RichTextNodeType } from \"../types/value/richText\"\nimport type { SliceZone } from \"../types/value/sliceZone\"\nimport type { AnyRegularField } from \"../types/value/types\"\n\nimport * as is from \"./isValue\"\n\n/**\n * Unknown value to check if it's a specific field type.\n *\n * @remarks\n * Explicit types are added to help ensure narrowing is done effectively.\n */\ntype UnknownValue =\n\t| PrismicDocument\n\t| InjectMigrationSpecificTypes<AnyRegularField | GroupField | SliceZone>\n\t| unknown\n\n/**\n * Checks if a value is a migration content relationship field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration content relationship field, `false`\n *   otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const contentRelationship = (\n\tvalue: UnknownValue,\n): value is MigrationContentRelationship => {\n\treturn (\n\t\tvalue instanceof PrismicMigrationDocument ||\n\t\tis.prismicDocument(value) ||\n\t\t(typeof value === \"object\" &&\n\t\t\tvalue !== null &&\n\t\t\t\"link_type\" in value &&\n\t\t\tvalue.link_type === LinkType.Document &&\n\t\t\t\"id\" in value &&\n\t\t\t(contentRelationship(value.id) || typeof value.id === \"function\"))\n\t)\n}\n\n/**\n * Checks if a value is a migration image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration image field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const image = (value: UnknownValue): value is MigrationImage => {\n\treturn (\n\t\tvalue instanceof PrismicMigrationAsset ||\n\t\t(typeof value === \"object\" &&\n\t\t\tvalue !== null &&\n\t\t\t\"id\" in value &&\n\t\t\tObject.values(value).every(\n\t\t\t\t(maybeThumbnail) => maybeThumbnail instanceof PrismicMigrationAsset,\n\t\t\t))\n\t)\n}\n\n/**\n * Checks if a value is a migration link to media field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration link to media field, `false`\n *   otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const linkToMedia = (\n\tvalue: UnknownValue,\n): value is MigrationLinkToMedia => {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"id\" in value &&\n\t\tvalue.id instanceof PrismicMigrationAsset &&\n\t\t\"link_type\" in value &&\n\t\tvalue.link_type === LinkType.Media\n\t)\n}\n\n/**\n * Checks if a value is a migration rich text image node.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration rich text image node, `false`\n *   otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const rtImageNode = (\n\tvalue: UnknownValue,\n): value is MigrationRTImageNode => {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"id\" in value &&\n\t\tvalue.id instanceof PrismicMigrationAsset &&\n\t\t\"type\" in value &&\n\t\tvalue.type === RichTextNodeType.image\n\t)\n}\n"],"names":["is.prismicDocument"],"mappings":";;;;;;;;;;;;;;;;AA0Ca,MAAA,sBAAsB,CAClC,UAC0C;IAEzC,OAAA,iMAAiB,2BAAA,wKACjBA,kBAAAA,EAAmB,KAAK,KACvB,OAAO,UAAU,YACjB,UAAU,QACV,eAAe,SACf,MAAM,SAAA,6KAAc,WAAA,CAAS,QAAA,IAC7B,QAAQ,SAAA,CACP,oBAAoB,MAAM,EAAE,KAAK,OAAO,MAAM,EAAA,KAAO,UAAA;AAEzD;AAYa,MAAA,QAAQ,CAAC,UAAgD;IACrE,OACC,6LAAiB,yBAAA,IAChB,OAAO,UAAU,YACjB,UAAU,QACV,QAAQ,SACR,OAAO,MAAA,CAAO,KAAK,EAAE,KAAA,CACpB,CAAC,iBAAmB,0BAA0B,qMAAqB;AAGvE;AAaa,MAAA,cAAc,CAC1B,UACkC;IAClC,OACC,OAAO,UAAU,YACjB,UAAU,QACV,QAAQ,SACR,MAAM,EAAA,yLAAc,wBAAA,IACpB,eAAe,SACf,MAAM,SAAA,6KAAc,WAAA,CAAS,KAAA;AAE/B;AAaa,MAAA,cAAc,CAC1B,UACkC;IAClC,OACC,OAAO,UAAU,YACjB,UAAU,QACV,QAAQ,SACR,MAAM,EAAA,yLAAc,wBAAA,IACpB,UAAU,SACV,MAAM,IAAA,iLAAS,mBAAA,CAAiB,KAAA;AAElC","ignoreList":[0]}},
    {"offset": {"line": 3144, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3150, "column": 0}, "map": {"version":3,"file":"isFilled.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/isFilled.ts"],"sourcesContent":["import type { ColorField } from \"../types/value/color\"\nimport type { ContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { DateField } from \"../types/value/date\"\nimport type { AnyOEmbed, EmbedField } from \"../types/value/embed\"\nimport type { GeoPointField } from \"../types/value/geoPoint\"\nimport type { GroupField, NestedGroupField } from \"../types/value/group\"\nimport type { ImageField, ImageFieldImage } from \"../types/value/image\"\nimport type { IntegrationField } from \"../types/value/integration\"\nimport type { KeyTextField } from \"../types/value/keyText\"\nimport type { LinkField } from \"../types/value/link\"\nimport type { LinkToMediaField } from \"../types/value/linkToMedia\"\nimport type { NumberField } from \"../types/value/number\"\nimport type { RichTextField } from \"../types/value/richText\"\nimport type { SelectField } from \"../types/value/select\"\nimport type { SharedSlice } from \"../types/value/sharedSlice\"\nimport type { Slice } from \"../types/value/slice\"\nimport type { SliceZone } from \"../types/value/sliceZone\"\nimport type { TimestampField } from \"../types/value/timestamp\"\nimport type { TitleField } from \"../types/value/title\"\nimport type { AnyRegularField, Repeatable } from \"../types/value/types\"\n\n/**\n * Determines if a value is not nullish (i.e. not `null` or `undefined`). This\n * is used to check if nullable field values are filled.\n *\n * @param input - The value to check.\n *\n * @returns `true` if `input` is not nullish, `false` otherwise.\n */\nconst isNonNullish = <T>(input: T): input is NonNullable<T> => {\n\treturn input != null\n}\n\n/**\n * Determines if an array is not empty. This is used to check if array-based\n * fields are filled.\n *\n * @param input - The array to check.\n *\n * @returns `true` if `input` has at least one element, `false` otherwise.\n */\nconst isNonEmptyArray = <T>(input: T[]): input is [T, ...T[]] => {\n\treturn !!input.length\n}\n\n/**\n * Determines if a rich text field is filled.\n *\n * @param field - rich text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const richText = (\n\tfield: RichTextField | null | undefined,\n): field is RichTextField<\"filled\"> => {\n\tif (!isNonNullish(field)) {\n\t\treturn false\n\t} else if (field.length === 1 && \"text\" in field[0]) {\n\t\treturn !!field[0].text\n\t} else {\n\t\treturn !!field.length\n\t}\n}\n\n/**\n * Determines if a title field is filled.\n *\n * @param field - Title field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const title = richText as (\n\tfield: TitleField | null | undefined,\n) => field is TitleField<\"filled\">\n\n/**\n * Determines if an Image thumbnail is filled.\n *\n * @param thumbnail - Image thumbnail to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const imageThumbnail = (\n\tthumbnail: ImageFieldImage | null | undefined,\n): thumbnail is ImageFieldImage<\"filled\"> => {\n\treturn isNonNullish(thumbnail) && !!thumbnail.url\n}\n\n/**\n * Determines if an image field is filled.\n *\n * @param field - Image field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const image = imageThumbnail as <\n\tThumbnailNames extends string | null = never,\n>(\n\tfield: ImageField<ThumbnailNames> | null | undefined,\n) => field is ImageField<ThumbnailNames, \"filled\">\n\n/**\n * Determines if a link field is filled.\n *\n * @param field - Link field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const link = <\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n>(\n\tfield: LinkField<TypeEnum, LangEnum, DataInterface> | null | undefined,\n): field is LinkField<TypeEnum, LangEnum, DataInterface, \"filled\"> => {\n\treturn isNonNullish(field) && (\"id\" in field || \"url\" in field)\n}\n\n/**\n * Determines if a link to media field is filled.\n *\n * @param field - Link to media field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const linkToMedia = link as (\n\tfield: LinkToMediaField | null | undefined,\n) => field is LinkToMediaField<\"filled\">\n\n/**\n * Determines if a content relationship field is filled.\n *\n * @param field - Content Relationship field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const contentRelationship = link as <\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n>(\n\tfield:\n\t\t| ContentRelationshipField<TypeEnum, LangEnum, DataInterface>\n\t\t| null\n\t\t| undefined,\n) => field is ContentRelationshipField<\n\tTypeEnum,\n\tLangEnum,\n\tDataInterface,\n\t\"filled\"\n>\n\n/**\n * Determines if a date field is filled.\n *\n * @param field - Date field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const date = isNonNullish as (\n\tfield: DateField | null | undefined,\n) => field is DateField<\"filled\">\n\n/**\n * Determines if a timestamp field is filled.\n *\n * @param field - Timestamp field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const timestamp = isNonNullish as (\n\tfield: TimestampField | null | undefined,\n) => field is TimestampField<\"filled\">\n\n/**\n * Determines if a color field is filled.\n *\n * @param field - Color field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const color = isNonNullish as (\n\tfield: ColorField | null | undefined,\n) => field is ColorField<\"filled\">\n\n/**\n * Determines if a number field is filled.\n *\n * @param field - Number field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const number = isNonNullish as (\n\tfield: NumberField | null | undefined,\n) => field is NumberField<\"filled\">\n\n/**\n * Determines if a key text field is filled.\n *\n * @param field - Key Text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const keyText = (\n\tfield: KeyTextField | null | undefined,\n): field is KeyTextField<\"filled\"> => {\n\treturn isNonNullish(keyText) && !!field\n}\n\n/**\n * Determines if a select field is filled.\n *\n * @param field - Select field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const select = isNonNullish as <Enum extends string>(\n\tfield: SelectField<Enum> | null | undefined,\n) => field is SelectField<Enum, \"filled\">\n\n/**\n * Determines if an embed field is filled.\n *\n * @param field - Embed field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const embed = <Field extends EmbedField<AnyOEmbed>>(\n\tfield: Field | null | undefined,\n): field is Extract<Field, EmbedField<AnyOEmbed, \"filled\">> => {\n\treturn isNonNullish(field) && !!field.embed_url\n}\n\n/**\n * Determines if a geopoint field is filled.\n *\n * @param field - GeoPoint field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const geoPoint = (\n\tfield: GeoPointField | null | undefined,\n): field is GeoPointField<\"filled\"> => {\n\treturn isNonNullish(field) && \"longitude\" in field\n}\n\n/**\n * Determines if an integration field is filled.\n *\n * @param field - Integration field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const integrationField = isNonNullish as <\n\tData extends Record<string, unknown>,\n>(\n\tfield: IntegrationField<Data> | null | undefined,\n) => field is IntegrationField<Data, \"filled\">\n/**\n * @deprecated Renamed to `integrationField`.\n */\n// TODO: Remove when we remove support for deprecated `integrationFields` export.\nexport const integrationFields = integrationField\n\n/**\n * Determines if a repeatable field has at least one item.\n *\n * @param repeatable - Repeatable to check.\n *\n * @returns `true` if `repeatable` contains at least one item, `false`\n *   otherwise.\n */\nexport const repeatable = <T extends LinkField>(\n\trepeatable: Repeatable<T> | null | undefined,\n): repeatable is Repeatable<T, \"filled\"> => {\n\treturn isNonNullish(repeatable) && isNonEmptyArray(repeatable)\n}\n\n/**\n * Determines if a Group has at least one item.\n *\n * @param group - Group to check.\n *\n * @returns `true` if `group` contains at least one item, `false` otherwise.\n */\nexport const group = <\n\tFields extends Record<string, AnyRegularField | NestedGroupField>,\n>(\n\tgroup: GroupField<Fields> | null | undefined,\n): group is GroupField<Fields, \"filled\"> => {\n\treturn isNonNullish(group) && isNonEmptyArray(group)\n}\n\n/**\n * Determines if a Slice Zone has at least one Slice.\n *\n * @param slices - Slice Zone to check.\n *\n * @returns `true` if `slices` contains at least one Slice, `false` otherwise.\n */\nexport const sliceZone = <Slices extends Slice | SharedSlice>(\n\tslices: SliceZone<Slices> | null | undefined,\n): slices is SliceZone<Slices, \"filled\"> => {\n\treturn isNonNullish(slices) && isNonEmptyArray(slices)\n}\n"],"names":["repeatable","group"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AA6BA,MAAM,eAAe,CAAI,UAAqC;IAC7D,OAAO,SAAS;AACjB;AAUA,MAAM,kBAAkB,CAAI,UAAoC;IACxD,OAAA,CAAC,CAAC,MAAM,MAAA;AAChB;AASa,MAAA,WAAW,CACvB,UACqC;IACjC,IAAA,CAAC,aAAa,KAAK,GAAG;QAClB,OAAA;IAAA,OAAA,IACG,MAAM,MAAA,KAAW,KAAK,UAAU,KAAA,CAAM,CAAC,CAAA,EAAG;QACpD,OAAO,CAAC,CAAC,KAAA,CAAM,CAAC,CAAA,CAAE,IAAA;IAAA,OACZ;QACC,OAAA,CAAC,CAAC,MAAM,MAAA;IAChB;AACD;AASO,MAAM,QAAQ;AAWR,MAAA,iBAAiB,CAC7B,cAC2C;IAC3C,OAAO,aAAa,SAAS,KAAK,CAAC,CAAC,UAAU,GAAA;AAC/C;AASO,MAAM,QAAQ;AAaR,MAAA,OAAO,CAOnB,UACoE;IACpE,OAAO,aAAa,KAAK,KAAA,CAAM,QAAQ,SAAS,SAAS,KAAA;AAC1D;AASO,MAAM,cAAc;AAWpB,MAAM,sBAAsB;AAyB5B,MAAM,OAAO;AAWb,MAAM,YAAY;AAWlB,MAAM,QAAQ;AAWd,MAAM,SAAS;AAWT,MAAA,UAAU,CACtB,UACoC;IACpC,OAAO,aAAa,OAAO,KAAK,CAAC,CAAC;AACnC;AASO,MAAM,SAAS;AAWT,MAAA,QAAQ,CACpB,UAC6D;IAC7D,OAAO,aAAa,KAAK,KAAK,CAAC,CAAC,MAAM,SAAA;AACvC;AASa,MAAA,WAAW,CACvB,UACqC;IAC9B,OAAA,aAAa,KAAK,KAAK,eAAe;AAC9C;AASO,MAAM,mBAAmB;AASzB,MAAM,oBAAoB;AAUpB,MAAA,aAAa,CACzBA,gBAC0C;IAC1C,OAAO,aAAaA,WAAU,KAAK,gBAAgBA,WAAU;AAC9D;AASa,MAAA,QAAQ,CAGpBC,WAC0C;IAC1C,OAAO,aAAaA,MAAK,KAAK,gBAAgBA,MAAK;AACpD;AASa,MAAA,YAAY,CACxB,WAC0C;IAC1C,OAAO,aAAa,MAAM,KAAK,gBAAgB,MAAM;AACtD","ignoreList":[0]}},
    {"offset": {"line": 3224, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3230, "column": 0}, "map": {"version":3,"file":"resolveMigrationDocumentData.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/resolveMigrationDocumentData.ts"],"sourcesContent":["import type { MigrationLinkToMediaField } from \"../types/migration/Asset\"\nimport {\n\ttype MigrationImage,\n\ttype MigrationLinkToMedia,\n\ttype MigrationRTImageNode,\n\tPrismicMigrationAsset,\n} from \"../types/migration/Asset\"\nimport type {\n\tMigrationContentRelationship,\n\tMigrationContentRelationshipField,\n} from \"../types/migration/ContentRelationship\"\nimport { PrismicMigrationDocument } from \"../types/migration/Document\"\nimport type { FilledImageFieldImage } from \"../types/value/image\"\nimport type { LinkField } from \"../types/value/link\"\nimport { LinkType } from \"../types/value/link\"\nimport type { RTImageNode } from \"../types/value/richText\"\nimport { RichTextNodeType } from \"../types/value/richText\"\n\nimport * as isFilled from \"../helpers/isFilled\"\nimport type { Migration } from \"../Migration\"\n\nimport * as isMigration from \"./isMigrationValue\"\n\n/**\n * Resolves a migration content relationship to a content relationship field.\n *\n * @param relation - Content relationship to resolve.\n *\n * @returns Resolved content relationship field.\n */\nexport async function resolveMigrationContentRelationship(\n\trelation: MigrationContentRelationship,\n): Promise<MigrationContentRelationshipField> {\n\tif (typeof relation === \"function\") {\n\t\treturn resolveMigrationContentRelationship(await relation())\n\t}\n\n\tif (relation instanceof PrismicMigrationDocument) {\n\t\treturn relation.document.id\n\t\t\t? { link_type: LinkType.Document, id: relation.document.id }\n\t\t\t: { link_type: LinkType.Document }\n\t}\n\n\tif (relation) {\n\t\tif (\n\t\t\tisMigration.contentRelationship(relation.id) ||\n\t\t\ttypeof relation.id === \"function\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\t...(await resolveMigrationContentRelationship(relation.id)),\n\t\t\t\t// TODO: Remove when link text PR is merged\n\t\t\t\t// @ts-expect-error - Future-proofing for link text\n\t\t\t\ttext: relation.text,\n\t\t\t}\n\t\t}\n\n\t\treturn { link_type: LinkType.Document, id: relation.id }\n\t}\n\n\treturn { link_type: LinkType.Document }\n}\n\n/**\n * Resolves a migration image to an image field.\n *\n * @param migrationAsset - Asset to resolve.\n * @param migration - Migration instance.\n * @param withThumbnails - Whether to include thumbnails.\n *\n * @returns Resolved image field.\n */\nexport const resolveMigrationImage = (\n\timage: MigrationImage,\n\tmigration: Migration,\n\twithThumbnails?: boolean,\n): FilledImageFieldImage | undefined => {\n\tconst { id: master, ...thumbnails } =\n\t\timage instanceof PrismicMigrationAsset ? { id: image } : image\n\n\tconst asset = migration._assets.get(master.config.id)?.asset\n\tconst maybeInitialField = master.originalField\n\n\tif (asset) {\n\t\tconst parameters = (maybeInitialField?.url || asset.url).split(\"?\")[1]\n\t\tconst url = `${asset.url.split(\"?\")[0]}${parameters ? `?${parameters}` : \"\"}`\n\t\tconst dimensions: FilledImageFieldImage[\"dimensions\"] = {\n\t\t\twidth: asset.width!,\n\t\t\theight: asset.height!,\n\t\t}\n\t\tconst edit: FilledImageFieldImage[\"edit\"] =\n\t\t\tmaybeInitialField && \"edit\" in maybeInitialField\n\t\t\t\t? maybeInitialField?.edit\n\t\t\t\t: { x: 0, y: 0, zoom: 1, background: \"transparent\" }\n\n\t\t// We give priority to the asset's specific alt text, then the image's general alt text\n\t\tconst alt = master.config.alt || asset.alt || null\n\n\t\tconst resolvedThumbnails: Record<string, FilledImageFieldImage> = {}\n\t\tif (withThumbnails) {\n\t\t\tfor (const [name, thumbnail] of Object.entries(thumbnails)) {\n\t\t\t\tconst resolvedThumbnail = resolveMigrationImage(thumbnail, migration)\n\t\t\t\tif (resolvedThumbnail) {\n\t\t\t\t\tresolvedThumbnails[name] = resolvedThumbnail\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: asset.id,\n\t\t\turl,\n\t\t\tdimensions,\n\t\t\tedit,\n\t\t\talt: alt,\n\t\t\tcopyright: asset.credits || null,\n\t\t\t...resolvedThumbnails,\n\t\t}\n\t}\n}\n\n/**\n * Resolves a migration rich text image node to a regular rich text image node.\n *\n * @param rtImageNode - Migration rich text image node to resolve.\n * @param migration - Migration instance.\n *\n * @returns Resolved rich text image node.\n */\nexport const resolveMigrationRTImageNode = async (\n\trtImageNode: MigrationRTImageNode,\n\tmigration: Migration,\n): Promise<RTImageNode | undefined> => {\n\tconst image = resolveMigrationImage(rtImageNode.id, migration)\n\n\tif (image) {\n\t\tconst linkTo = (await resolveMigrationDocumentData(\n\t\t\trtImageNode.linkTo,\n\t\t\tmigration,\n\t\t)) as LinkField\n\n\t\treturn {\n\t\t\t...image,\n\t\t\ttype: RichTextNodeType.image,\n\t\t\tlinkTo: isFilled.link(linkTo) ? linkTo : undefined,\n\t\t}\n\t}\n}\n\n/**\n * Resolves a migration link to media to a regular link to media field.\n *\n * @param linkToMedia - Migration link to media to resolve.\n * @param migration - Migration instance.\n *\n * @returns Resolved link to media field.\n */\nexport const resolveMigrationLinkToMedia = (\n\tlinkToMedia: MigrationLinkToMedia,\n\tmigration: Migration,\n): MigrationLinkToMediaField => {\n\tconst asset = migration._assets.get(linkToMedia.id.config.id)?.asset\n\n\tif (asset) {\n\t\treturn {\n\t\t\tid: asset.id,\n\t\t\tlink_type: LinkType.Media,\n\t\t\ttext: linkToMedia.text,\n\t\t}\n\t}\n\n\treturn { link_type: LinkType.Media }\n}\n\n/**\n * Resolves a migration document data to actual data ready to be sent to the\n * Migration API.\n *\n * @param input - Migration link to media to resolve.\n * @param migration - Migration instance.\n *\n * @returns Resolved data.\n */\nexport async function resolveMigrationDocumentData(\n\tinput: unknown,\n\tmigration: Migration,\n): Promise<unknown> {\n\t// Migration fields\n\tif (isMigration.contentRelationship(input)) {\n\t\treturn resolveMigrationContentRelationship(input)\n\t}\n\n\tif (isMigration.image(input)) {\n\t\treturn resolveMigrationImage(input, migration, true)\n\t}\n\n\tif (isMigration.linkToMedia(input)) {\n\t\treturn resolveMigrationLinkToMedia(input, migration)\n\t}\n\n\tif (isMigration.rtImageNode(input)) {\n\t\treturn resolveMigrationRTImageNode(input, migration)\n\t}\n\n\tif (typeof input === \"function\") {\n\t\treturn await resolveMigrationDocumentData(await input(), migration)\n\t}\n\n\t// Object traversing\n\tif (Array.isArray(input)) {\n\t\tconst res = []\n\n\t\tfor (const element of input) {\n\t\t\tres.push(await resolveMigrationDocumentData(element, migration))\n\t\t}\n\n\t\treturn res.filter(Boolean)\n\t}\n\n\tif (input && typeof input === \"object\") {\n\t\tconst res: Record<PropertyKey, unknown> = {}\n\n\t\tfor (const key in input) {\n\t\t\tres[key] = await resolveMigrationDocumentData(\n\t\t\t\tinput[key as keyof typeof input],\n\t\t\t\tmigration,\n\t\t\t)\n\t\t}\n\n\t\treturn res\n\t}\n\n\t// Primitives\n\treturn input\n}\n"],"names":["isMigration.contentRelationship","image","rtImageNode","isFilled.link","linkToMedia","isMigration.image","isMigration.linkToMedia","isMigration.rtImageNode"],"mappings":";;;;;;;;;;;;;;;;;;;AA8BA,eAAsB,oCACrB,QAAA,EAAsC;IAElC,IAAA,OAAO,aAAa,YAAY;QAC5B,OAAA,oCAAoC,MAAM,SAAA,CAAU;IAC5D;IAEA,IAAI,oMAAoB,2BAAA,EAA0B;QACjD,OAAO,SAAS,QAAA,CAAS,EAAA,GACtB;YAAE,mLAAW,WAAA,CAAS,QAAA;YAAU,IAAI,SAAS,QAAA,CAAS,EAAA;QAAI,IAC1D;YAAE,mLAAW,WAAA,CAAS,QAAA;QAAA;IAC1B;IAEA,IAAI,UAAU;QAEZ,iLAAAA,sBAAAA,EAAgC,SAAS,EAAE,KAC3C,OAAO,SAAS,EAAA,KAAO,YACtB;YACM,OAAA;gBACN,GAAI,MAAM,oCAAoC,SAAS,EAAE,CAAA;gBAAA,2CAAA;gBAAA,mDAAA;gBAGzD,MAAM,SAAS,IAAA;YAAA;QAEjB;QAEA,OAAO;YAAE,WAAW,mLAAA,CAAS,QAAA;YAAU,IAAI,SAAS,EAAA;QAAA;IACrD;IAEO,OAAA;QAAE,mLAAW,WAAA,CAAS,QAAA;IAAA;AAC9B;AAWO,MAAM,wBAAwB,CACpCC,QACA,WACA,mBACsC;;IAChC,MAAA,EAAE,IAAI,MAAA,EAAQ,GAAG,WACtB,CAAA,GAAAA,+LAAiB,wBAAA,GAAwB;QAAE,IAAIA;IAAA,IAAUA;IAE1D,MAAM,QAAA,CAAQ,KAAA,UAAU,OAAA,CAAQ,GAAA,CAAI,OAAO,MAAA,CAAO,EAAE,CAAA,KAAtC,OAAA,KAAA,IAAA,GAAyC,KAAA;IACvD,MAAM,oBAAoB,OAAO,aAAA;IAEjC,IAAI,OAAO;QACJ,MAAA,aAAA,CAAA,CAAc,qBAAA,OAAA,KAAA,IAAA,kBAAmB,GAAA,KAAO,MAAM,GAAA,EAAK,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA;QACrE,MAAM,MAAM,GAAG,MAAM,GAAA,CAAI,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAC,GAAG,aAAa,CAAA,CAAA,EAAI,UAAU,EAAA,GAAK,EAAE,EAAA;QAC3E,MAAM,aAAkD;YACvD,OAAO,MAAM,KAAA;YACb,QAAQ,MAAM,MAAA;QAAA;QAEf,MAAM,OACL,qBAAqB,UAAU,oBAC5B,qBAAA,OAAA,KAAA,IAAA,kBAAmB,IAAA,GACnB;YAAE,GAAG;YAAG,GAAG;YAAG,MAAM;YAAG,YAAY;QAAA;QAGvC,MAAM,MAAM,OAAO,MAAA,CAAO,GAAA,IAAO,MAAM,GAAA,IAAO;QAE9C,MAAM,qBAA4D,CAAA;QAClE,IAAI,gBAAgB;YACnB,KAAA,MAAW,CAAC,MAAM,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,UAAU,EAAG;gBACrD,MAAA,oBAAoB,sBAAsB,WAAW,SAAS;gBACpE,IAAI,mBAAmB;oBACtB,kBAAA,CAAmB,IAAI,CAAA,GAAI;gBAC5B;YACD;QACD;QAEO,OAAA;YACN,IAAI,MAAM,EAAA;YACV;YACA;YACA;YACA;YACA,WAAW,MAAM,OAAA,IAAW;YAC5B,GAAG,kBAAA;QAAA;IAEL;AACD;AAUa,MAAA,8BAA8B,OAC1CC,cACA,cACqC;IACrC,MAAMD,SAAQ,sBAAsBC,aAAY,EAAA,EAAI,SAAS;IAE7D,IAAID,QAAO;QACV,MAAM,SAAU,MAAM,6BACrBC,aAAY,MAAA,EACZ,SAAS;QAGH,OAAA;YACN,GAAGD,MAAAA;YACH,MAAM,+LAAA,CAAiB,KAAA;YACvB,iLAAQE,OAAAA,EAAc,MAAM,IAAI,SAAS,KAAA;QAAA;IAE3C;AACD;AAUa,MAAA,8BAA8B,CAC1CC,cACA,cAC8B;;IACxB,MAAA,QAAA,CAAQ,KAAA,UAAU,OAAA,CAAQ,GAAA,CAAIA,aAAY,EAAA,CAAG,MAAA,CAAO,EAAE,CAAA,KAA9C,OAAA,KAAA,IAAA,GAAiD,KAAA;IAE/D,IAAI,OAAO;QACH,OAAA;YACN,IAAI,MAAM,EAAA;YACV,mLAAW,WAAA,CAAS,KAAA;YACpB,MAAMA,aAAY,IAAA;QAAA;IAEpB;IAEO,OAAA;QAAE,mLAAW,WAAA,CAAS,KAAA;IAAA;AAC9B;AAWsB,eAAA,6BACrB,KAAA,EACA,SAAA,EAAoB;IAGhB,iLAAAJ,sBAAAA,EAAgC,KAAK,GAAG;QAC3C,OAAO,oCAAoC,KAAK;IACjD;IAEI,iLAAAK,QAAAA,EAAkB,KAAK,GAAG;QACtB,OAAA,sBAAsB,OAAO,WAAW,IAAI;IACpD;IAEI,iLAAAC,cAAAA,EAAwB,KAAK,GAAG;QAC5B,OAAA,4BAA4B,OAAO,SAAS;IACpD;IAEI,iLAAAC,cAAAA,EAAwB,KAAK,GAAG;QAC5B,OAAA,4BAA4B,OAAO,SAAS;IACpD;IAEI,IAAA,OAAO,UAAU,YAAY;QAChC,OAAO,MAAM,6BAA6B,MAAM,SAAS,SAAS;IACnE;IAGI,IAAA,MAAM,OAAA,CAAQ,KAAK,GAAG;QACzB,MAAM,MAAM,CAAA,CAAA;QAEZ,KAAA,MAAW,WAAW,MAAO;YAC5B,IAAI,IAAA,CAAK,MAAM,6BAA6B,SAAS,SAAS,CAAC;QAChE;QAEO,OAAA,IAAI,MAAA,CAAO,OAAO;IAC1B;IAEI,IAAA,SAAS,OAAO,UAAU,UAAU;QACvC,MAAM,MAAoC,CAAA;QAE1C,IAAA,MAAW,OAAO,MAAO;YACxB,GAAA,CAAI,GAAG,CAAA,GAAI,MAAM,6BAChB,KAAA,CAAM,GAAyB,CAAA,EAC/B,SAAS;QAEX;QAEO,OAAA;IACR;IAGO,OAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 3379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3385, "column": 0}, "map": {"version":3,"file":"WriteClient.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/WriteClient.ts"],"sourcesContent":["import { devMsg } from \"./lib/devMsg\"\nimport { pLimit } from \"./lib/pLimit\"\nimport {\n\tresolveMigrationContentRelationship,\n\tresolveMigrationDocumentData,\n} from \"./lib/resolveMigrationDocumentData\"\n\nimport type {\n\tAsset,\n\tPatchAssetParams,\n\tPatchAssetResult,\n\tPostAssetParams,\n\tPostAssetResult,\n} from \"./types/api/asset/asset\"\nimport type {\n\tAssetTag,\n\tGetAssetTagsResult,\n\tPostAssetTagParams,\n\tPostAssetTagResult,\n} from \"./types/api/asset/tag\"\nimport type { PutDocumentResult } from \"./types/api/migration/document\"\nimport {\n\ttype PostDocumentParams,\n\ttype PostDocumentResult,\n\ttype PutDocumentParams,\n} from \"./types/api/migration/document\"\nimport type { PrismicMigrationAsset } from \"./types/migration/Asset\"\nimport type {\n\tMigrationDocument,\n\tPendingPrismicDocument,\n\tPrismicMigrationDocument,\n} from \"./types/migration/Document\"\nimport type { PrismicDocument } from \"./types/value/document\"\n\nimport { PrismicError } from \"./errors/PrismicError\"\n\nimport type { FetchParams, RequestInitLike } from \"./BaseClient\"\nimport { Client } from \"./Client\"\nimport type { ClientConfig } from \"./Client\"\nimport type { Migration } from \"./Migration\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { createMigration } from \"./createMigration\"\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends { type: string },\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * Utility type to construct events reported by the migration process.\n */\ntype MigrateReporterEvent<\n\tTType extends string,\n\tTData = never,\n> = TData extends never\n\t? { type: TType }\n\t: {\n\t\t\ttype: TType\n\t\t\tdata: TData\n\t\t}\n\n/**\n * A map of event types and their data reported by the migration process.\n */\ntype MigrateReporterEventMap = {\n\tstart: {\n\t\tpending: {\n\t\t\tdocuments: number\n\t\t\tassets: number\n\t\t}\n\t}\n\tend: {\n\t\tmigrated: {\n\t\t\tdocuments: number\n\t\t\tassets: number\n\t\t}\n\t}\n\t\"assets:creating\": {\n\t\tcurrent: number\n\t\tremaining: number\n\t\ttotal: number\n\t\tasset: PrismicMigrationAsset\n\t}\n\t\"assets:created\": {\n\t\tcreated: number\n\t}\n\t\"documents:masterLocale\": {\n\t\tmasterLocale: string\n\t}\n\t\"documents:creating\": {\n\t\tcurrent: number\n\t\tremaining: number\n\t\ttotal: number\n\t\tdocument: PrismicMigrationDocument\n\t}\n\t\"documents:created\": {\n\t\tcreated: number\n\t}\n\t\"documents:updating\": {\n\t\tcurrent: number\n\t\tremaining: number\n\t\ttotal: number\n\t\tdocument: PrismicMigrationDocument\n\t}\n\t\"documents:updated\": {\n\t\tupdated: number\n\t}\n}\n\n/**\n * Available event types reported by the migration process.\n */\ntype MigrateReporterEventTypes = keyof MigrateReporterEventMap\n\n/**\n * All events reported by the migration process. Events can be listened to by\n * providing a `reporter` function to the `migrate` method.\n */\nexport type MigrateReporterEvents = {\n\t[K in MigrateReporterEventTypes]: MigrateReporterEvent<\n\t\tK,\n\t\tMigrateReporterEventMap[K]\n\t>\n}[MigrateReporterEventTypes]\n\n/**\n * Additional parameters for creating an asset in the Prismic media library.\n */\nexport type CreateAssetParams = {\n\t/**\n\t * Asset notes.\n\t */\n\tnotes?: string\n\n\t/**\n\t * Asset credits.\n\t */\n\tcredits?: string\n\n\t/**\n\t * Asset alt text.\n\t */\n\talt?: string\n\n\t/**\n\t * Asset tags.\n\t */\n\ttags?: string[]\n}\n\n/**\n * Prismic Migration API demo keys.\n */\nconst MIGRATION_API_DEMO_KEYS = [\n\t\"cSaZlfkQlF9C6CEAM2Del6MNX9WonlV86HPbeEJL\",\n\t\"pZCexCajUQ4jriYwIGSxA1drZrFxDyFf1S0D1K0P\",\n\t\"Yc0mfrkGDw8gaaGKTrzwC3QUZDajv6k73DA99vWN\",\n\t\"ySzSEbVMAb5S1oSCQfbVG4mbh9Cb8wlF7BCvKI0L\",\n\t\"g2DA3EKWvx8uxVYcNFrmT5nJpon1Vi9V4XcOibJD\",\n\t\"CCNIlI0Vz41J66oFwsHUXaZa6NYFIY6z7aDF62Bc\",\n]\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type WriteClientConfig = {\n\t/**\n\t * A Prismic write token that allows writing content to the repository.\n\t */\n\twriteToken: string\n\n\t/**\n\t * A Prismic Migration API key that allows working with the Migration API.\n\t *\n\t * @remarks\n\t * If no key is provided, the client will use one of the demo key available\n\t * which has stricter rate limiting rules enforced.\n\t */\n\tmigrationAPIKey?: string\n\n\t/**\n\t * The Prismic Asset API endpoint.\n\t *\n\t * @defaultValue `\"https://asset-api.prismic.io/\"`\n\t *\n\t * @see Prismic Asset API technical reference: {@link https://prismic.io/docs/asset-api-technical-reference}\n\t */\n\tassetAPIEndpoint?: string\n\n\t/**\n\t * The Prismic Migration API endpoint.\n\t *\n\t * @defaultValue `\"https://migration.prismic.io/\"`\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tmigrationAPIEndpoint?: string\n} & ClientConfig\n\n/**\n * A client that allows querying and writing content to a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class WriteClient<\n\tTDocuments extends PrismicDocument = PrismicDocument,\n> extends Client<TDocuments> {\n\twriteToken: string\n\tmigrationAPIKey: string\n\n\tassetAPIEndpoint = \"https://asset-api.prismic.io/\"\n\tmigrationAPIEndpoint = \"https://migration.prismic.io/\"\n\n\t/**\n\t * Creates a Prismic client that can be used to query and write content to a\n\t * repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as in some Node.js versions, the `fetch` option must be provided as\n\t * part of the `options` parameter.\n\t *\n\t * @param repositoryName - The Prismic repository name for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from and written to the Prismic repository.\n\t *\n\t * @returns A client that can query and write content to the repository.\n\t */\n\tconstructor(repositoryName: string, options: WriteClientConfig) {\n\t\tsuper(repositoryName, options)\n\n\t\tif (typeof globalThis.window !== \"undefined\") {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] Prismic write client appears to be running in a browser environment. This is not recommended as it exposes your write token and Migration API key. Consider using Prismic write client in a server environment only, preferring the regular client for browser environement. For more details, see ${devMsg(\"avoid-write-client-in-browser\")}`,\n\t\t\t)\n\t\t}\n\n\t\tthis.writeToken = options.writeToken\n\t\tthis.migrationAPIKey =\n\t\t\toptions.migrationAPIKey ||\n\t\t\tMIGRATION_API_DEMO_KEYS[\n\t\t\t\tMath.floor(Math.random() * MIGRATION_API_DEMO_KEYS.length)\n\t\t\t]\n\n\t\tif (options.assetAPIEndpoint) {\n\t\t\tthis.assetAPIEndpoint = `${options.assetAPIEndpoint}/`\n\t\t}\n\n\t\tif (options.migrationAPIEndpoint) {\n\t\t\tthis.migrationAPIEndpoint = `${options.migrationAPIEndpoint}/`\n\t\t}\n\t}\n\n\t/**\n\t * Creates a migration release on the Prismic repository based on the provided\n\t * prepared migration.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tasync migrate(\n\t\tmigration: Migration<TDocuments>,\n\t\tparams: {\n\t\t\treporter?: (event: MigrateReporterEvents) => void\n\t\t} & FetchParams = {},\n\t): Promise<void> {\n\t\tparams.reporter?.({\n\t\t\ttype: \"start\",\n\t\t\tdata: {\n\t\t\t\tpending: {\n\t\t\t\t\tdocuments: migration._documents.length,\n\t\t\t\t\tassets: migration._assets.size,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tawait this.migrateCreateAssets(migration, params)\n\t\tawait this.migrateCreateDocuments(migration, params)\n\t\tawait this.migrateUpdateDocuments(migration, params)\n\n\t\tparams.reporter?.({\n\t\t\ttype: \"end\",\n\t\t\tdata: {\n\t\t\t\tmigrated: {\n\t\t\t\t\tdocuments: migration._documents.length,\n\t\t\t\t\tassets: migration._assets.size,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t}\n\n\t/**\n\t * Creates assets in the Prismic repository's media library.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @internal This method is one of the step performed by the {@link migrate} method.\n\t */\n\tprivate async migrateCreateAssets(\n\t\tmigration: Migration<TDocuments>,\n\t\t{\n\t\t\treporter,\n\t\t\t...fetchParams\n\t\t}: { reporter?: (event: MigrateReporterEvents) => void } & FetchParams = {},\n\t): Promise<void> {\n\t\tlet created = 0\n\t\tfor (const [_, migrationAsset] of migration._assets) {\n\t\t\treporter?.({\n\t\t\t\ttype: \"assets:creating\",\n\t\t\t\tdata: {\n\t\t\t\t\tcurrent: ++created,\n\t\t\t\t\tremaining: migration._assets.size - created,\n\t\t\t\t\ttotal: migration._assets.size,\n\t\t\t\t\tasset: migrationAsset,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tconst { file, filename, notes, credits, alt, tags } =\n\t\t\t\tmigrationAsset.config\n\n\t\t\tlet resolvedFile: PostAssetParams[\"file\"] | File\n\t\t\tif (typeof file === \"string\") {\n\t\t\t\tlet url: URL | undefined\n\t\t\t\ttry {\n\t\t\t\t\turl = new URL(file)\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// noop only on invalid URL, fetch errors will throw in the next if statement\n\t\t\t\t}\n\n\t\t\t\tif (url) {\n\t\t\t\t\t// File is a URL, fetch it\n\t\t\t\t\tresolvedFile = await this.fetchForeignAsset(\n\t\t\t\t\t\turl.toString(),\n\t\t\t\t\t\tfetchParams,\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\t// File is actual file content, use it as-is\n\t\t\t\t\tresolvedFile = file\n\t\t\t\t}\n\t\t\t} else if (file instanceof URL) {\n\t\t\t\t// File is a URL instance, fetch it\n\t\t\t\tresolvedFile = await this.fetchForeignAsset(\n\t\t\t\t\tfile.toString(),\n\t\t\t\t\tfetchParams,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tresolvedFile = file\n\t\t\t}\n\n\t\t\tconst asset = await this.createAsset(resolvedFile, filename, {\n\t\t\t\t...{ notes, credits, alt, tags },\n\t\t\t\t...fetchParams,\n\t\t\t})\n\n\t\t\tmigrationAsset.asset = asset\n\t\t}\n\n\t\treporter?.({\n\t\t\ttype: \"assets:created\",\n\t\t\tdata: {\n\t\t\t\tcreated,\n\t\t\t},\n\t\t})\n\t}\n\n\t/**\n\t * Creates documents in the Prismic repository's migration release.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @internal This method is one of the step performed by the {@link migrate} method.\n\t */\n\tprivate async migrateCreateDocuments(\n\t\tmigration: Migration<TDocuments>,\n\t\t{\n\t\t\treporter,\n\t\t\t...fetchParams\n\t\t}: { reporter?: (event: MigrateReporterEvents) => void } & FetchParams = {},\n\t): Promise<void> {\n\t\t// Resolve master locale\n\t\tconst repository = await this.getRepository(fetchParams)\n\t\tconst masterLocale = repository.languages.find((lang) => lang.is_master)!.id\n\t\treporter?.({\n\t\t\ttype: \"documents:masterLocale\",\n\t\t\tdata: {\n\t\t\t\tmasterLocale,\n\t\t\t},\n\t\t})\n\n\t\tconst documentsToCreate: PrismicMigrationDocument<TDocuments>[] = []\n\t\t// We create an array with non-master locale documents last because\n\t\t// we need their master locale document to be created first.\n\t\tfor (const doc of migration._documents) {\n\t\t\tif (!doc.document.id) {\n\t\t\t\tif (doc.document.lang === masterLocale) {\n\t\t\t\t\tdocumentsToCreate.unshift(doc)\n\t\t\t\t} else {\n\t\t\t\t\tdocumentsToCreate.push(doc)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet created = 0\n\t\tfor (const doc of documentsToCreate) {\n\t\t\treporter?.({\n\t\t\t\ttype: \"documents:creating\",\n\t\t\t\tdata: {\n\t\t\t\t\tcurrent: ++created,\n\t\t\t\t\tremaining: documentsToCreate.length - created,\n\t\t\t\t\ttotal: documentsToCreate.length,\n\t\t\t\t\tdocument: doc,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\t// Resolve master language document ID for non-master locale documents\n\t\t\tlet masterLanguageDocumentID: string | undefined\n\t\t\tif (doc.masterLanguageDocument) {\n\t\t\t\tconst masterLanguageDocument =\n\t\t\t\t\tawait resolveMigrationContentRelationship(doc.masterLanguageDocument)\n\n\t\t\t\tmasterLanguageDocumentID =\n\t\t\t\t\t\"id\" in masterLanguageDocument ? masterLanguageDocument.id : undefined\n\t\t\t} else if (doc.originalPrismicDocument) {\n\t\t\t\tconst maybeOriginalID =\n\t\t\t\t\tdoc.originalPrismicDocument.alternate_languages.find(\n\t\t\t\t\t\t({ lang }) => lang === masterLocale,\n\t\t\t\t\t)?.id\n\n\t\t\t\tif (maybeOriginalID) {\n\t\t\t\t\tmasterLanguageDocumentID =\n\t\t\t\t\t\tmigration._getByOriginalID(maybeOriginalID)?.document.id\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { id } = await this.createDocument(\n\t\t\t\t// We'll upload documents data later on.\n\t\t\t\t{ ...doc.document, data: {} },\n\t\t\t\tdoc.title!,\n\t\t\t\t{\n\t\t\t\t\tmasterLanguageDocumentID,\n\t\t\t\t\t...fetchParams,\n\t\t\t\t},\n\t\t\t)\n\n\t\t\tdoc.document.id = id\n\t\t}\n\n\t\treporter?.({\n\t\t\ttype: \"documents:created\",\n\t\t\tdata: { created },\n\t\t})\n\t}\n\n\t/**\n\t * Updates documents in the Prismic repository's migration release with their\n\t * patched data.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @internal This method is one of the step performed by the {@link migrate} method.\n\t */\n\tprivate async migrateUpdateDocuments(\n\t\tmigration: Migration<TDocuments>,\n\t\t{\n\t\t\treporter,\n\t\t\t...fetchParams\n\t\t}: { reporter?: (event: MigrateReporterEvents) => void } & FetchParams = {},\n\t): Promise<void> {\n\t\tlet i = 0\n\t\tfor (const doc of migration._documents) {\n\t\t\treporter?.({\n\t\t\t\ttype: \"documents:updating\",\n\t\t\t\tdata: {\n\t\t\t\t\tcurrent: ++i,\n\t\t\t\t\tremaining: migration._documents.length - i,\n\t\t\t\t\ttotal: migration._documents.length,\n\t\t\t\t\tdocument: doc,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tawait this.updateDocument(\n\t\t\t\tdoc.document.id!,\n\t\t\t\t// We need to forward again document name and tags to update them\n\t\t\t\t// in case the document already existed during the previous step.\n\t\t\t\t{\n\t\t\t\t\t...doc.document,\n\t\t\t\t\tdata: await resolveMigrationDocumentData(\n\t\t\t\t\t\tdoc.document.data,\n\t\t\t\t\t\tmigration,\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\tfetchParams,\n\t\t\t)\n\t\t}\n\n\t\treporter?.({\n\t\t\ttype: \"documents:updated\",\n\t\t\tdata: {\n\t\t\t\tupdated: migration._documents.length,\n\t\t\t},\n\t\t})\n\t}\n\n\t/**\n\t * Creates an asset in the Prismic media library.\n\t *\n\t * @param file - The file to upload as an asset.\n\t * @param filename - The filename of the asset.\n\t * @param params - Additional asset data and fetch parameters.\n\t *\n\t * @returns The created asset.\n\t */\n\tprivate async createAsset(\n\t\tfile: PostAssetParams[\"file\"] | File,\n\t\tfilename: string,\n\t\t{\n\t\t\tnotes,\n\t\t\tcredits,\n\t\t\talt,\n\t\t\ttags,\n\t\t\t...params\n\t\t}: CreateAssetParams & FetchParams = {},\n\t): Promise<Asset> {\n\t\tconst url = new URL(\"assets\", this.assetAPIEndpoint)\n\n\t\tconst formData = new FormData()\n\t\tformData.append(\n\t\t\t\"file\",\n\t\t\tnew File([file], filename, {\n\t\t\t\ttype: file instanceof File ? file.type : undefined,\n\t\t\t}),\n\t\t)\n\n\t\tif (notes) {\n\t\t\tformData.append(\"notes\", notes)\n\t\t}\n\n\t\tif (credits) {\n\t\t\tformData.append(\"credits\", credits)\n\t\t}\n\n\t\tif (alt) {\n\t\t\tformData.append(\"alt\", alt)\n\t\t}\n\n\t\tconst asset = await this.fetch<PostAssetResult>(\n\t\t\turl.toString(),\n\t\t\tthis.buildAssetAPIQueryParams({\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: formData,\n\t\t\t\tparams,\n\t\t\t}),\n\t\t)\n\n\t\tif (tags && tags.length) {\n\t\t\treturn this.updateAsset(asset.id, { tags })\n\t\t}\n\n\t\treturn asset\n\t}\n\n\t/**\n\t * Updates an asset in the Prismic media library.\n\t *\n\t * @param id - The ID of the asset to update.\n\t * @param params - The asset data to update and additional fetch parameters.\n\t *\n\t * @returns The updated asset.\n\t */\n\tprivate async updateAsset(\n\t\tid: string,\n\t\t{\n\t\t\tnotes,\n\t\t\tcredits,\n\t\t\talt,\n\t\t\tfilename,\n\t\t\ttags,\n\t\t\t...params\n\t\t}: PatchAssetParams & FetchParams = {},\n\t): Promise<Asset> {\n\t\tconst url = new URL(`assets/${id}`, this.assetAPIEndpoint)\n\n\t\t// Resolve tags if any and create missing ones\n\t\tif (tags && tags.length) {\n\t\t\ttags = await this.resolveAssetTagIDs(tags, {\n\t\t\t\tcreateTags: true,\n\t\t\t\t...params,\n\t\t\t})\n\t\t}\n\n\t\treturn this.fetch<PatchAssetResult>(\n\t\t\turl.toString(),\n\t\t\tthis.buildAssetAPIQueryParams<PatchAssetParams>({\n\t\t\t\tmethod: \"PATCH\",\n\t\t\t\tbody: {\n\t\t\t\t\tnotes,\n\t\t\t\t\tcredits,\n\t\t\t\t\talt,\n\t\t\t\t\tfilename,\n\t\t\t\t\ttags,\n\t\t\t\t},\n\t\t\t\tparams,\n\t\t\t}),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches a foreign asset from a URL.\n\t *\n\t * @param url - The URL of the asset to fetch.\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @returns A file representing the fetched asset.\n\t */\n\tprivate async fetchForeignAsset(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<Blob> {\n\t\tconst requestInit: RequestInitLike = {\n\t\t\t...this.fetchOptions,\n\t\t\t...params.fetchOptions,\n\t\t\theaders: {\n\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t...params.fetchOptions?.headers,\n\t\t\t},\n\t\t\tsignal:\n\t\t\t\tparams.fetchOptions?.signal ||\n\t\t\t\tparams.signal ||\n\t\t\t\tthis.fetchOptions?.signal,\n\t\t}\n\n\t\tconst res = await this.fetchFn(url, requestInit)\n\n\t\tif (!res.ok) {\n\t\t\tthrow new PrismicError(\"Could not fetch foreign asset\", url, undefined)\n\t\t}\n\n\t\tconst blob = await res.blob()\n\n\t\t// Ensure a correct content type is attached to the blob.\n\t\treturn new File([blob], \"\", {\n\t\t\ttype: res.headers.get(\"content-type\") || undefined,\n\t\t})\n\t}\n\n\t/**\n\t * {@link resolveAssetTagIDs} rate limiter.\n\t */\n\tprivate _resolveAssetTagIDsLimit = pLimit()\n\n\t/**\n\t * Resolves asset tag IDs from tag names.\n\t *\n\t * @param tagNames - An array of tag names to resolve.\n\t * @param params - Whether or not missing tags should be created and\n\t *   additional fetch parameters.\n\t *\n\t * @returns An array of resolved tag IDs.\n\t */\n\tprivate async resolveAssetTagIDs(\n\t\ttagNames: string[] = [],\n\t\t{ createTags, ...params }: { createTags?: boolean } & FetchParams = {},\n\t): Promise<string[]> {\n\t\treturn this._resolveAssetTagIDsLimit(async () => {\n\t\t\tconst existingTags = await this.getAssetTags(params)\n\t\t\tconst existingTagMap: Record<string, AssetTag> = {}\n\t\t\tfor (const tag of existingTags) {\n\t\t\t\texistingTagMap[tag.name] = tag\n\t\t\t}\n\n\t\t\tconst resolvedTagIDs = []\n\t\t\tfor (const tagName of tagNames) {\n\t\t\t\t// Tag does not exists yet, we create it if `createTags` is set\n\t\t\t\tif (!existingTagMap[tagName] && createTags) {\n\t\t\t\t\texistingTagMap[tagName] = await this.createAssetTag(tagName, params)\n\t\t\t\t}\n\n\t\t\t\t// Add tag if found\n\t\t\t\tif (existingTagMap[tagName]) {\n\t\t\t\t\tresolvedTagIDs.push(existingTagMap[tagName].id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resolvedTagIDs\n\t\t})\n\t}\n\n\t/**\n\t * Creates a tag in the Asset API.\n\t *\n\t * @remarks\n\t * Tags should be at least 3 characters long and 20 characters at most.\n\t *\n\t * @param name - The name of the tag to create.\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @returns The created tag.\n\t */\n\tprivate async createAssetTag(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<AssetTag> {\n\t\tconst url = new URL(\"tags\", this.assetAPIEndpoint)\n\n\t\treturn this.fetch<PostAssetTagResult>(\n\t\t\turl.toString(),\n\t\t\tthis.buildAssetAPIQueryParams<PostAssetTagParams>({\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: { name },\n\t\t\t\tparams,\n\t\t\t}),\n\t\t)\n\t}\n\n\t/**\n\t * Queries existing tags from the Asset API.\n\t *\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @returns An array of existing tags.\n\t */\n\tprivate async getAssetTags(params?: FetchParams): Promise<AssetTag[]> {\n\t\tconst url = new URL(\"tags\", this.assetAPIEndpoint)\n\n\t\tconst { items } = await this.fetch<GetAssetTagsResult>(\n\t\t\turl.toString(),\n\t\t\tthis.buildAssetAPIQueryParams({ params }),\n\t\t)\n\n\t\treturn items\n\t}\n\n\t/**\n\t * Creates a document in the repository's migration release.\n\t *\n\t * @typeParam TType - Type of Prismic documents to create.\n\t *\n\t * @param document - The document to create.\n\t * @param documentTitle - The title of the document to create which will be\n\t *   displayed in the editor.\n\t * @param params - Document master language document ID and additional fetch\n\t *   parameters.\n\t *\n\t * @returns The ID of the created document.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tprivate async createDocument<TType extends TDocuments[\"type\"]>(\n\t\tdocument: PendingPrismicDocument<ExtractDocumentType<TDocuments, TType>>,\n\t\tdocumentTitle: string,\n\t\t{\n\t\t\tmasterLanguageDocumentID,\n\t\t\t...params\n\t\t}: { masterLanguageDocumentID?: string } & FetchParams = {},\n\t): Promise<{ id: string }> {\n\t\tconst url = new URL(\"documents\", this.migrationAPIEndpoint)\n\n\t\tconst result = await this.fetch<PostDocumentResult>(\n\t\t\turl.toString(),\n\t\t\tthis.buildMigrationAPIQueryParams<PostDocumentParams>({\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: {\n\t\t\t\t\ttitle: documentTitle,\n\t\t\t\t\ttype: document.type,\n\t\t\t\t\tuid: document.uid || undefined,\n\t\t\t\t\tlang: document.lang,\n\t\t\t\t\talternate_language_id: masterLanguageDocumentID,\n\t\t\t\t\ttags: document.tags,\n\t\t\t\t\tdata: document.data,\n\t\t\t\t},\n\t\t\t\tparams,\n\t\t\t}),\n\t\t)\n\n\t\treturn { id: result.id }\n\t}\n\n\t/**\n\t * Updates an existing document in the repository's migration release.\n\t *\n\t * @typeParam TType - Type of Prismic documents to update.\n\t *\n\t * @param id - The ID of the document to update.\n\t * @param document - The document content to update.\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tprivate async updateDocument<TType extends TDocuments[\"type\"]>(\n\t\tid: string,\n\t\tdocument: MigrationDocument<ExtractDocumentType<TDocuments, TType>> & {\n\t\t\tdocumentTitle?: string\n\t\t},\n\t\tparams?: FetchParams,\n\t): Promise<void> {\n\t\tconst url = new URL(`documents/${id}`, this.migrationAPIEndpoint)\n\n\t\tawait this.fetch<PutDocumentResult>(\n\t\t\turl.toString(),\n\t\t\tthis.buildMigrationAPIQueryParams({\n\t\t\t\tmethod: \"PUT\",\n\t\t\t\tbody: {\n\t\t\t\t\ttitle: document.documentTitle,\n\t\t\t\t\tuid: document.uid || undefined,\n\t\t\t\t\ttags: document.tags,\n\t\t\t\t\tdata: document.data,\n\t\t\t\t},\n\t\t\t\tparams,\n\t\t\t}),\n\t\t)\n\t}\n\n\t/**\n\t * Builds fetch parameters for the Asset API.\n\t *\n\t * @typeParam TBody - Type of the body to send in the fetch request.\n\t *\n\t * @param params - Method, body, and additional fetch parameters.\n\t *\n\t * @returns An object that can be fetched to interact with the Asset API.\n\t *\n\t * @see Prismic Asset API technical reference: {@link https://prismic.io/docs/asset-api-technical-reference}\n\t */\n\tprivate buildAssetAPIQueryParams<TBody = FormData | Record<string, unknown>>({\n\t\tmethod,\n\t\tbody,\n\t\tparams,\n\t}: {\n\t\tmethod?: string\n\t\tbody?: TBody\n\t\tparams?: FetchParams\n\t}): FetchParams {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...params?.fetchOptions?.headers,\n\t\t\tauthorization: `Bearer ${this.writeToken}`,\n\t\t\trepository: this.repositoryName,\n\t\t}\n\n\t\tlet _body: FormData | string | undefined\n\t\tif (body instanceof FormData) {\n\t\t\t_body = body\n\t\t} else if (body) {\n\t\t\t_body = JSON.stringify(body)\n\t\t\theaders[\"content-type\"] = \"application/json\"\n\t\t}\n\n\t\treturn {\n\t\t\t...params,\n\t\t\tfetchOptions: {\n\t\t\t\t...params?.fetchOptions,\n\t\t\t\tmethod,\n\t\t\t\tbody: _body,\n\t\t\t\theaders,\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * Builds fetch parameters for the Migration API.\n\t *\n\t * @typeParam TBody - Type of the body to send in the fetch request.\n\t *\n\t * @param params - Method, body, and additional fetch options.\n\t *\n\t * @returns An object that can be fetched to interact with the Migration API.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tprivate buildMigrationAPIQueryParams<\n\t\tTBody extends PostDocumentParams | PutDocumentParams,\n\t>({\n\t\tmethod,\n\t\tbody,\n\t\tparams,\n\t}: {\n\t\tmethod?: string\n\t\tbody: TBody\n\t\tparams?: FetchParams\n\t}): FetchParams {\n\t\treturn {\n\t\t\t...params,\n\t\t\tfetchOptions: {\n\t\t\t\t...params?.fetchOptions,\n\t\t\t\tmethod,\n\t\t\t\tbody: JSON.stringify(body),\n\t\t\t\theaders: {\n\t\t\t\t\t...params?.fetchOptions?.headers,\n\t\t\t\t\t\"content-type\": \"application/json\",\n\t\t\t\t\trepository: this.repositoryName,\n\t\t\t\t\tauthorization: `Bearer ${this.writeToken}`,\n\t\t\t\t\t\"x-api-key\": this.migrationAPIKey,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAoKA,MAAM,0BAA0B;IAC/B;IACA;IACA;IACA;IACA;IACA;;AAkDK,MAAO,oBAEH,iKAAA,CAAkB;IAAA;;;;;;;;;;;;;GAAA,GAqB3B,YAAY,cAAA,EAAwB,OAAA,CAA0B;QAC7D,KAAA,CAAM,gBAAgB,OAAO;QArB9B,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA,oBAAmB;QACnB,cAAA,IAAA,EAAA,wBAAuB;QAybf;;KAAA,GAAA,cAAA,IAAA,EAAA,4BAA2B,4KAAA,CAAM;QAtapC,IAAA,OAAO,WAAW,MAAA,KAAW,aAAa;YAC7C,QAAQ,IAAA,CACP,CAAA,uTAAA,qKAA0T,SAAA,EAAO,+BAA+B,CAAC,EAAE;QAErW;QAEA,IAAA,CAAK,UAAA,GAAa,QAAQ,UAAA;QACrB,IAAA,CAAA,eAAA,GACJ,QAAQ,eAAA,IACR,uBAAA,CACC,KAAK,KAAA,CAAM,KAAK,MAAA,CAAM,IAAK,wBAAwB,MAAM,CAAC,CAAA;QAG5D,IAAI,QAAQ,gBAAA,EAAkB;YACxB,IAAA,CAAA,gBAAA,GAAmB,GAAG,QAAQ,gBAAgB,CAAA,CAAA,CAAA;QACpD;QAEA,IAAI,QAAQ,oBAAA,EAAsB;YAC5B,IAAA,CAAA,oBAAA,GAAuB,GAAG,QAAQ,oBAAoB,CAAA,CAAA,CAAA;QAC5D;IACD;IAAA;;;;;;;;GAAA,GAWA,MAAM,QACL,SAAA,EACA,SAEkB,CAAA,CAAA,EAAE;;QAEpB,CAAA,KAAA,OAAO,QAAA,KAAP,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,QAAkB;YACjB,MAAM;YACN,MAAM;gBACL,SAAS;oBACR,WAAW,UAAU,UAAA,CAAW,MAAA;oBAChC,QAAQ,UAAU,OAAA,CAAQ,IAAA;gBAC1B;YACD;QAAA;QAGI,MAAA,IAAA,CAAK,mBAAA,CAAoB,WAAW,MAAM;QAC1C,MAAA,IAAA,CAAK,sBAAA,CAAuB,WAAW,MAAM;QAC7C,MAAA,IAAA,CAAK,sBAAA,CAAuB,WAAW,MAAM;QAEnD,CAAA,KAAA,OAAO,QAAA,KAAP,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,QAAkB;YACjB,MAAM;YACN,MAAM;gBACL,UAAU;oBACT,WAAW,UAAU,UAAA,CAAW,MAAA;oBAChC,QAAQ,UAAU,OAAA,CAAQ,IAAA;gBAC1B;YACD;QAAA;IAEH;IAAA;;;;;;;GAAA,GAUQ,MAAM,oBACb,SAAA,EACA,EACC,QAAA,EACA,GAAG,YACqE,CAAA,GAAA,CAAA,CAAA,EAAE;QAE3E,IAAI,UAAU;QACd,KAAA,MAAW,CAAC,GAAG,cAAc,CAAA,IAAK,UAAU,OAAA,CAAS;YACzC,YAAA,OAAA,KAAA,IAAA,SAAA;gBACV,MAAM;gBACN,MAAM;oBACL,SAAS,EAAE;oBACX,WAAW,UAAU,OAAA,CAAQ,IAAA,GAAO;oBACpC,OAAO,UAAU,OAAA,CAAQ,IAAA;oBACzB,OAAO;gBACP;YAAA;YAGI,MAAA,EAAE,IAAA,EAAM,QAAA,EAAU,KAAA,EAAO,OAAA,EAAS,GAAA,EAAK,IAAA,CAAA,CAAA,GAC5C,eAAe,MAAA;YAEZ,IAAA;YACA,IAAA,OAAO,SAAS,UAAU;gBACzB,IAAA;gBACA,IAAA;oBACG,MAAA,IAAI,IAAI,IAAI;gBAAA,EAAA,OACV,OAAO,CAEhB;gBAEA,IAAI,KAAK;oBAER,eAAe,MAAM,IAAA,CAAK,iBAAA,CACzB,IAAI,QAAA,CAAA,GACJ,WAAW;gBAAA,OAEN;oBAES,eAAA;gBAChB;YAAA,OAAA,IACU,gBAAgB,KAAK;gBAE/B,eAAe,MAAM,IAAA,CAAK,iBAAA,CACzB,KAAK,QAAA,CAAA,GACL,WAAW;YAAA,OAEN;gBACS,eAAA;YAChB;YAEA,MAAM,QAAQ,MAAM,IAAA,CAAK,WAAA,CAAY,cAAc,UAAU;gBAC5D,GAAG;oBAAE;oBAAO;oBAAS;oBAAK;gBAAM,CAAA;gBAChC,GAAG,WAAA;YAAA,CACH;YAED,eAAe,KAAA,GAAQ;QACxB;QAEW,YAAA,OAAA,KAAA,IAAA,SAAA;YACV,MAAM;YACN,MAAM;gBACL;YACA;QAAA;IAEH;IAAA;;;;;;;GAAA,GAUQ,MAAM,uBACb,SAAA,EACA,EACC,QAAA,EACA,GAAG,YACqE,CAAA,GAAA,CAAA,CAAA,EAAE;;QAG3E,MAAM,aAAa,MAAM,IAAA,CAAK,aAAA,CAAc,WAAW;QACjD,MAAA,eAAe,WAAW,SAAA,CAAU,IAAA,CAAK,CAAC,OAAS,KAAK,SAAS,EAAG,EAAA;QAC/D,YAAA,OAAA,KAAA,IAAA,SAAA;YACV,MAAM;YACN,MAAM;gBACL;YACA;QAAA;QAGF,MAAM,oBAA4D,CAAA,CAAA;QAGvD,KAAA,MAAA,OAAO,UAAU,UAAA,CAAY;YACnC,IAAA,CAAC,IAAI,QAAA,CAAS,EAAA,EAAI;gBACjB,IAAA,IAAI,QAAA,CAAS,IAAA,KAAS,cAAc;oBACvC,kBAAkB,OAAA,CAAQ,GAAG;gBAAA,OACvB;oBACN,kBAAkB,IAAA,CAAK,GAAG;gBAC3B;YACD;QACD;QAEA,IAAI,UAAU;QACd,KAAA,MAAW,OAAO,kBAAmB;YACzB,YAAA,OAAA,KAAA,IAAA,SAAA;gBACV,MAAM;gBACN,MAAM;oBACL,SAAS,EAAE;oBACX,WAAW,kBAAkB,MAAA,GAAS;oBACtC,OAAO,kBAAkB,MAAA;oBACzB,UAAU;gBACV;YAAA;YAIE,IAAA;YACJ,IAAI,IAAI,sBAAA,EAAwB;gBAC/B,MAAM,yBACL,8LAAM,uCAAA,EAAoC,IAAI,sBAAsB;gBAGpE,2BAAA,QAAQ,yBAAyB,uBAAuB,EAAA,GAAK,KAAA;YAAA,OAAA,IACpD,IAAI,uBAAA,EAAyB;gBACjC,MAAA,kBAAA,CACL,KAAA,IAAI,uBAAA,CAAwB,mBAAA,CAAoB,IAAA,CAC/C,CAAC,EAAE,IAAA,EAAA,GAAW,SAAS,YAAY,CAAA,KADpC,OAAA,KAAA,IAAA,GAEG,EAAA;gBAEJ,IAAI,iBAAiB;oBACpB,2BAAA,CACC,KAAA,UAAU,gBAAA,CAAiB,eAAe,CAAA,KAA1C,OAAA,KAAA,IAAA,GAA6C,QAAA,CAAS,EAAA;gBACxD;YACD;YAEA,MAAM,EAAE,EAAA,CAAA,CAAA,GAAO,MAAM,IAAA,CAAK,cAAA,CAAA,wCAAA;YAEzB;gBAAE,GAAG,IAAI,QAAA;gBAAU,MAAM,CAAA;YAAI,GAC7B,IAAI,KAAA,EACJ;gBACC;gBACA,GAAG,WAAA;YACH;YAGF,IAAI,QAAA,CAAS,EAAA,GAAK;QACnB;QAEW,YAAA,OAAA,KAAA,IAAA,SAAA;YACV,MAAM;YACN,MAAM;gBAAE;YAAS;QAAA;IAEnB;IAAA;;;;;;;;GAAA,GAWQ,MAAM,uBACb,SAAA,EACA,EACC,QAAA,EACA,GAAG,YACqE,CAAA,GAAA,CAAA,CAAA,EAAE;QAE3E,IAAI,IAAI;QACG,KAAA,MAAA,OAAO,UAAU,UAAA,CAAY;YAC5B,YAAA,OAAA,KAAA,IAAA,SAAA;gBACV,MAAM;gBACN,MAAM;oBACL,SAAS,EAAE;oBACX,WAAW,UAAU,UAAA,CAAW,MAAA,GAAS;oBACzC,OAAO,UAAU,UAAA,CAAW,MAAA;oBAC5B,UAAU;gBACV;YAAA;YAGF,MAAM,IAAA,CAAK,cAAA,CACV,IAAI,QAAA,CAAS,EAAA,EAAA,iEAAA;YAAA,iEAAA;YAGb;gBACC,GAAG,IAAI,QAAA;gBACP,MAAM,+LAAM,+BAAA,EACX,IAAI,QAAA,CAAS,IAAA,EACb,SAAS;YAAA,GAGX;QAEF;QAEW,YAAA,OAAA,KAAA,IAAA,SAAA;YACV,MAAM;YACN,MAAM;gBACL,SAAS,UAAU,UAAA,CAAW,MAAA;YAC9B;QAAA;IAEH;IAAA;;;;;;;;GAAA,GAWQ,MAAM,YACb,IAAA,EACA,QAAA,EACA,EACC,KAAA,EACA,OAAA,EACA,GAAA,EACA,IAAA,EACA,GAAG,QAAA,GACiC,CAAA,CAAA,EAAE;QAEvC,MAAM,MAAM,IAAI,IAAI,UAAU,IAAA,CAAK,gBAAgB;QAE7C,MAAA,WAAW,IAAI;QACrB,SAAS,MAAA,CACR,QACA,IAAI,KAAK;YAAC,IAAI;SAAA,EAAG,UAAU;YAC1B,MAAM,gBAAgB,OAAO,KAAK,IAAA,GAAO,KAAA;QACzC,CAAA,CAAC;QAGH,IAAI,OAAO;YACD,SAAA,MAAA,CAAO,SAAS,KAAK;QAC/B;QAEA,IAAI,SAAS;YACH,SAAA,MAAA,CAAO,WAAW,OAAO;QACnC;QAEA,IAAI,KAAK;YACC,SAAA,MAAA,CAAO,OAAO,GAAG;QAC3B;QAEM,MAAA,QAAQ,MAAM,IAAA,CAAK,KAAA,CACxB,IAAI,QAAA,CAAU,GACd,IAAA,CAAK,wBAAA,CAAyB;YAC7B,QAAQ;YACR,MAAM;YACN;QACA,CAAA,CAAC;QAGC,IAAA,QAAQ,KAAK,MAAA,EAAQ;YACxB,OAAO,IAAA,CAAK,WAAA,CAAY,MAAM,EAAA,EAAI;gBAAE;YAAA,CAAM;QAC3C;QAEO,OAAA;IACR;IAAA;;;;;;;GAAA,GAUQ,MAAM,YACb,EAAA,EACA,EACC,KAAA,EACA,OAAA,EACA,GAAA,EACA,QAAA,EACA,IAAA,EACA,GAAG,QAAA,GACgC,CAAA,CAAA,EAAE;QAEtC,MAAM,MAAM,IAAI,IAAI,CAAA,OAAA,EAAU,EAAE,EAAA,EAAI,IAAA,CAAK,gBAAgB;QAGrD,IAAA,QAAQ,KAAK,MAAA,EAAQ;YACjB,OAAA,MAAM,IAAA,CAAK,kBAAA,CAAmB,MAAM;gBAC1C,YAAY;gBACZ,GAAG,MAAA;YAAA,CACH;QACF;QAEA,OAAO,IAAA,CAAK,KAAA,CACX,IAAI,QAAA,CAAQ,GACZ,IAAA,CAAK,wBAAA,CAA2C;YAC/C,QAAQ;YACR,MAAM;gBACL;gBACA;gBACA;gBACA;gBACA;YACA;YACD;QACA,CAAA,CAAC;IAEJ;IAAA;;;;;;;GAAA,GAUQ,MAAM,kBACb,GAAA,EACA,SAAsB,CAAA,CAAA,EAAE;;QAExB,MAAM,cAA+B;YACpC,GAAG,IAAA,CAAK,YAAA;YACR,GAAG,OAAO,YAAA;YACV,SAAS;gBACR,GAAA,CAAG,KAAA,IAAA,CAAK,YAAA,KAAL,OAAA,KAAA,IAAA,GAAmB,OAAA;gBACtB,GAAA,CAAG,KAAA,OAAO,YAAA,KAAP,OAAA,KAAA,IAAA,GAAqB,OAAA;YACxB;YACD,QAAA,CAAA,CACC,KAAA,OAAO,YAAA,KAAP,OAAA,KAAA,IAAA,GAAqB,MAAA,KACrB,OAAO,MAAA,IAAA,CAAA,CACP,KAAA,IAAA,CAAK,YAAA,KAAL,OAAA,KAAA,IAAA,GAAmB,MAAA;QAAA;QAGrB,MAAM,MAAM,MAAM,IAAA,CAAK,OAAA,CAAQ,KAAK,WAAW;QAE3C,IAAA,CAAC,IAAI,EAAA,EAAI;YACZ,MAAM,4KAAI,eAAA,CAAa,iCAAiC,KAAK,KAAA,CAAS;QACvE;QAEM,MAAA,OAAO,MAAM,IAAI,IAAA;QAGvB,OAAO,IAAI,KAAK;YAAC,IAAI;SAAA,EAAG,IAAI;YAC3B,MAAM,IAAI,OAAA,CAAQ,GAAA,CAAI,cAAc,KAAK,KAAA;QAAA,CACzC;IACF;IAAA;;;;;;;;GAAA,GAgBQ,MAAM,mBACb,WAAqB,CAAE,CAAA,EACvB,EAAE,UAAA,EAAY,GAAG,OAAmD,CAAA,GAAA,CAAA,CAAA,EAAE;QAE/D,OAAA,IAAA,CAAK,wBAAA,CAAyB,YAAW;YAC/C,MAAM,eAAe,MAAM,IAAA,CAAK,YAAA,CAAa,MAAM;YACnD,MAAM,iBAA2C,CAAA;YACjD,KAAA,MAAW,OAAO,aAAc;gBAChB,cAAA,CAAA,IAAI,IAAI,CAAA,GAAI;YAC5B;YAEA,MAAM,iBAAiB,CAAA,CAAA;YACvB,KAAA,MAAW,WAAW,SAAU;gBAE/B,IAAI,CAAC,cAAA,CAAe,OAAO,CAAA,IAAK,YAAY;oBAC3C,cAAA,CAAe,OAAO,CAAA,GAAI,MAAM,IAAA,CAAK,cAAA,CAAe,SAAS,MAAM;gBACpE;gBAGI,IAAA,cAAA,CAAe,OAAO,CAAA,EAAG;oBAC5B,eAAe,IAAA,CAAK,cAAA,CAAe,OAAO,CAAA,CAAE,EAAE;gBAC/C;YACD;YAEO,OAAA;QAAA,CACP;IACF;IAAA;;;;;;;;;;GAAA,GAaQ,MAAM,eACb,IAAA,EACA,MAAA,EAAoB;QAEpB,MAAM,MAAM,IAAI,IAAI,QAAQ,IAAA,CAAK,gBAAgB;QAEjD,OAAO,IAAA,CAAK,KAAA,CACX,IAAI,QAAA,CAAQ,GACZ,IAAA,CAAK,wBAAA,CAA6C;YACjD,QAAQ;YACR,MAAM;gBAAE;YAAM;YACd;QACA,CAAA,CAAC;IAEJ;IAAA;;;;;;GAAA,GASQ,MAAM,aAAa,MAAA,EAAoB;QAC9C,MAAM,MAAM,IAAI,IAAI,QAAQ,IAAA,CAAK,gBAAgB;QAEjD,MAAM,EAAE,KAAA,CAAU,CAAA,GAAA,MAAM,IAAA,CAAK,KAAA,CAC5B,IAAI,QAAA,CAAU,GACd,IAAA,CAAK,wBAAA,CAAyB;YAAE;QAAA,CAAQ,CAAC;QAGnC,OAAA;IACR;IAAA;;;;;;;;;;;;;;GAAA,GAiBQ,MAAM,eACb,QAAA,EACA,aAAA,EACA,EACC,wBAAA,EACA,GAAG,OACqD,CAAA,GAAA,CAAA,CAAA,EAAE;QAE3D,MAAM,MAAM,IAAI,IAAI,aAAa,IAAA,CAAK,oBAAoB;QAEpD,MAAA,SAAS,MAAM,IAAA,CAAK,KAAA,CACzB,IAAI,QAAA,CAAU,GACd,IAAA,CAAK,4BAAA,CAAiD;YACrD,QAAQ;YACR,MAAM;gBACL,OAAO;gBACP,MAAM,SAAS,IAAA;gBACf,KAAK,SAAS,GAAA,IAAO,KAAA;gBACrB,MAAM,SAAS,IAAA;gBACf,uBAAuB;gBACvB,MAAM,SAAS,IAAA;gBACf,MAAM,SAAS,IAAA;YACf;YACD;QACA,CAAA,CAAC;QAGI,OAAA;YAAE,IAAI,OAAO,EAAA;QAAA;IACrB;IAAA;;;;;;;;;;GAAA,GAaQ,MAAM,eACb,EAAA,EACA,QAAA,EAGA,MAAA,EAAoB;QAEpB,MAAM,MAAM,IAAI,IAAI,CAAA,UAAA,EAAa,EAAE,EAAA,EAAI,IAAA,CAAK,oBAAoB;QAEhE,MAAM,IAAA,CAAK,KAAA,CACV,IAAI,QAAA,CAAQ,GACZ,IAAA,CAAK,4BAAA,CAA6B;YACjC,QAAQ;YACR,MAAM;gBACL,OAAO,SAAS,aAAA;gBAChB,KAAK,SAAS,GAAA,IAAO,KAAA;gBACrB,MAAM,SAAS,IAAA;gBACf,MAAM,SAAS,IAAA;YACf;YACD;QACA,CAAA,CAAC;IAEJ;IAAA;;;;;;;;;;GAAA,GAaQ,yBAAqE,EAC5E,MAAA,EACA,IAAA,EACA,MAAA,EAAA,EAKA;;QACA,MAAM,UAAkC;YACvC,GAAA,CAAG,KAAA,UAAA,OAAA,KAAA,IAAA,OAAQ,YAAA,KAAR,OAAA,KAAA,IAAA,GAAsB,OAAA;YACzB,eAAe,CAAA,OAAA,EAAU,IAAA,CAAK,UAAU,EAAA;YACxC,YAAY,IAAA,CAAK,cAAA;QAAA;QAGd,IAAA;QACJ,IAAI,gBAAgB,UAAU;YACrB,QAAA;QAAA,OAAA,IACE,MAAM;YACR,QAAA,KAAK,SAAA,CAAU,IAAI;YAC3B,OAAA,CAAQ,cAAc,CAAA,GAAI;QAC3B;QAEO,OAAA;YACN,GAAG,MAAA;YACH,cAAc;gBACb,GAAG,UAAA,OAAA,KAAA,IAAA,OAAQ,YAAA;gBACX;gBACA,MAAM;gBACN;YACA;QAAA;IAEH;IAAA;;;;;;;;;;GAAA,GAaQ,6BAEN,EACD,MAAA,EACA,IAAA,EACA,MAAA,EAAA,EAKA;;QACO,OAAA;YACN,GAAG,MAAA;YACH,cAAc;gBACb,GAAG,UAAA,OAAA,KAAA,IAAA,OAAQ,YAAA;gBACX;gBACA,MAAM,KAAK,SAAA,CAAU,IAAI;gBACzB,SAAS;oBACR,GAAA,CAAG,KAAA,UAAA,OAAA,KAAA,IAAA,OAAQ,YAAA,KAAR,OAAA,KAAA,IAAA,GAAsB,OAAA;oBACzB,gBAAgB;oBAChB,YAAY,IAAA,CAAK,cAAA;oBACjB,eAAe,CAAA,OAAA,EAAU,IAAA,CAAK,UAAU,EAAA;oBACxC,aAAa,IAAA,CAAK,eAAA;gBAClB;YACD;QAAA;IAEH;AACA","ignoreList":[0]}},
    {"offset": {"line": 3908, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3914, "column": 0}, "map": {"version":3,"file":"asDate.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asDate.ts"],"sourcesContent":["import type { DateField } from \"../types/value/date\"\nimport type { TimestampField } from \"../types/value/timestamp\"\n\n/**\n * The return type of `asDate()`.\n */\ntype AsDateReturnType<\n\tField extends DateField | TimestampField | null | undefined,\n> = Field extends DateField<\"filled\"> | TimestampField<\"filled\"> ? Date : null\n\n/**\n * Transforms a date or timestamp field into a JavaScript Date object\n *\n * @param dateOrTimestampField - A date or timestamp field from Prismic\n *\n * @returns A Date object, null if provided date is falsy\n *\n * @see Templating date field from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#date-and-timestamp}\n */\nexport const asDate = <\n\tField extends DateField | TimestampField | null | undefined,\n>(\n\tdateOrTimestampField: Field,\n): AsDateReturnType<Field> => {\n\tif (!dateOrTimestampField) {\n\t\treturn null as AsDateReturnType<Field>\n\t}\n\n\t// If field is a timestamp field...\n\tif (dateOrTimestampField.length === 24) {\n\t\t/**\n\t\t * Converts basic ISO 8601 to ECMAScript simplified ISO 8601 format for\n\t\t * browser compatibility issues\n\t\t *\n\t\t * From: YYYY-MM-DDTHH:mm:ssZ To: YYYY-MM-DDTHH:mm:ss.sssZ\n\t\t *\n\t\t * @see MDN documentation: {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date#timestamp_string}\n\t\t * @see ECMAScript 2020 language specification: {@link https://262.ecma-international.org/11.0/#sec-date-time-string-format}\n\t\t * @see Related forum issue: {@link https://community.prismic.io/t/prismics-date-api/2520}\n\t\t * @see Regex101 expression: {@link https://regex101.com/r/jxyETT/1}\n\t\t */\n\t\treturn new Date(\n\t\t\tdateOrTimestampField.replace(/(\\+|-)(\\d{2})(\\d{2})$/, \".000$1$2:$3\"),\n\t\t) as AsDateReturnType<Field>\n\t} else {\n\t\t// ...else field is a date field\n\t\treturn new Date(dateOrTimestampField) as AsDateReturnType<Field>\n\t}\n}\n"],"names":[],"mappings":";;;AAmBa,MAAA,SAAS,CAGrB,yBAC4B;IAC5B,IAAI,CAAC,sBAAsB;QACnB,OAAA;IACR;IAGI,IAAA,qBAAqB,MAAA,KAAW,IAAI;QAYvC,OAAO,IAAI,KACV,qBAAqB,OAAA,CAAQ,yBAAyB,aAAa,CAAC;IAAA,OAE/D;QAEC,OAAA,IAAI,KAAK,oBAAoB;IACrC;AACD","ignoreList":[0]}},
    {"offset": {"line": 3929, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3935, "column": 0}, "map": {"version":3,"file":"escapeHTML.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/escapeHTML.ts"],"sourcesContent":["/*\n ** Core logic from https://github.com/component/escape-html\n ** Many thanks to @component\n */\n\nconst matchHtmlRegExp = /[\"'&<>]/\n\nexport const escapeHTML = (string?: string | null): string => {\n\tconst str = \"\" + string\n\tconst match = matchHtmlRegExp.exec(str)\n\n\tif (!match) {\n\t\treturn str\n\t}\n\n\tlet escape\n\tlet html = \"\"\n\tlet index = 0\n\tlet lastIndex = 0\n\n\tfor (index = match.index; index < str.length; index++) {\n\t\tswitch (str.charCodeAt(index)) {\n\t\t\tcase 34: // \"\n\t\t\t\tescape = \"&quot;\"\n\t\t\t\tbreak\n\t\t\tcase 38: // &\n\t\t\t\tescape = \"&amp;\"\n\t\t\t\tbreak\n\t\t\tcase 39: // '\n\t\t\t\tescape = \"&#39;\"\n\t\t\t\tbreak\n\t\t\tcase 60: // <\n\t\t\t\tescape = \"&lt;\"\n\t\t\t\tbreak\n\t\t\tcase 62: // >\n\t\t\t\tescape = \"&gt;\"\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t}\n\n\t\tif (lastIndex !== index) {\n\t\t\thtml += str.substring(lastIndex, index)\n\t\t}\n\n\t\tlastIndex = index + 1\n\t\thtml += escape\n\t}\n\n\treturn lastIndex !== index ? html + str.substring(lastIndex, index) : html\n}\n"],"names":[],"mappings":";;;AAKA,MAAM,kBAAkB;AAEX,MAAA,aAAa,CAAC,WAAkC;IAC5D,MAAM,MAAM,KAAK;IACX,MAAA,QAAQ,gBAAgB,IAAA,CAAK,GAAG;IAEtC,IAAI,CAAC,OAAO;QACJ,OAAA;IACR;IAEI,IAAA;IACJ,IAAI,OAAO;IACX,IAAI,QAAQ;IACZ,IAAI,YAAY;IAEhB,IAAK,QAAQ,MAAM,KAAA,EAAO,QAAQ,IAAI,MAAA,EAAQ,QAAS;QAC9C,OAAA,IAAI,UAAA,CAAW,KAAK,GAAG;YAC9B,KAAK;gBACK,SAAA;gBACT;YACD,KAAK;gBACK,SAAA;gBACT;YACD,KAAK;gBACK,SAAA;gBACT;YACD,KAAK;gBACK,SAAA;gBACT;YACD,KAAK;gBACK,SAAA;gBACT;YACD;gBACC;QACF;QAEA,IAAI,cAAc,OAAO;YAChB,QAAA,IAAI,SAAA,CAAU,WAAW,KAAK;QACvC;QAEA,YAAY,QAAQ;QACZ,QAAA;IACT;IAEA,OAAO,cAAc,QAAQ,OAAO,IAAI,SAAA,CAAU,WAAW,KAAK,IAAI;AACvE","ignoreList":[0]}},
    {"offset": {"line": 3979, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3985, "column": 0}, "map": {"version":3,"file":"serializerHelpers.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/serializerHelpers.ts"],"sourcesContent":["import type { RichTextMapSerializer } from \"../richtext/types\"\nimport { LinkType } from \"../types/value/link\"\nimport type { RTAnyNode } from \"../types/value/richText\"\n\nimport type {\n\tHTMLRichTextMapSerializer,\n\tHTMLStrictRichTextMapSerializer,\n} from \"../helpers/asHTML\"\nimport type { LinkResolverFunction } from \"../helpers/asLink\"\nimport { asLink } from \"../helpers/asLink\"\n\nimport { escapeHTML } from \"./escapeHTML\"\n\ntype Attributes = Record<string, string | boolean | null | undefined>\nconst formatAttributes = (node: RTAnyNode, attributes: Attributes): string => {\n\tconst _attributes = { ...attributes }\n\n\t// Respect `ltr` and `rtl` direction\n\tif (\"direction\" in node && node.direction === \"rtl\") {\n\t\t_attributes.dir = node.direction\n\t}\n\n\t// Add label to attributes\n\tif (\"data\" in node && \"label\" in node.data && node.data.label) {\n\t\t_attributes.class = _attributes.class\n\t\t\t? `${_attributes.class} ${node.data.label}`\n\t\t\t: node.data.label\n\t}\n\n\tconst result = []\n\n\tfor (const key in _attributes) {\n\t\tconst value = _attributes[key]\n\n\t\tif (value) {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tresult.push(key)\n\t\t\t} else {\n\t\t\t\tresult.push(`${key}=\"${escapeHTML(value)}\"`)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add a space at the beginning if there's any result\n\tif (result.length) {\n\t\tresult.unshift(\"\")\n\t}\n\n\treturn result.join(\" \")\n}\n\nconst getGeneralAttributes = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[keyof HTMLRichTextMapSerializer],\n): Attributes => {\n\treturn serializerOrShorthand && typeof serializerOrShorthand !== \"function\"\n\t\t? serializerOrShorthand\n\t\t: {}\n}\n\nexport const serializeStandardTag = <\n\tBlockType extends keyof RichTextMapSerializer<string>,\n>(\n\ttag: string,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[BlockType],\n): NonNullable<HTMLStrictRichTextMapSerializer[BlockType]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn (({ node, children }) => {\n\t\treturn `<${tag}${formatAttributes(\n\t\t\tnode,\n\t\t\tgeneralAttributes,\n\t\t)}>${children}</${tag}>`\n\t}) as NonNullable<HTMLStrictRichTextMapSerializer[BlockType]>\n}\n\nexport const serializePreFormatted = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"preformatted\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"preformatted\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node }) => {\n\t\treturn `<pre${formatAttributes(node, generalAttributes)}>${escapeHTML(\n\t\t\tnode.text,\n\t\t)}</pre>`\n\t}\n}\n\nexport const serializeImage = (\n\tlinkResolver:\n\t\t| LinkResolverFunction<string | null | undefined>\n\t\t| undefined\n\t\t| null,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"image\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"image\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node }) => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t\tsrc: node.url,\n\t\t\talt: node.alt,\n\t\t\tcopyright: node.copyright,\n\t\t}\n\n\t\tlet imageTag = `<img${formatAttributes(node, attributes)} />`\n\n\t\t// If the image has a link, we wrap it with an anchor tag\n\t\tif (node.linkTo) {\n\t\t\timageTag = serializeHyperlink(linkResolver)({\n\t\t\t\ttype: \"hyperlink\",\n\t\t\t\tnode: {\n\t\t\t\t\ttype: \"hyperlink\",\n\t\t\t\t\tdata: node.linkTo,\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tend: 0,\n\t\t\t\t},\n\t\t\t\ttext: \"\",\n\t\t\t\tchildren: imageTag,\n\t\t\t\tkey: \"\",\n\t\t\t})!\n\t\t}\n\n\t\treturn `<p class=\"block-img\">${imageTag}</p>`\n\t}\n}\n\nexport const serializeEmbed = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"embed\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"embed\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node }) => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t\t[\"data-oembed\"]: node.oembed.embed_url,\n\t\t\t[\"data-oembed-type\"]: node.oembed.type,\n\t\t\t[\"data-oembed-provider\"]: node.oembed.provider_name,\n\t\t}\n\n\t\treturn `<div${formatAttributes(node, attributes)}>${node.oembed.html}</div>`\n\t}\n}\n\nexport const serializeHyperlink = (\n\tlinkResolver:\n\t\t| LinkResolverFunction<string | null | undefined>\n\t\t| undefined\n\t\t| null,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"hyperlink\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"hyperlink\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node, children }): string => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t}\n\n\t\tif (node.data.link_type === LinkType.Web) {\n\t\t\tattributes.href = node.data.url\n\t\t\tattributes.target = node.data.target\n\t\t\tattributes.rel = \"noopener noreferrer\"\n\t\t} else if (node.data.link_type === LinkType.Document) {\n\t\t\tattributes.href = asLink(node.data, { linkResolver })\n\t\t} else if (node.data.link_type === LinkType.Media) {\n\t\t\tattributes.href = node.data.url\n\t\t}\n\n\t\treturn `<a${formatAttributes(node, attributes)}>${children}</a>`\n\t}\n}\n\nexport const serializeSpan = (): NonNullable<\n\tHTMLStrictRichTextMapSerializer[\"span\"]\n> => {\n\treturn ({ text }): string => {\n\t\treturn text ? escapeHTML(text).replace(/\\n/g, \"<br />\") : \"\"\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4106, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4112, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/richtext/types.ts"],"sourcesContent":["import type {\n\tRTAnyNode,\n\tRTEmNode,\n\tRTEmbedNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n\tRichTextNodeTypes,\n} from \"../types/value/richText\"\nimport { RichTextNodeType } from \"../types/value/richText\"\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: RichTextNodeTypes,\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those\n * handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"]\n\tnode: Node\n\ttext: TextType\n\tchildren: ReturnType[]\n\tkey: string\n}) => ReturnType | null | undefined\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n *\n * @typeParam ReturnType - Return type of the map serializer\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>\n}\n\n// Tree\nexport interface Tree {\n\tkey: string\n\tchildren: TreeNode[]\n}\n\nexport interface TreeNode {\n\tkey: string\n\ttype: RichTextNodeTypes\n\ttext?: string\n\tnode: RTAnyNode\n\tchildren: TreeNode[]\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const\n"],"names":[],"mappings":";;;;;AAoJO,MAAM,2BAA2B;IACvC,6KAAC,mBAAA,CAAiB,QAAQ,CAAA,EAAG;IAC7B,6KAAC,mBAAA,CAAiB,SAAS,CAAA,EAAG;IAC9B,6KAAC,mBAAA,CAAiB,IAAI,CAAA,EAAG;IACzB,6KAAC,mBAAA,CAAiB,KAAK,CAAA,EAAG","ignoreList":[0]}},
    {"offset": {"line": 4125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4131, "column": 0}, "map": {"version":3,"file":"wrapMapSerializer.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/richtext/wrapMapSerializer.ts"],"sourcesContent":["import type { RichTextFunctionSerializer, RichTextMapSerializer } from \"./types\"\nimport { RichTextReversedNodeType } from \"./types\"\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of the map serializer\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t]\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t})\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;AAgBa,MAAA,oBAAoB,CAChC,kBACqD;IACrD,OAAO,CAAC,MAAM,MAAM,MAAM,UAAU,QAAO;QAC1C,MAAM,gBACL,aAAA,oKACE,2BAAA,CACA,IAA6C,CAAA,IACzC,IAA0D,CAAA;QAGjE,IAAI,eAAe;YAClB,OAAO,cAAc;gBAAA,0CAAA;gBAEpB;gBAAA,0CAAA;gBAEA;gBAAA,0CAAA;gBAEA;gBAAA,0CAAA;gBAEA;gBAAA,0CAAA;gBAEA;YAAA,CACA;QACF;IAAA;AAEF","ignoreList":[0]}},
    {"offset": {"line": 4157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4163, "column": 0}, "map": {"version":3,"file":"composeSerializers.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/richtext/composeSerializers.ts"],"sourcesContent":["import type { RichTextFunctionSerializer } from \"./types\"\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of serializers\n *\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i]\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args)\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAgBa,MAAA,qBAAqB,CAAA,GAC9B,gBAIkD;IACrD,OAAO,CAAA,GAAI,SAAQ;QAClB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,MAAA,EAAQ,IAAK;YACtC,MAAA,aAAa,WAAA,CAAY,CAAC,CAAA;YAEhC,IAAI,YAAY;gBACT,MAAA,MAAM,WAAW,GAAG,IAAI;gBAE9B,IAAI,OAAO,MAAM;oBACT,OAAA;gBACR;YACD;QACD;IAAA;AAEF","ignoreList":[0]}},
    {"offset": {"line": 4181, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4187, "column": 0}, "map": {"version":3,"file":"asTree.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/richtext/asTree.ts"],"sourcesContent":["import type {\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"../types/value/richText\"\nimport { RichTextNodeType } from \"../types/value/richText\"\nimport type { Tree, TreeNode } from \"./types\"\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString()\n}\nuuid.i = 0\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n *\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes)\n\n\tconst children: TreeNode[] = []\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]))\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t}\n}\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t}\n}\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t})\n}\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0)\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i]\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t]\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode)\n\t\t\t\tmutNodes.splice(i, 1)\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes\n}\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t)\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = []\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]))\n\t\t}\n\n\t\treturn createTreeNode(node, children)\n\t}\n\n\treturn createTreeNode(node)\n}\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)]\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0)\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end)\n\n\tconst children: TreeNode[] = []\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i]\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0\n\t\tconst spanStart = span.start - parentSpanStart\n\t\tconst spanEnd = span.end - parentSpanStart\n\t\tconst text = node.text.slice(spanStart, spanEnd)\n\n\t\tconst childSpans: RTInlineNode[] = []\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j]\n\n\t\t\tif (siblingSpan !== span) {\n\t\t\t\tif (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n\t\t\t\t\tchildSpans.push(siblingSpan)\n\t\t\t\t\tmutSpans.splice(j, 1)\n\t\t\t\t\tj--\n\t\t\t\t} else if (\n\t\t\t\t\tsiblingSpan.start < span.end &&\n\t\t\t\t\tsiblingSpan.end > span.start\n\t\t\t\t) {\n\t\t\t\t\tchildSpans.push({\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tend: span.end,\n\t\t\t\t\t})\n\t\t\t\t\tmutSpans[j] = {\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tstart: span.end,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)))\n\t\t}\n\n\t\tconst spanWithText = { ...span, text }\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t}\n\n\treturn children\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4323, "column": 0}, "map": {"version":3,"file":"serialize.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/richtext/serialize.ts"],"sourcesContent":["import type { RichTextField } from \"../types/value/richText\"\nimport type { RichTextFunctionSerializer, TreeNode } from \"./types\"\n\nimport { asTree } from \"./asTree\"\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of the serializer\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t)\n}\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = []\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i]\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t)\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode)\n\t\t}\n\t}\n\n\treturn serializedTreeNodes\n}\n"],"names":[],"mappings":";;;;;AAqBa,MAAA,YAAY,CACxB,eACA,eAC2B;IAC3B,OAAO,2LACN,SAAA,EAAO,aAAa,EAAE,QAAA,EACtB,UAAU;AAEZ;AAEA,MAAM,qBAAqB,CAC1B,OACA,eACQ;IACR,MAAM,sBAA2B,CAAA,CAAA;IAEjC,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,IAAK;QAChC,MAAA,WAAW,KAAA,CAAM,CAAC,CAAA;QACxB,MAAM,qBAAqB,WAC1B,SAAS,IAAA,EACT,SAAS,IAAA,EACT,SAAS,IAAA,EACT,mBAAmB,SAAS,QAAA,EAAU,UAAU,GAChD,SAAS,GAAG;QAGb,IAAI,sBAAsB,MAAM;YAC/B,oBAAoB,IAAA,CAAK,kBAAkB;QAC5C;IACD;IAEO,OAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 4344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4350, "column": 0}, "map": {"version":3,"file":"asHTML.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asHTML.ts"],"sourcesContent":["import {\n\tserializeEmbed,\n\tserializeHyperlink,\n\tserializeImage,\n\tserializePreFormatted,\n\tserializeSpan,\n\tserializeStandardTag,\n} from \"../lib/serializerHelpers\"\n\nimport type { RichTextField } from \"../types/value/richText\"\n\nimport type {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextMapSerializerFunction,\n} from \"../richtext\"\nimport { composeSerializers, serialize, wrapMapSerializer } from \"../richtext\"\n\nimport type { LinkResolverFunction } from \"./asLink\"\n\n/**\n * Serializes a node from a rich text or title field with a function to HTML.\n *\n * Unlike a typical `@prismicio/client/richtext` function serializer, this\n * serializer converts the `children` argument to a single string rather than an\n * array of strings.\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLRichTextFunctionSerializer = (\n\ttype: Parameters<RichTextFunctionSerializer<string>>[0],\n\tnode: Parameters<RichTextFunctionSerializer<string>>[1],\n\ttext: Parameters<RichTextFunctionSerializer<string>>[2],\n\tchildren: Parameters<RichTextFunctionSerializer<string>>[3][number],\n\tkey: Parameters<RichTextFunctionSerializer<string>>[4],\n) => string | null | undefined\n\n/**\n * Serializes a node from a rich text or title field with a map to HTML\n *\n * Unlike a typical `@prismicio/client/richtext` map serializer, this serializer\n * converts the `children` property to a single string rather than an array of\n * strings and accepts shorthand declarations.\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLRichTextMapSerializer = {\n\t[P in keyof RichTextMapSerializer<string>]: P extends RichTextMapSerializer<string>[\"span\"]\n\t\t? HTMLStrictRichTextMapSerializer[P]\n\t\t: HTMLStrictRichTextMapSerializer[P] | HTMLRichTextMapSerializerShorthand\n}\n\n/**\n * Serializes a node from a rich text or title field with a map to HTML\n *\n * Unlike a typical `@prismicio/client/richtext` map serializer, this serializer\n * converts the `children` property to a single string rather than an array of\n * strings but doesn't accept shorthand declarations.\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLStrictRichTextMapSerializer = {\n\t[P in keyof RichTextMapSerializer<string>]: (payload: {\n\t\ttype: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"type\"]\n\t\tnode: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"node\"]\n\t\ttext: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"text\"]\n\t\tchildren: Parameters<\n\t\t\tHTMLRichTextMapSerializerFunction<P>\n\t\t>[0][\"children\"][number]\n\t\tkey: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"key\"]\n\t}) => string | null | undefined\n}\n\n/**\n * A {@link RichTextMapSerializerFunction} type specifically for\n * {@link HTMLRichTextMapSerializer}.\n *\n * @typeParam BlockName - The serializer's rich text block type.\n */\ntype HTMLRichTextMapSerializerFunction<\n\tBlockType extends keyof RichTextMapSerializer<string>,\n> = RichTextMapSerializerFunction<\n\tstring,\n\tExtractNodeGeneric<RichTextMapSerializer<string>[BlockType]>,\n\tExtractTextTypeGeneric<RichTextMapSerializer<string>[BlockType]>\n>\n\n/**\n * Returns the `Node` generic from {@link RichTextMapSerializerFunction}.\n *\n * @typeParam T - The `RichTextMapSerializerFunction` containing the needed\n *   `Node` generic.\n */\ntype ExtractNodeGeneric<T> =\n\tT extends RichTextMapSerializerFunction<\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tany,\n\t\tinfer U,\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tany\n\t>\n\t\t? U\n\t\t: never\n\n/**\n * Returns the `TextType` generic from {@link RichTextMapSerializerFunction}.\n *\n * @typeParam T - The `RichTextMapSerializerFunction` containing the needed\n *   `TextType` generic.\n */\ntype ExtractTextTypeGeneric<T> =\n\tT extends RichTextMapSerializerFunction<\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tany,\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tany,\n\t\tinfer U\n\t>\n\t\t? U\n\t\t: never\n\n/**\n * A shorthand definition for {@link HTMLRichTextMapSerializer} element types.\n */\nexport type HTMLRichTextMapSerializerShorthand = {\n\t/**\n\t * Classes to apply to the element type.\n\t */\n\tclass?: string\n\n\t/**\n\t * Other attributes to apply to the element type.\n\t */\n\t[Attribute: string]: string | boolean | null | undefined\n}\n\n/**\n * Serializes a node from a rich text or title field with a map or a function to\n * HTML\n *\n * @see {@link HTMLRichTextMapSerializer} and {@link HTMLRichTextFunctionSerializer}\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n */\nexport type HTMLRichTextSerializer =\n\t| HTMLRichTextMapSerializer\n\t| HTMLRichTextFunctionSerializer\n\n/**\n * Creates a HTML rich text serializer with a given link resolver and provide\n * sensible and safe defaults for every node type\n *\n * @internal\n */\nconst createHTMLRichTextSerializer = (\n\tlinkResolver: LinkResolverFunction | undefined | null,\n\tserializer?: HTMLRichTextMapSerializer | null,\n): RichTextFunctionSerializer<string> => {\n\tconst useSerializerOrDefault = <\n\t\tBlockType extends keyof RichTextMapSerializer<string>,\n\t>(\n\t\tnodeSerializerOrShorthand: HTMLRichTextMapSerializer[BlockType],\n\t\tdefaultWithShorthand: NonNullable<\n\t\t\tHTMLStrictRichTextMapSerializer[BlockType]\n\t\t>,\n\t): NonNullable<HTMLStrictRichTextMapSerializer[BlockType]> => {\n\t\tif (typeof nodeSerializerOrShorthand === \"function\") {\n\t\t\treturn ((payload) => {\n\t\t\t\treturn (\n\t\t\t\t\t(\n\t\t\t\t\t\tnodeSerializerOrShorthand as HTMLStrictRichTextMapSerializer[BlockType]\n\t\t\t\t\t)?.(payload) || defaultWithShorthand(payload)\n\t\t\t\t)\n\t\t\t}) as NonNullable<HTMLStrictRichTextMapSerializer[BlockType]>\n\t\t}\n\n\t\treturn defaultWithShorthand\n\t}\n\n\tconst mapSerializer: Required<HTMLStrictRichTextMapSerializer> = {\n\t\theading1: useSerializerOrDefault<\"heading1\">(\n\t\t\tserializer?.heading1,\n\t\t\tserializeStandardTag<\"heading1\">(\"h1\", serializer?.heading1),\n\t\t),\n\t\theading2: useSerializerOrDefault<\"heading2\">(\n\t\t\tserializer?.heading2,\n\t\t\tserializeStandardTag<\"heading2\">(\"h2\", serializer?.heading2),\n\t\t),\n\t\theading3: useSerializerOrDefault<\"heading3\">(\n\t\t\tserializer?.heading3,\n\t\t\tserializeStandardTag<\"heading3\">(\"h3\", serializer?.heading3),\n\t\t),\n\t\theading4: useSerializerOrDefault<\"heading4\">(\n\t\t\tserializer?.heading4,\n\t\t\tserializeStandardTag<\"heading4\">(\"h4\", serializer?.heading4),\n\t\t),\n\t\theading5: useSerializerOrDefault<\"heading5\">(\n\t\t\tserializer?.heading5,\n\t\t\tserializeStandardTag<\"heading5\">(\"h5\", serializer?.heading5),\n\t\t),\n\t\theading6: useSerializerOrDefault<\"heading6\">(\n\t\t\tserializer?.heading6,\n\t\t\tserializeStandardTag<\"heading6\">(\"h6\", serializer?.heading6),\n\t\t),\n\t\tparagraph: useSerializerOrDefault<\"paragraph\">(\n\t\t\tserializer?.paragraph,\n\t\t\tserializeStandardTag<\"paragraph\">(\"p\", serializer?.paragraph),\n\t\t),\n\t\tpreformatted: useSerializerOrDefault<\"preformatted\">(\n\t\t\tserializer?.preformatted,\n\t\t\tserializePreFormatted(serializer?.preformatted),\n\t\t),\n\t\tstrong: useSerializerOrDefault<\"strong\">(\n\t\t\tserializer?.strong,\n\t\t\tserializeStandardTag<\"strong\">(\"strong\", serializer?.strong),\n\t\t),\n\t\tem: useSerializerOrDefault<\"em\">(\n\t\t\tserializer?.em,\n\t\t\tserializeStandardTag<\"em\">(\"em\", serializer?.em),\n\t\t),\n\t\tlistItem: useSerializerOrDefault<\"listItem\">(\n\t\t\tserializer?.listItem,\n\t\t\tserializeStandardTag<\"listItem\">(\"li\", serializer?.listItem),\n\t\t),\n\t\toListItem: useSerializerOrDefault<\"oListItem\">(\n\t\t\tserializer?.oListItem,\n\t\t\tserializeStandardTag<\"oListItem\">(\"li\", serializer?.oListItem),\n\t\t),\n\t\tlist: useSerializerOrDefault<\"list\">(\n\t\t\tserializer?.list,\n\t\t\tserializeStandardTag<\"list\">(\"ul\", serializer?.list),\n\t\t),\n\t\toList: useSerializerOrDefault<\"oList\">(\n\t\t\tserializer?.oList,\n\t\t\tserializeStandardTag<\"oList\">(\"ol\", serializer?.oList),\n\t\t),\n\t\timage: useSerializerOrDefault<\"image\">(\n\t\t\tserializer?.image,\n\t\t\tserializeImage(linkResolver, serializer?.image),\n\t\t),\n\t\tembed: useSerializerOrDefault<\"embed\">(\n\t\t\tserializer?.embed,\n\t\t\tserializeEmbed(serializer?.embed),\n\t\t),\n\t\thyperlink: useSerializerOrDefault<\"hyperlink\">(\n\t\t\tserializer?.hyperlink,\n\t\t\tserializeHyperlink(linkResolver, serializer?.hyperlink),\n\t\t),\n\t\tlabel: useSerializerOrDefault<\"label\">(\n\t\t\tserializer?.label,\n\t\t\tserializeStandardTag<\"label\">(\"span\", serializer?.label),\n\t\t),\n\t\tspan: useSerializerOrDefault<\"span\">(serializer?.span, serializeSpan()),\n\t}\n\n\treturn wrapMapSerializerWithStringChildren(mapSerializer)\n}\n\n/**\n * Wraps a map serializer into a regular function serializer. The given map\n * serializer should accept children as a string, not as an array of strings\n * like `@prismicio/client/richtext`'s `wrapMapSerializer`.\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nconst wrapMapSerializerWithStringChildren = (\n\tmapSerializer: HTMLStrictRichTextMapSerializer,\n): RichTextFunctionSerializer<string> => {\n\tconst modifiedMapSerializer = {} as RichTextMapSerializer<string>\n\n\tfor (const tag in mapSerializer) {\n\t\tconst tagSerializer = mapSerializer[tag as keyof typeof mapSerializer]\n\n\t\tif (tagSerializer) {\n\t\t\tmodifiedMapSerializer[tag as keyof typeof mapSerializer] = (payload) => {\n\t\t\t\treturn tagSerializer({\n\t\t\t\t\t...payload,\n\t\t\t\t\t// @ts-expect-error - merging blockSerializer types causes TS to bail to a never type\n\t\t\t\t\tchildren: payload.children.join(\"\"),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn wrapMapSerializer(modifiedMapSerializer)\n}\n\n/**\n * Configuration that determines the output of `asHTML()`.\n */\ntype AsHTMLConfig = {\n\t/**\n\t * An optional link resolver function to resolve links. Without it you're\n\t * expected to use the `routes` options from the API.\n\t */\n\tlinkResolver?: LinkResolverFunction | null\n\n\t/**\n\t * An optional rich text serializer, unhandled cases will fallback to the\n\t * default serializer\n\t */\n\tserializer?: HTMLRichTextSerializer | null\n}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsHTMLDeprecatedTupleConfig = [\n\tlinkResolver?: LinkResolverFunction | null,\n\tserializer?: HTMLRichTextSerializer | null,\n]\n\n/**\n * The return type of `asHTML()`.\n */\ntype AsHTMLReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asHTML: {\n\t/**\n\t * Serializes a rich text or title field to an HTML string.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param config - Configuration that determines the output of `asHTML()`\n\t *\n\t * @returns HTML equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsHTMLConfig,\n\t): AsHTMLReturnType<Field>\n\n\t/**\n\t * Serializes a rich text or title field to an HTML string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param linkResolver - An optional link resolver function to resolve links,\n\t *   without it you're expected to use the `routes` options from the API\n\t * @param serializer - An optional rich text serializer, unhandled cases will\n\t *   fallback to the default serializer\n\t *\n\t * @returns HTML equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsHTMLDeprecatedTupleConfig\n\t): AsHTMLReturnType<Field>\n} = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple: [config?: AsHTMLConfig] | AsHTMLDeprecatedTupleConfig\n): AsHTMLReturnType<Field> => {\n\tif (richTextField) {\n\t\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\t\tconst [configObjectOrLinkResolver, maybeSerializer] = configObjectOrTuple\n\t\tlet config: AsHTMLConfig\n\t\tif (\n\t\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\t\tconfigObjectOrLinkResolver == null\n\t\t) {\n\t\t\tconfig = {\n\t\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t\t\tserializer: maybeSerializer,\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = { ...configObjectOrLinkResolver }\n\t\t}\n\n\t\tlet serializer: RichTextFunctionSerializer<string>\n\t\tif (config.serializer) {\n\t\t\tif (typeof config.serializer === \"function\") {\n\t\t\t\tserializer = composeSerializers(\n\t\t\t\t\t(type, node, text, children, key) =>\n\t\t\t\t\t\t// TypeScript doesn't narrow the type correctly here since it is now in a callback function, so we have to cast it here.\n\t\t\t\t\t\t(config.serializer as HTMLRichTextFunctionSerializer)(\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\tchildren.join(\"\"),\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t),\n\t\t\t\t\tcreateHTMLRichTextSerializer(config.linkResolver),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tserializer = createHTMLRichTextSerializer(\n\t\t\t\t\tconfig.linkResolver,\n\t\t\t\t\tconfig.serializer,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tserializer = createHTMLRichTextSerializer(config.linkResolver)\n\t\t}\n\n\t\treturn serialize(richTextField, serializer).join(\n\t\t\t\"\",\n\t\t) as AsHTMLReturnType<Field>\n\t} else {\n\t\treturn null as AsHTMLReturnType<Field>\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAyJA,MAAM,+BAA+B,CACpC,cACA,eACuC;IACjC,MAAA,yBAAyB,CAG9B,2BACA,yBAG4D;QACxD,IAAA,OAAO,8BAA8B,YAAY;YACpD,OAAQ,CAAC,YAAW;gBACnB,OAAA,CAEE,6BAAA,OAAA,KAAA,IAAA,0BACG,QAAA,KAAY,qBAAqB,OAAO;YAAA;QAG/C;QAEO,OAAA;IAAA;IAGR,MAAM,gBAA2D;QAChE,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,gLACZ,uBAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,gLACZ,uBAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,gLACZ,uBAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,EACZ,qMAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,+KACZ,wBAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,GACZ,oMAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,WAAW,uBACV,cAAA,OAAA,KAAA,IAAA,WAAY,SAAA,gLACZ,uBAAA,EAAkC,KAAK,cAAA,OAAA,KAAA,IAAA,WAAY,SAAS,CAAC;QAE9D,cAAc,uBACb,cAAA,OAAA,KAAA,IAAA,WAAY,YAAA,gLACZ,wBAAA,EAAsB,cAAA,OAAA,KAAA,IAAA,WAAY,YAAY,CAAC;QAEhD,QAAQ,uBACP,cAAA,OAAA,KAAA,IAAA,WAAY,MAAA,gLACZ,uBAAA,EAA+B,UAAU,cAAA,OAAA,KAAA,IAAA,WAAY,MAAM,CAAC;QAE7D,IAAI,uBACH,cAAA,OAAA,KAAA,IAAA,WAAY,EAAA,gLACZ,uBAAA,EAA2B,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,EAAE,CAAC;QAEjD,UAAU,uBACT,cAAA,OAAA,KAAA,IAAA,WAAY,QAAA,gLACZ,uBAAA,EAAiC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,QAAQ,CAAC;QAE7D,WAAW,uBACV,cAAA,OAAA,KAAA,IAAA,WAAY,SAAA,gLACZ,uBAAA,EAAkC,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,SAAS,CAAC;QAE/D,MAAM,uBACL,cAAA,OAAA,KAAA,IAAA,WAAY,IAAA,gLACZ,uBAAA,EAA6B,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,IAAI,CAAC;QAErD,OAAO,uBACN,cAAA,OAAA,KAAA,IAAA,WAAY,KAAA,GACZ,oMAAA,EAA8B,MAAM,cAAA,OAAA,KAAA,IAAA,WAAY,KAAK,CAAC;QAEvD,OAAO,uBACN,cAAA,OAAA,KAAA,IAAA,WAAY,KAAA,gLACZ,iBAAA,EAAe,cAAc,cAAA,OAAA,KAAA,IAAA,WAAY,KAAK,CAAC;QAEhD,OAAO,uBACN,cAAA,OAAA,KAAA,IAAA,WAAY,KAAA,gLACZ,iBAAA,EAAe,cAAA,OAAA,KAAA,IAAA,WAAY,KAAK,CAAC;QAElC,WAAW,uBACV,cAAA,OAAA,KAAA,IAAA,WAAY,SAAA,gLACZ,qBAAA,EAAmB,cAAc,cAAA,OAAA,KAAA,IAAA,WAAY,SAAS,CAAC;QAExD,OAAO,uBACN,cAAA,OAAA,KAAA,IAAA,WAAY,KAAA,gLACZ,uBAAA,EAA8B,QAAQ,cAAA,OAAA,KAAA,IAAA,WAAY,KAAK,CAAC;QAEzD,MAAM,uBAA+B,cAAA,OAAA,KAAA,IAAA,WAAY,IAAA,gLAAM,gBAAA,EAAe;IAAA;IAGvE,OAAO,oCAAoC,aAAa;AACzD;AAWA,MAAM,sCAAsC,CAC3C,kBACuC;IACvC,MAAM,wBAAwB,CAAA;IAE9B,IAAA,MAAW,OAAO,cAAe;QAC1B,MAAA,gBAAgB,aAAA,CAAc,GAAiC,CAAA;QAErE,IAAI,eAAe;YACI,qBAAA,CAAA,GAAiC,CAAA,GAAI,CAAC,YAAW;gBACtE,OAAO,cAAc;oBACpB,GAAG,OAAA;oBAAA,qFAAA;oBAEH,UAAU,QAAQ,QAAA,CAAS,IAAA,CAAK,EAAE;gBAAA,CAClC;YAAA;QAEH;IACD;IAEA,OAAO,uMAAA,EAAkB,qBAAqB;AAC/C;AAmCa,MAAA,SAmCT,CACH,eAAA,GAEG,wBACyB;IAC5B,IAAI,eAAe;QAEZ,MAAA,CAAC,4BAA4B,eAAe,CAAA,GAAI;QAClD,IAAA;QACJ,IACC,OAAO,+BAA+B,cACtC,8BAA8B,MAC7B;YACQ,SAAA;gBACR,cAAc;gBACd,YAAY;YAAA;QAAA,OAEP;YACG,SAAA;gBAAE,GAAG,0BAAA;YAAA;QACf;QAEI,IAAA;QACJ,IAAI,OAAO,UAAA,EAAY;YAClB,IAAA,OAAO,OAAO,UAAA,KAAe,YAAY;gBAC5C,iMAAa,qBAAA,EACZ,CAAC,MAAM,MAAM,MAAM,UAAU,MAAA,wHAAA;oBAE3B,OAAO,UAAA,CACP,MACA,MACA,MACA,SAAS,IAAA,CAAK,EAAE,GAChB,GAAG,GAEL,6BAA6B,OAAO,YAAY,CAAC;YAAA,OAE5C;gBACN,aAAa,6BACZ,OAAO,YAAA,EACP,OAAO,UAAU;YAEnB;QAAA,OACM;YACO,aAAA,6BAA6B,OAAO,YAAY;QAC9D;QAEA,kLAAO,YAAA,EAAU,eAAe,UAAU,EAAE,IAAA,CAC3C,EAAE;IAAA,OAEG;QACC,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 4441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4447, "column": 0}, "map": {"version":3,"file":"asImagePixelDensitySrcSet.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asImagePixelDensitySrcSet.ts"],"sourcesContent":["import type { BuildPixelDensitySrcSetParams } from \"imgix-url-builder\"\nimport { buildPixelDensitySrcSet, buildURL } from \"imgix-url-builder\"\n\nimport type { ImageFieldImage } from \"../types/value/image\"\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\"\n\n/**\n * The default pixel densities used to generate a `srcset` value.\n */\nconst DEFAULT_PIXEL_DENSITIES = [1, 2, 3]\n\n/**\n * Configuration for `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetConfig = Omit<\n\tBuildPixelDensitySrcSetParams,\n\t\"pixelDensities\"\n> &\n\tPartial<Pick<BuildPixelDensitySrcSetParams, \"pixelDensities\">>\n\n/**\n * The return type of `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> =\n\tField extends ImageFieldImage<\"filled\">\n\t\t? {\n\t\t\t\t/**\n\t\t\t\t * The image field's image URL with Imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrc: string\n\n\t\t\t\t/**\n\t\t\t\t * A pixel-densitye-based `srcset` attribute value for the image field's\n\t\t\t\t * image with Imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrcset: string\n\t\t\t}\n\t\t: null\n\n/**\n * Creates a pixel-density-based `srcset` from an image field with optional\n * image transformations (via Imgix URL parameters).\n *\n * If a `pixelDensities` parameter is not given, the following pixel densities\n * will be used by default: 1, 2, 3.\n *\n * @example\n *\n * ```ts\n * const srcset = asImagePixelDensitySrcSet(document.data.imageField, {\n * \tpixelDensities: [1, 2],\n * \tsat: -100,\n * })\n * // => {\n * //   src:    'https://images.prismic.io/repo/image.png?sat=-100',\n * //   srcset: 'https://images.prismic.io/repo/image.png?sat=-100&dpr=1 1x, ' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&dpr=2 2x'\n * // }\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param config - An object of Imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for the image field with Imgix URL\n *   parameters (if given). If the image field is empty, `null` is returned.\n *\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImagePixelDensitySrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tconfig: AsImagePixelDensitySrcSetConfig = {},\n): AsImagePixelDensitySrcSetReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\t// We are using destructuring to omit `pixelDensities` from the\n\t\t// object we will pass to `buildURL()`.\n\t\tconst { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = config\n\n\t\treturn {\n\t\t\tsrc: buildURL(field.url, imgixParams),\n\t\t\tsrcset: buildPixelDensitySrcSet(field.url, {\n\t\t\t\t...imgixParams,\n\t\t\t\tpixelDensities,\n\t\t\t}),\n\t\t} as AsImagePixelDensitySrcSetReturnType<Field>\n\t} else {\n\t\treturn null as AsImagePixelDensitySrcSetReturnType<Field>\n\t}\n}\n"],"names":["isImageThumbnailFilled"],"mappings":";;;;;;;;AAUA,MAAM,0BAA0B;IAAC;IAAG;IAAG,CAAC;CAAA;AA+DjC,MAAM,4BAA4B,CAGxC,OACA,SAA0C,CAAA,CAAA,KACK;IAC3C,IAAA,SAASA,0LAAAA,EAAuB,KAAK,GAAG;QAG3C,MAAM,EAAE,iBAAiB,uBAAA,EAAyB,GAAG,aAAA,GAAgB;QAE9D,OAAA;YACN,KAAK,2KAAA,EAAS,MAAM,GAAA,EAAK,WAAW;YACpC,QAAQ,yMAAA,EAAwB,MAAM,GAAA,EAAK;gBAC1C,GAAG,WAAA;gBACH;YAAA,CACA;QAAA;IAAA,OAEI;QACC,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 4476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4482, "column": 0}, "map": {"version":3,"file":"asImageSrc.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asImageSrc.ts"],"sourcesContent":["import type { ImgixURLParams } from \"imgix-url-builder\"\nimport { buildURL } from \"imgix-url-builder\"\n\nimport type { ImageFieldImage } from \"../types/value/image\"\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\"\n\n/**\n * The return type of `asImageSrc()`.\n */\ntype AsImageSrcReturnType<Field extends ImageFieldImage | null | undefined> =\n\tField extends ImageFieldImage<\"filled\"> ? string : null\n\n/**\n * Returns the URL of an image field with optional image transformations (via\n * Imgix URL parameters).\n *\n * @example\n *\n * ```ts\n * const src = asImageSrc(document.data.imageField, { sat: -100 })\n * // => https://images.prismic.io/repo/image.png?sat=-100\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param config - An object of Imgix URL API parameters to transform the image.\n *\n * @returns The image field's image URL with transformations applied (if given).\n *   If the image field is empty, `null` is returned.\n *\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImageSrc = <Field extends ImageFieldImage | null | undefined>(\n\tfield: Field,\n\tconfig: ImgixURLParams = {},\n): AsImageSrcReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\treturn buildURL(field.url, config) as AsImageSrcReturnType<Field>\n\t} else {\n\t\treturn null as AsImageSrcReturnType<Field>\n\t}\n}\n"],"names":["isImageThumbnailFilled"],"mappings":";;;;;;;AAiCO,MAAM,aAAa,CACzB,OACA,SAAyB,CAAA,CAAA,KACO;IAC5B,IAAA,kLAASA,iBAAAA,EAAuB,KAAK,GAAG;QACpC,uKAAA,WAAA,EAAS,MAAM,GAAA,EAAK,MAAM;IAAA,OAC3B;QACC,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 4498, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4504, "column": 0}, "map": {"version":3,"file":"asImageWidthSrcSet.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asImageWidthSrcSet.ts"],"sourcesContent":["import type { BuildWidthSrcSetParams } from \"imgix-url-builder\"\nimport { buildURL, buildWidthSrcSet } from \"imgix-url-builder\"\n\nimport type { ImageFieldImage } from \"../types/value/image\"\n\nimport * as isFilled from \"./isFilled\"\n\n/**\n * The default widths used to generate a `srcset` value.\n */\nconst DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840]\n\n/**\n * The return type of `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> =\n\tField extends ImageFieldImage<\"filled\">\n\t\t? {\n\t\t\t\t/**\n\t\t\t\t * The image field's image URL with Imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrc: string\n\n\t\t\t\t/**\n\t\t\t\t * A width-based `srcset` attribute value for the image field's image\n\t\t\t\t * with Imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrcset: string\n\t\t\t}\n\t\t: null\n\n/**\n * Configuration for `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetConfig = Omit<BuildWidthSrcSetParams, \"widths\"> & {\n\twidths?: \"thumbnails\" | BuildWidthSrcSetParams[\"widths\"]\n}\n\n/**\n * Creates a width-based `srcset` from an image field with optional image\n * transformations (via Imgix URL parameters).\n *\n * If a `widths` parameter is not given, the following widths will be used by\n * default: 640, 750, 828, 1080, 1200, 1920, 2048, 3840.\n *\n * If the image field contains responsive views, each responsive view can be\n * used as a width in the resulting `srcset` by passing `\"thumbnails\"` as the\n * `widths` parameter.\n *\n * @example\n *\n * ```ts\n * const srcset = asImageWidthSrcSet(document.data.imageField, {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * })\n * // => {\n * //   src:    'https://images.prismic.io/repo/image.png?sat=-100',\n * //   srcset: 'https://images.prismic.io/repo/image.png?sat=-100&width=400 400w, ' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&width=800 800w,' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&width=1600 1600w'\n * // }\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param config - An object of Imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths. Pass `\"thumbnails\"` to automatically\n *   use the field's responsive views.\n *\n * @returns A `srcset` attribute value for the image field with Imgix URL\n *   parameters (if given). If the image field is empty, `null` is returned.\n *\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImageWidthSrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tconfig: AsImageWidthSrcSetConfig = {},\n): AsImageWidthSrcSetReturnType<Field> => {\n\tif (field && isFilled.imageThumbnail(field)) {\n\t\t// We are using destructuring to omit `widths` from the object\n\t\t// we will pass to `buildURL()`.\n\t\tlet {\n\t\t\twidths = DEFAULT_WIDTHS,\n\t\t\t// eslint-disable-next-line prefer-const\n\t\t\t...imgixParams\n\t\t} = config\n\t\tconst {\n\t\t\turl,\n\t\t\tdimensions,\n\t\t\tid: _id,\n\t\t\talt: _alt,\n\t\t\tcopyright: _copyright,\n\t\t\tedit: _edit,\n\t\t\t...responsiveViews\n\t\t} = field\n\n\t\t// The Prismic Rest API will always return thumbnail values if\n\t\t// the base size is filled.\n\t\tconst responsiveViewObjects: ImageFieldImage<\"filled\">[] =\n\t\t\tObject.values(responsiveViews)\n\n\t\t// If this `asImageWidthSrcSet()` call is configured to use\n\t\t// thumbnail widths, but the field does not have thumbnails, we\n\t\t// fall back to the default set of widths.\n\t\tif (widths === \"thumbnails\" && responsiveViewObjects.length < 1) {\n\t\t\twidths = DEFAULT_WIDTHS\n\t\t}\n\n\t\treturn {\n\t\t\tsrc: buildURL(url, imgixParams),\n\t\t\tsrcset:\n\t\t\t\t// By this point, we know `widths` can only be\n\t\t\t\t// `\"thubmanils\"` if the field has thumbnails.\n\t\t\t\twidths === \"thumbnails\"\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tbuildWidthSrcSet(url, {\n\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\twidths: [dimensions.width],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t...responsiveViewObjects.map((thumbnail) => {\n\t\t\t\t\t\t\t\treturn buildWidthSrcSet(thumbnail.url, {\n\t\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\t\twidths: [thumbnail.dimensions.width],\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t].join(\", \")\n\t\t\t\t\t: buildWidthSrcSet(field.url, {\n\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\twidths,\n\t\t\t\t\t\t}),\n\t\t} as AsImageWidthSrcSetReturnType<Field>\n\t} else {\n\t\treturn null as AsImageWidthSrcSetReturnType<Field>\n\t}\n}\n"],"names":["isFilled.imageThumbnail"],"mappings":";;;;;;;;AAUA,MAAM,iBAAiB;IAAC;IAAK;IAAK;IAAM;IAAM,IAAI;CAAA;AAmE3C,MAAM,qBAAqB,CAGjC,OACA,SAAmC,CAAA,CAAA,KACK;IACxC,IAAI,aAASA,sLAAAA,EAAwB,KAAK,GAAG;QAGxC,IAAA,EACH,SAAS,cAAA,EAAA,wCAAA;QAET,GAAG,aACA,GAAA;QACJ,MAAM,EACL,GAAA,EACA,UAAA,EACA,IAAI,GAAA,EACJ,KAAK,IAAA,EACL,WAAW,UAAA,EACX,MAAM,KAAA,EACN,GAAG,iBAAA,GACA;QAIE,MAAA,wBACL,OAAO,MAAA,CAAO,eAAe;QAK9B,IAAI,WAAW,gBAAgB,sBAAsB,MAAA,GAAS,GAAG;YACvD,SAAA;QACV;QAEO,OAAA;YACN,qKAAK,WAAA,EAAS,KAAK,WAAW;YAC9B,QAAA,8CAAA;YAAA,8CAAA;YAGC,WAAW,eACR;wLACA,mBAAA,EAAiB,KAAK;oBACrB,GAAG,WAAA;oBACH,QAAQ;wBAAC,WAAW,KAAK;qBAAA;gBAAA,CACzB;mBACE,sBAAsB,GAAA,CAAI,CAAC,cAAa;oBACnC,+KAAA,mBAAA,EAAiB,UAAU,GAAA,EAAK;wBACtC,GAAG,WAAA;wBACH,QAAQ;4BAAC,UAAU,UAAA,CAAW,KAAK;yBAAA;oBAAA,CACnC;gBAAA,CACD;aAAA,CACA,IAAA,CAAK,IAAI,IACV,2LAAA,EAAiB,MAAM,GAAA,EAAK;gBAC5B,GAAG,WAAA;gBACH;YAAA,CACA;QAAA;IAAA,OAEC;QACC,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 4558, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4564, "column": 0}, "map": {"version":3,"file":"isInternalURL.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/lib/isInternalURL.ts"],"sourcesContent":["/**\n * Determines if a URL is internal or external.\n *\n * @param url - The URL to check if internal or external.\n *\n * @returns `true` if `url` is internal, `false` otherwise.\n */\n// TODO: This does not detect all relative URLs as internal such as `about` or `./about`. This function assumes relative URLs start with a \"/\" or \"#\"`.\nexport const isInternalURL = (url: string): boolean => {\n\tconst isInternal = /^(\\/(?!\\/)|#)/.test(url)\n\tconst isSpecialLink = !isInternal && !/^https?:\\/\\//.test(url)\n\n\treturn isInternal && !isSpecialLink\n}\n"],"names":[],"mappings":";;;AAQa,MAAA,gBAAgB,CAAC,QAAwB;IAC/C,MAAA,aAAa,gBAAgB,IAAA,CAAK,GAAG;IAC3C,MAAM,gBAAgB,CAAC,cAAc,CAAC,eAAe,IAAA,CAAK,GAAG;IAE7D,OAAO,cAAc,CAAC;AACvB","ignoreList":[0]}},
    {"offset": {"line": 4574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4580, "column": 0}, "map": {"version":3,"file":"asLinkAttrs.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asLinkAttrs.ts"],"sourcesContent":["import { isInternalURL } from \"../lib/isInternalURL\"\n\nimport type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { FilledLinkToWebField, LinkField } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\n\nimport type { AsLinkReturnType, LinkResolverFunction } from \"./asLink\"\nimport { asLink } from \"./asLink\"\nimport { link as isFilledLink } from \"./isFilled\"\n\ntype AsLinkAttrsConfigRelArgs<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = {\n\thref:\n\t\t| NonNullable<AsLinkReturnType<LinkResolverFunctionReturnType, Field>>\n\t\t| undefined\n\tisExternal: boolean\n\ttarget?: string\n}\n\nexport type AsLinkAttrsConfig<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = {\n\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType>\n\trel?: (\n\t\targs: AsLinkAttrsConfigRelArgs<LinkResolverFunctionReturnType, Field>,\n\t) => string | undefined | void\n}\n\n/**\n * The return type of `asLinkAttrs()`.\n */\ntype AsLinkAttrsReturnType<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? {\n\t\t\thref:\n\t\t\t\t| NonNullable<AsLinkReturnType<LinkResolverFunctionReturnType, Field>>\n\t\t\t\t| undefined\n\t\t\ttarget?: string\n\t\t\trel?: string\n\t\t}\n\t: {\n\t\t\thref?: undefined\n\t\t\ttarget?: undefined\n\t\t\trel?: undefined\n\t\t}\n\n/**\n * Resolves any type of link field or Prismic document to a set of link\n * attributes. The attributes are designed to be passed to link HTML elements,\n * like `<a>`.\n *\n * If a resolved URL is external (i.e. starts with a protocol like `https://`),\n * `rel` is returned as `\"noreferrer\"`.\n *\n * @typeParam LinkResolverFunctionReturnType - link resolver function return\n *   type\n * @typeParam Field - Link field or Prismic document to resolve to link\n *   attributes\n *\n * @param linkFieldOrDocument - Any kind of link field or a document to resolve\n * @param config - Configuration that determines the output of `asLinkAttrs()`\n *\n * @returns Resolved set of link attributes or, if the provided link field or\n *   document is empty, and empty object\n *\n * @see Prismic link resolver documentation: {@link https://prismic.io/docs/route-resolver#link-resolver}\n * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/route-resolver}\n */\nexport const asLinkAttrs = <\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\tconfig: AsLinkAttrsConfig<LinkResolverFunctionReturnType> = {},\n): AsLinkAttrsReturnType<LinkResolverFunctionReturnType> => {\n\tif (\n\t\tlinkFieldOrDocument &&\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t(\"link_type\" in linkFieldOrDocument\n\t\t\t? isFilledLink(linkFieldOrDocument)\n\t\t\t: linkFieldOrDocument)\n\t) {\n\t\tconst target =\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t\t\"target\" in linkFieldOrDocument ? linkFieldOrDocument.target : undefined\n\n\t\tconst rawHref = asLink(linkFieldOrDocument, config.linkResolver)\n\t\tconst href =\n\t\t\trawHref == null ? undefined : (rawHref as NonNullable<typeof rawHref>)\n\n\t\tconst isExternal = typeof href === \"string\" ? !isInternalURL(href) : false\n\n\t\tconst rel = config.rel\n\t\t\t? config.rel({ href, isExternal, target })\n\t\t\t: isExternal\n\t\t\t\t? \"noreferrer\"\n\t\t\t\t: undefined\n\n\t\treturn {\n\t\t\thref,\n\t\t\ttarget,\n\t\t\trel: rel == null ? undefined : rel,\n\t\t}\n\t}\n\n\treturn {}\n}\n"],"names":["isFilledLink"],"mappings":";;;;;;;;;AA0FO,MAAM,cAAc,CAQ1B,qBACA,SAA4D,CAAA,CAAA,KACF;IAEzD,IAAA,uBAAA,6DAAA;IAAA,2FAAA;IAAA,CAGC,eAAe,+LACbA,OAAAA,EAAa,mBAAmB,IAChC,mBAAA,GACF;QACK,MAAA,SAAA,6DAAA;QAAA,2FAAA;QAGL,YAAY,sBAAsB,oBAAoB,MAAA,GAAS,KAAA;QAEhE,MAAM,iLAAU,SAAA,EAAO,qBAAqB,OAAO,YAAY;QACzD,MAAA,OACL,WAAW,OAAO,KAAA,IAAa;QAEhC,MAAM,aAAa,OAAO,SAAS,WAAW,2KAAC,gBAAA,EAAc,IAAI,IAAI;QAErE,MAAM,MAAM,OAAO,GAAA,GAChB,OAAO,GAAA,CAAI;YAAE;YAAM;YAAY;QAAM,CAAE,IACvC,aACC,eACA,KAAA;QAEG,OAAA;YACN;YACA;YACA,KAAK,OAAO,OAAO,KAAA,IAAY;QAAA;IAEjC;IAEA,OAAO,CAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 4614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4620, "column": 0}, "map": {"version":3,"file":"asText.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/richtext/asText.ts"],"sourcesContent":["import type { RTTextNode, RichTextField } from \"../types/value/richText\"\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n *\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\"\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text\n\t\t}\n\t}\n\n\treturn result\n}\n"],"names":[],"mappings":";;;AAYO,MAAM,SAAS,CACrB,eACA,YAAY,GAAA,KACD;IACX,IAAI,SAAS;IAEb,IAAA,IAAS,IAAI,GAAG,IAAI,cAAc,MAAA,EAAQ,IAAK;QAC1C,IAAA,UAAU,aAAA,CAAc,CAAC,CAAA,EAAG;YAC/B,UAAA,CACE,SAAS,YAAY,EAAA,IAAO,aAAA,CAAc,CAAC,CAAA,CAAiB,IAAA;QAC/D;IACD;IAEO,OAAA;AACR","ignoreList":[0]}},
    {"offset": {"line": 4634, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4640, "column": 0}, "map": {"version":3,"file":"asText.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/helpers/asText.ts"],"sourcesContent":["import type { RichTextField } from \"../types/value/richText\"\n\nimport { asText as baseAsText } from \"../richtext/asText\"\n\n/**\n * Configuration that determines the output of `asText()`.\n */\ntype AsTextConfig = {\n\t/**\n\t * Separator used to join each element.\n\t *\n\t * @defaultValue ` ` (a space)\n\t */\n\tseparator?: string\n}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsTextDeprecatedTupleConfig = [separator?: string]\n\n/**\n * The return type of `asText()`.\n */\ntype AsTextReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null\n\nexport const asText: {\n\t/**\n\t * Serializes a rich text or title field to a plain text string.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param config - Configuration that determines the output of `asText()`\n\t *\n\t * @returns Plain text equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsTextConfig,\n\t): AsTextReturnType<Field>\n\n\t/**\n\t * Serializes a rich text or title field to a plain text string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text or title field from Prismic\n\t * @param separator - Separator used to join each element, defaults to a space\n\t *\n\t * @returns Plain text equivalent of the provided rich text or title field\n\t *\n\t * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/template-content-vanilla-javascript#rich-text-and-title}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsTextDeprecatedTupleConfig\n\t): AsTextReturnType<Field>\n} = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple: [config?: AsTextConfig] | AsTextDeprecatedTupleConfig\n): AsTextReturnType<Field> => {\n\tif (richTextField) {\n\t\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\t\tconst [configObjectOrSeparator] = configObjectOrTuple\n\t\tlet config: AsTextConfig\n\t\tif (typeof configObjectOrSeparator === \"string\") {\n\t\t\tconfig = {\n\t\t\t\tseparator: configObjectOrSeparator,\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = { ...configObjectOrSeparator }\n\t\t}\n\n\t\treturn baseAsText(\n\t\t\trichTextField,\n\t\t\tconfig.separator,\n\t\t) as AsTextReturnType<Field>\n\t} else {\n\t\treturn null as AsTextReturnType<Field>\n\t}\n}\n"],"names":["baseAsText"],"mappings":";;;;;AA4Ba,MAAA,SAgCT,CACH,eAAA,GAEG,wBACyB;IAC5B,IAAI,eAAe;QAEZ,MAAA,CAAC,uBAAuB,CAAA,GAAI;QAC9B,IAAA;QACA,IAAA,OAAO,4BAA4B,UAAU;YACvC,SAAA;gBACR,WAAW;YAAA;QAAA,OAEN;YACG,SAAA;gBAAE,GAAG,uBAAA;YAAA;QACf;QAEO,+KAAAA,SAAAA,EACN,eACA,OAAO,SAAS;IAAA,OAEX;QACC,OAAA;IACR;AACD","ignoreList":[0]}},
    {"offset": {"line": 4665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4671, "column": 0}, "map": {"version":3,"file":"createClient.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/createClient.ts"],"sourcesContent":["import type { PrismicDocument } from \"./types/value/document\"\n\nimport type { ClientConfig } from \"./Client\"\nimport { Client } from \"./Client\"\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>\n}\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name.\n * createClient(\"qwerty\")\n *\n * // Or with a full Prismic Rest API V2 endpoint.\n * createClient(\"https://qwerty.cdn.prismic.io/api/v2\")\n * ```\n *\n * @typeParam TDocuments - A union of Prismic document types for the repository.\n *\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n *   API V2 endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient: CreateClient = <TDocuments extends PrismicDocument>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options)\n"],"names":[],"mappings":";;;;;AAqCO,MAAM,eAA6B,CACzC,0BACA,UACI,4JAAI,SAAA,CAAmB,0BAA0B,OAAO","ignoreList":[0]}},
    {"offset": {"line": 4679, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4685, "column": 0}, "map": {"version":3,"file":"createMigration.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/createMigration.ts"],"sourcesContent":["import type { PrismicDocument } from \"./types/value/document\"\n\nimport { Migration } from \"./Migration\"\n\n/**\n * Type definitions for the `createMigration()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateMigration {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Migration>\n\t): Migration<TDocuments>\n}\n\n/**\n * Creates a Prismic migration instance that can be used to prepare your\n * migration to Prismic.\n *\n * @example\n *\n * ```ts\n * createMigration()\n * ```\n *\n * @typeParam TDocuments - A union of Prismic document types for the repository.\n *\n * @returns A migration instance to prepare your migration.\n */\nexport const createMigration: CreateMigration = <\n\tTDocuments extends PrismicDocument,\n>() => new Migration<TDocuments>()\n"],"names":[],"mappings":";;;;;AA4Ba,MAAA,kBAAmC,IAEzC,+JAAI,YAAA,CAAS","ignoreList":[0]}},
    {"offset": {"line": 4693, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4699, "column": 0}, "map": {"version":3,"file":"createWriteClient.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/createWriteClient.ts"],"sourcesContent":["import type { PrismicDocument } from \"./types/value/document\"\n\nimport type { WriteClientConfig } from \"./WriteClient\"\nimport { WriteClient } from \"./WriteClient\"\n\n/**\n * Type definitions for the `createWriteClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateWriteClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof WriteClient>\n\t): WriteClient<TDocuments>\n}\n\n/**\n * Creates a Prismic client that can be used to query and write content to a\n * repository.\n *\n * @remarks\n * This client works in environments supporting File, Blob, and FormData,\n * including Node.js 20 and later.\n *\n * @example\n *\n * ```ts\n * createWriteClient(\"qwerty\", { writeToken: \"***\" })\n * ```\n *\n * @typeParam TDocuments - A union of Prismic document types for the repository.\n *\n * @param repositoryName - The Prismic repository name for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from and written to the Prismic repository.\n *\n * @returns A client that can query and write content to the repository.\n */\nexport const createWriteClient: CreateWriteClient = <\n\tTDocuments extends PrismicDocument,\n>(\n\trepositoryName: string,\n\toptions: WriteClientConfig,\n) => new WriteClient<TDocuments>(repositoryName, options)\n"],"names":[],"mappings":";;;;;AAqCO,MAAM,oBAAuC,CAGnD,gBACA,UACI,iKAAI,cAAA,CAAwB,gBAAgB,OAAO","ignoreList":[0]}},
    {"offset": {"line": 4707, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4713, "column": 0}, "map": {"version":3,"file":"getGraphQLEndpoint.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/getGraphQLEndpoint.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Get a repository's Prismic GraphQL endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getGraphQLEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/graphql` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/graphql` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAaa,MAAA,qBAAqB,CACjC,mBACuD;IACnD,0KAAA,mBAAA,EAAiB,cAAc,GAAG;QACrC,OAAO,CAAA,QAAA,EAAW,cAAc,CAAA,uBAAA,CAAA;IAAA,OAC1B;QACN,MAAM,4KAAI,eAAA,CACT,CAAA,8CAAA,EAAiD,cAAc,EAAA,EAC/D,KAAA,GACA,KAAA,CAAS;IAEX;AACD","ignoreList":[0]}},
    {"offset": {"line": 4729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4735, "column": 0}, "map": {"version":3,"file":"getToolbarSrc.js","sources":["file:///Users/agimanifesto/_dev/portfolio/node_modules/%40prismicio/src/getToolbarSrc.ts"],"sourcesContent":["import { PrismicError } from \"./errors/PrismicError\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Returns the URL for a Prismic repository's Prismic Toolbar script. Use the\n * URL to inject the script into your app.\n *\n * @example\n *\n * ```typescriptreact\n * // In Next.js apps, use `next/script` in your `app/layout.tsx` file.\n *\n * import Script from \"next/script\";\n * import * as prismic from \"@prismicio/client\";\n *\n * export default function RootLayout({\n * \tchildren,\n * }: {\n * \tchildren: React.ReactNode,\n * }) {\n * \tconst toolbarSrc = prismic.getToolbarSrc(\"my-repo\");\n *\n * \treturn (\n * \t\t<html lang=\"en\">\n * \t\t\t<body>{children}</body>\n * \t\t\t<Script src={toolbarSrc} />\n * \t\t</html>\n * \t);\n * }\n * ```\n *\n * @param repositoryName - The name of the Prismic repository. For example,\n *   `\"my-repo\"` if the repository URL is `my-repo.prismic.io`.\n *\n * @returns The URL for the given Prismic repository's Prismic Toolbar script.\n */\nexport const getToolbarSrc = <TRepositoryName extends string>(\n\trepositoryName: TRepositoryName,\n): `https://static.cdn.prismic.io/prismic.js?new=true&repo=${TRepositoryName}` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://static.cdn.prismic.io/prismic.js?new=true&repo=${repositoryName}` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAqCa,MAAA,gBAAgB,CAC5B,mBACgF;IAC5E,0KAAA,mBAAA,EAAiB,cAAc,GAAG;QACrC,OAAO,CAAA,uDAAA,EAA0D,cAAc,EAAA;IAAA,OACzE;QACN,MAAM,4KAAI,eAAA,CACT,CAAA,8CAAA,EAAiD,cAAc,EAAA,EAC/D,KAAA,GACA,KAAA,CAAS;IAEX;AACD","ignoreList":[0]}},
    {"offset": {"line": 4751, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}